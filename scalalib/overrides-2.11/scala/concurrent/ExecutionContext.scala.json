[
  {
    "id" : "5041331c-b081-40d7-b925-36ce33ebc06b",
    "prId" : 621,
    "comments" : [
      {
        "id" : "30e48a25-5420-4b87-9a78-ad798898f529",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "That's the only method overriden here.",
        "createdAt" : "2017-04-05T15:31:18Z",
        "updatedAt" : "2017-04-10T12:24:08Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "519a04ea55e644018688f8debbd0684e3d3a7ab7",
    "line" : 131,
    "diffHunk" : "@@ -0,0 +1,181 @@\n+/*                     __                                               *\\\n+**     ________ ___   / /  ___     Scala API                            **\n+**    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             **\n+**  __\\ \\/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **\n+** /____/\\___/_/ |_/____/_/ | |                                         **\n+**                          |/                                          **\n+\\*                                                                      */\n+\n+package scala.concurrent\n+\n+\n+import java.util.concurrent.{ ExecutorService, Executor }\n+import scala.annotation.implicitNotFound\n+import scala.util.Try\n+\n+/**\n+ * An `ExecutionContext` can execute program logic asynchronously,\n+ * typically but not necessarily on a thread pool.\n+ *\n+ * A general purpose `ExecutionContext` must be asynchronous in executing\n+ * any `Runnable` that is passed into its `execute`-method. A special purpose\n+ * `ExecutionContext` may be synchronous but must only be passed to code that\n+ * is explicitly safe to be run using a synchronously executing `ExecutionContext`.\n+ *\n+ * APIs such as `Future.onComplete` require you to provide a callback\n+ * and an implicit `ExecutionContext`. The implicit `ExecutionContext`\n+ * will be used to execute the callback.\n+ *\n+ * It is possible to simply import\n+ * `scala.concurrent.ExecutionContext.Implicits.global` to obtain an\n+ * implicit `ExecutionContext`. This global context is a reasonable\n+ * default thread pool.\n+ *\n+ * However, application developers should carefully consider where they\n+ * want to set policy; ideally, one place per application (or per\n+ * logically-related section of code) will make a decision about\n+ * which `ExecutionContext` to use. That is, you might want to avoid\n+ * hardcoding `scala.concurrent.ExecutionContext.Implicits.global` all\n+ * over the place in your code.\n+ * One approach is to add `(implicit ec: ExecutionContext)`\n+ * to methods which need an `ExecutionContext`. Then import a specific\n+ * context in one place for the entire application or module,\n+ * passing it implicitly to individual methods.\n+ *\n+ * A custom `ExecutionContext` may be appropriate to execute code\n+ * which blocks on IO or performs long-running computations.\n+ * `ExecutionContext.fromExecutorService` and `ExecutionContext.fromExecutor`\n+ * are good ways to create a custom `ExecutionContext`.\n+ *\n+ * The intent of `ExecutionContext` is to lexically scope code execution.\n+ * That is, each method, class, file, package, or application determines\n+ * how to run its own code. This avoids issues such as running\n+ * application callbacks on a thread pool belonging to a networking library.\n+ * The size of a networking library's thread pool can be safely configured,\n+ * knowing that only that library's network operations will be affected.\n+ * Application callback execution can be configured separately.\n+ */\n+@implicitNotFound(\"\"\"Cannot find an implicit ExecutionContext. You might pass\n+an (implicit ec: ExecutionContext) parameter to your method\n+or import scala.concurrent.ExecutionContext.Implicits.global.\"\"\")\n+trait ExecutionContext {\n+\n+  /** Runs a block of code on this execution context.\n+   *\n+   *  @param runnable  the task to execute\n+   */\n+  def execute(runnable: Runnable): Unit\n+\n+  /** Reports that an asynchronous computation failed.\n+   *\n+   *  @param cause  the cause of the failure\n+   */\n+  def reportFailure(@deprecatedName('t) cause: Throwable): Unit\n+\n+  /** Prepares for the execution of a task. Returns the prepared execution context.\n+   *\n+   *  `prepare` should be called at the site where an `ExecutionContext` is received (for\n+   *  example, through an implicit method parameter). The returned execution context may\n+   *  then be used to execute tasks. The role of `prepare` is to save any context relevant\n+   *  to an execution's ''call site'', so that this context may be restored at the\n+   *  ''execution site''. (These are often different: for example, execution may be\n+   *  suspended through a `Promise`'s future until the `Promise` is completed, which may\n+   *  be done in another thread, on another stack.)\n+   *\n+   *  Note: a valid implementation of `prepare` is one that simply returns `this`.\n+   *\n+   *  @return the prepared execution context\n+   */\n+  def prepare(): ExecutionContext = this\n+\n+}\n+\n+/**\n+ * An [[ExecutionContext]] that is also a\n+ * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html Executor]].\n+ */\n+trait ExecutionContextExecutor extends ExecutionContext with Executor\n+\n+/**\n+ * An [[ExecutionContext]] that is also a\n+ * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html ExecutorService]].\n+ */\n+trait ExecutionContextExecutorService extends ExecutionContextExecutor with ExecutorService\n+\n+\n+/** Contains factory methods for creating execution contexts.\n+ */\n+object ExecutionContext {\n+  /**\n+   * The explicit global `ExecutionContext`. Invoke `global` when you want to provide the global\n+   * `ExecutionContext` explicitly.\n+   *\n+   * The default `ExecutionContext` implementation is backed by a work-stealing thread pool. By default,\n+   * the thread pool uses a target number of worker threads equal to the number of\n+   * [[https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#availableProcessors-- available processors]].\n+   *\n+   * @return the global `ExecutionContext`\n+   */\n+  def global: ExecutionContextExecutor = Implicits.global\n+\n+  object Implicits {\n+    /**\n+     * The implicit global `ExecutionContext`. Import `global` when you want to provide the global\n+     * `ExecutionContext` implicitly.\n+     *\n+     * The default `ExecutionContext` implementation is backed by a work-stealing thread pool. By default,\n+     * the thread pool uses a target number of worker threads equal to the number of\n+     * [[https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#availableProcessors-- available processors]].\n+     */\n+    implicit lazy val global: ExecutionContextExecutor =\n+      scala.scalanative.runtime.ExecutionContext.global"
  }
]
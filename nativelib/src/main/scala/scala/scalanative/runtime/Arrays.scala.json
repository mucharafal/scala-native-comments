[
  {
    "id" : "ac7dfb28-2092-4dff-8568-28e49dc3ab5d",
    "prId" : 184,
    "comments" : [
      {
        "id" : "ea517654-0ab4-4a41-a94c-81348ce0115f",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Object array copy should have the same implementation as we have now for primitives. We won't check safety of covariant casts, but that's fine for now, nobody does that anyway.\n",
        "createdAt" : "2016-06-20T16:17:55Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    "
  },
  {
    "id" : "c23aff73-c1f4-455a-9fea-b6357deff00e",
    "prId" : 184,
    "comments" : [
      {
        "id" : "f9b0dae9-2790-441c-a827-938285337730",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Obvious comments should not be included.\n",
        "createdAt" : "2016-06-20T16:18:40Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */"
  },
  {
    "id" : "7d17e900-11b7-45c0-b1c5-922154e7fbdc",
    "prId" : 184,
    "comments" : [
      {
        "id" : "22bcb6a8-d5f0-4dc5-b47c-c472a14d9a9f",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Please use javadoc style comments for documenting methods. \n",
        "createdAt" : "2016-06-20T16:20:17Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   "
  },
  {
    "id" : "4668c5c7-bd94-4f31-bdcf-31574c55a104",
    "prId" : 184,
    "comments" : [
      {
        "id" : "d62013a0-7c76-47ac-8786-9df403243d2d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Better name for this is `stride`.\n",
        "createdAt" : "2016-06-20T16:22:29Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   \n+  private[runtime] def validateBoundaries (from: Array[_], fromPos: Int, to: Array[_], toPos: Int, len: Int): Int = {\n+    if (len < 0)\n+      throw new IndexOutOfBoundsException(\"length is negative\")\n+\n+    if (fromPos < 0 || fromPos + len > from.length)\n+      throw new IndexOutOfBoundsException(fromPos.toString)\n+\n+    if (toPos < 0 || toPos + len > to.length)\n+      throw new IndexOutOfBoundsException(toPos.toString)\n+    \n+    if (from == to) {\n+      if (fromPos < toPos && fromPos + len > toPos)\n+        -1  // backward copy\n+      else if (fromPos > toPos && toPos + len > fromPos)\n+        1 // forward copy\n+      else\n+        0\n     }\n-\n-  protected override def clone(): ObjectArray = {\n-    val newarr = ObjectArray.alloc(length)\n-    ObjectArray.copy(this, 0, newarr, 0, length)\n-    newarr\n+    else\n+      0\n   }\n+     \n+  /*\n+   * only used by ObjectArray\n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrinfo, arrsize)\n+    // set the length\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n+  } \n }\n \n-object ObjectArray {\n-  def copy(from: ObjectArray, fromPos: Int,\n-           to: ObjectArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+/*\n+ * \n+ */\n+ \n+abstract class PrimitiveArray[T] extends Array[T] {\n+  /** called by subclass::clone.  Allocate memory using GC_malloc_atomic and copy header and data */\n+  override protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.allocAtomic(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr\n+  }  \n+}\n \n-  def alloc(length: Int): ObjectArray = {\n-    val arrty = typeof[ObjectArray]\n-    val arrsize = sizeof[ArrayHeader] + sizeof[Object] * length\n-    val arr = runtime.alloc(arrty, arrsize)\n+/*\n+ * \n+ */\n+\n+object PrimitiveArray {\n+  /*\n+   * Primitive arrays don't contain pointers \n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.allocAtomic(arrinfo, arrsize)\n     // set the length\n-    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length\n-    arr.cast[ObjectArray]\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n   }\n }\n \n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 79)\n+/*\n+ *\n+ */\n+final class ObjectArray private () extends Array[Object] {\n+  def apply(i: Int): Object = ! (pointerAt(sizeof[Object], i).cast[Ptr[Object]])\n \n-final class BooleanArray private () extends Array[Boolean] {\n-  def apply(i: Int): Boolean =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Boolean]]\n-      headptr(i)\n-    }\n+  def update(i: Int, value: Object): Unit = ! (pointerAt(sizeof[Object], i).cast[Ptr[Object]]) = value\n \n-  def update(i: Int, value: Boolean): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Boolean]]\n-      headptr(i) = value\n-    }\n+  protected override def clone(): ObjectArray = helperClone (sizeof[Object]).cast[ObjectArray]  \n+}\n \n-  protected override def clone(): BooleanArray = {\n-    val newarr = BooleanArray.alloc(length)\n-    BooleanArray.copy(this, 0, newarr, 0, length)\n-    newarr\n-  }\n+object ObjectArray {\n+  def alloc(length: Int): ObjectArray = Array.alloc(length, typeof[ObjectArray], sizeof[Object]).cast[ObjectArray]\n }\n \n-object BooleanArray {\n-  def copy(from: BooleanArray, fromPos: Int,\n-           to: BooleanArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 210)\n \n-  def alloc(length: Int): BooleanArray = {\n-    val arrty = typeof[BooleanArray]\n-    val arrsize = sizeof[ArrayHeader] + sizeof[Boolean] * length\n-    val arr = runtime.allocAtomic(arrty, arrsize)\n-    // set the length\n-    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length\n-    arr.cast[BooleanArray]\n-  }\n-}\n+final class BooleanArray private () extends PrimitiveArray[Boolean] {\n+  def apply(i: Int): Boolean = ! (pointerAt(sizeof[Boolean], i).cast[Ptr[Boolean]])\n \n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 79)\n+  def update(i: Int, value: Boolean): Unit = ! (pointerAt(sizeof[Boolean], i).cast[Ptr[Boolean]]) = value\n \n-final class CharArray private () extends Array[Char] {\n-  def apply(i: Int): Char =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Char]]\n-      headptr(i)\n-    }\n+  protected override def clone(): BooleanArray = helperClone (sizeof[Boolean]).cast[BooleanArray]\n+  \n+  protected def copyTo (fromPos: Int, toPos: Int): Unit = update (toPos, apply(fromPos)) \n \n-  def update(i: Int, value: Char): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Char]]\n-      headptr(i) = value\n+  def sizeofElement: CSize = sizeof[Boolean]"
  },
  {
    "id" : "ebd06e94-b500-43fa-914f-9cabbf44097f",
    "prId" : 184,
    "comments" : [
      {
        "id" : "fdc1742b-f40a-4eb9-bc38-7cd70eb94271",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one should be a single-line comment right above `allocAtomic` call. Doc comments should document what corresponding methods do, not how they do it. \n",
        "createdAt" : "2016-06-20T16:24:07Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   \n+  private[runtime] def validateBoundaries (from: Array[_], fromPos: Int, to: Array[_], toPos: Int, len: Int): Int = {\n+    if (len < 0)\n+      throw new IndexOutOfBoundsException(\"length is negative\")\n+\n+    if (fromPos < 0 || fromPos + len > from.length)\n+      throw new IndexOutOfBoundsException(fromPos.toString)\n+\n+    if (toPos < 0 || toPos + len > to.length)\n+      throw new IndexOutOfBoundsException(toPos.toString)\n+    \n+    if (from == to) {\n+      if (fromPos < toPos && fromPos + len > toPos)\n+        -1  // backward copy\n+      else if (fromPos > toPos && toPos + len > fromPos)\n+        1 // forward copy\n+      else\n+        0\n     }\n-\n-  protected override def clone(): ObjectArray = {\n-    val newarr = ObjectArray.alloc(length)\n-    ObjectArray.copy(this, 0, newarr, 0, length)\n-    newarr\n+    else\n+      0\n   }\n+     \n+  /*\n+   * only used by ObjectArray\n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrinfo, arrsize)\n+    // set the length\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n+  } \n }\n \n-object ObjectArray {\n-  def copy(from: ObjectArray, fromPos: Int,\n-           to: ObjectArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+/*\n+ * \n+ */\n+ \n+abstract class PrimitiveArray[T] extends Array[T] {\n+  /** called by subclass::clone.  Allocate memory using GC_malloc_atomic and copy header and data */\n+  override protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.allocAtomic(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr\n+  }  \n+}\n \n-  def alloc(length: Int): ObjectArray = {\n-    val arrty = typeof[ObjectArray]\n-    val arrsize = sizeof[ArrayHeader] + sizeof[Object] * length\n-    val arr = runtime.alloc(arrty, arrsize)\n+/*\n+ * \n+ */\n+\n+object PrimitiveArray {\n+  /*\n+   * Primitive arrays don't contain pointers \n+   */   "
  },
  {
    "id" : "ca25dc5a-3a31-42cc-b3df-7271f0290498",
    "prId" : 184,
    "comments" : [
      {
        "id" : "bedd34f9-0852-4d69-9a8d-f078a3fc0914",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This comment doesn't give any valuable information.\n",
        "createdAt" : "2016-06-20T16:25:42Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   \n+  private[runtime] def validateBoundaries (from: Array[_], fromPos: Int, to: Array[_], toPos: Int, len: Int): Int = {\n+    if (len < 0)\n+      throw new IndexOutOfBoundsException(\"length is negative\")\n+\n+    if (fromPos < 0 || fromPos + len > from.length)\n+      throw new IndexOutOfBoundsException(fromPos.toString)\n+\n+    if (toPos < 0 || toPos + len > to.length)\n+      throw new IndexOutOfBoundsException(toPos.toString)\n+    \n+    if (from == to) {\n+      if (fromPos < toPos && fromPos + len > toPos)\n+        -1  // backward copy\n+      else if (fromPos > toPos && toPos + len > fromPos)\n+        1 // forward copy\n+      else\n+        0\n     }\n-\n-  protected override def clone(): ObjectArray = {\n-    val newarr = ObjectArray.alloc(length)\n-    ObjectArray.copy(this, 0, newarr, 0, length)\n-    newarr\n+    else\n+      0\n   }\n+     \n+  /*\n+   * only used by ObjectArray\n+   */   "
  },
  {
    "id" : "86675258-c470-466b-b29b-bfd4460f407d",
    "prId" : 184,
    "comments" : [
      {
        "id" : "421cf255-68a1-4157-b9f5-f97fe93473a1",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Trailing whitespace should not be there.\n",
        "createdAt" : "2016-06-20T16:28:13Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -1,28 +1,33 @@\n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 1)\n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 1)\n package scala.scalanative\n package runtime\n \n // Note 1:\n-// Arrays.scala is currently implemented as textual templating that is expanded through project/gyb.py script.\n+// Arrays.scala is currently implemented as textual templating that is expanded through project/gyb.py script. \n // Update Arrays.scala.gyb and re-generate the source\n \n // Note 2:\n-// Array of primitiveTypes don't contain pointers, runtime.allocAtomic() is called for memory allocation\n+// Array of primitiveTypes don't contain pointers, runtime.allocAtomic() is called for memory allocation   "
  },
  {
    "id" : "b7cc2b84-77c2-462c-aaf4-eab8832db970",
    "prId" : 184,
    "comments" : [
      {
        "id" : "c2932c00-51b7-4bf9-a1c8-ad9430c4741d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Obvious comment. \n",
        "createdAt" : "2016-06-20T16:30:10Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   \n+  private[runtime] def validateBoundaries (from: Array[_], fromPos: Int, to: Array[_], toPos: Int, len: Int): Int = {\n+    if (len < 0)\n+      throw new IndexOutOfBoundsException(\"length is negative\")\n+\n+    if (fromPos < 0 || fromPos + len > from.length)\n+      throw new IndexOutOfBoundsException(fromPos.toString)\n+\n+    if (toPos < 0 || toPos + len > to.length)\n+      throw new IndexOutOfBoundsException(toPos.toString)\n+    \n+    if (from == to) {\n+      if (fromPos < toPos && fromPos + len > toPos)\n+        -1  // backward copy\n+      else if (fromPos > toPos && toPos + len > fromPos)\n+        1 // forward copy\n+      else\n+        0\n     }\n-\n-  protected override def clone(): ObjectArray = {\n-    val newarr = ObjectArray.alloc(length)\n-    ObjectArray.copy(this, 0, newarr, 0, length)\n-    newarr\n+    else\n+      0\n   }\n+     \n+  /*\n+   * only used by ObjectArray\n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrinfo, arrsize)\n+    // set the length\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n+  } \n }\n \n-object ObjectArray {\n-  def copy(from: ObjectArray, fromPos: Int,\n-           to: ObjectArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+/*\n+ * \n+ */\n+ \n+abstract class PrimitiveArray[T] extends Array[T] {\n+  /** called by subclass::clone.  Allocate memory using GC_malloc_atomic and copy header and data */"
  },
  {
    "id" : "f6d101e8-6cec-4ecc-83b4-0bbe26f8044d",
    "prId" : 184,
    "comments" : [
      {
        "id" : "aec986d0-f2fd-49c7-9937-db7a10c8fc54",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Can't we just use `memmove` here? That's what apache harmony does for copying arrays. You can find their implementation in `array_copy` function that is located in `vm_arrays.cpp`.\n",
        "createdAt" : "2016-06-21T12:03:46Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc653f9a-d16f-4e8f-b86f-2b7ea0bb3496",
        "parentId" : "aec986d0-f2fd-49c7-9937-db7a10c8fc54",
        "author" : {
          "login" : "fbertra",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/18035?v=4"
        },
        "body" : "Of course, it is possible.\n\nI thought a LLVM intrinsics only version was better.\n",
        "createdAt" : "2016-06-21T14:08:21Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "fbertra",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/18035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cce41b01-50be-4ac5-81bf-df5ec429b129",
        "parentId" : "aec986d0-f2fd-49c7-9937-db7a10c8fc54",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "But it's fine, LLVM has memmove too (see `llvm.memmove.*` intrinsics.)\n",
        "createdAt" : "2016-06-21T14:18:40Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -31,381 +36,698 @@ sealed abstract class Array[T]\n \n   /** Create a shallow of given array. */\n   protected override def clone(): Array[T] = undefined\n-}\n-\n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n+  \n+  /*\n+   * helper methods\n+   */\n+   \n+  /** called by subclass::apply and subclass::update */\n+  protected def pointerAt(sizeOneElement: CSize, i: Int): Ptr[_] = {\n     if (i < 0 || i >= length)\n       throw new IndexOutOfBoundsException(i.toString)\n     else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n+      (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeOneElement * i).cast[Ptr[_]]\n     }\n+  }\n+  \n+  /** called by subclass::clone.  Allocate memory and copy header and data */\n+  protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr        \n+  }  \n+}\n \n-  def update(i: Int, value: Object): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i) = value\n+/** Utilities methods\n+  *\n+  */\n+\n+object Array {\n+  /*\n+   *\n+   */    \n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId) \n+      throw new ArrayStoreException (\"copy from object array to object array isn't implemented yet\")    \n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 86)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 91)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")\n+  }\n+  \n+  /*\n+   * the id's chosen by the compiler/linker for differents types of array\n+   */\n+\n+  val arrayObjectTypeId = typeId (typeof[scalanative.runtime.ObjectArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayBooleanTypeId = typeId (typeof[scalanative.runtime.BooleanArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayCharTypeId = typeId (typeof[scalanative.runtime.CharArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayByteTypeId = typeId (typeof[scalanative.runtime.ByteArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayShortTypeId = typeId (typeof[scalanative.runtime.ShortArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayIntTypeId = typeId (typeof[scalanative.runtime.IntArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayLongTypeId = typeId (typeof[scalanative.runtime.LongArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayFloatTypeId = typeId (typeof[scalanative.runtime.FloatArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 103)\n+\n+  val arrayDoubleTypeId = typeId (typeof[scalanative.runtime.DoubleArray])\n+  \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 107)\n+    \n+  /** \n+    *\n+    */      \n+  private def typeId (ptr : Ptr[Type]): Int = {\n+    (!ptr).id    \n+  }\n+  \n+  /** \n+    *\n+    */      \n+  private def instanceTypeId (any : AnyRef): Int = {\n+    typeId(runtime.getType(any))\n+  }\n+  \n+  /*\n+   * validate boundaries and check overlap\n+   *\n+   * return:\n+   *  == 0: no overlap\n+   *  != 0: overlap, the sign indicates if forward or backward copy is needed   \n+   */   \n+  private[runtime] def validateBoundaries (from: Array[_], fromPos: Int, to: Array[_], toPos: Int, len: Int): Int = {\n+    if (len < 0)\n+      throw new IndexOutOfBoundsException(\"length is negative\")\n+\n+    if (fromPos < 0 || fromPos + len > from.length)\n+      throw new IndexOutOfBoundsException(fromPos.toString)\n+\n+    if (toPos < 0 || toPos + len > to.length)\n+      throw new IndexOutOfBoundsException(toPos.toString)\n+    \n+    if (from == to) {\n+      if (fromPos < toPos && fromPos + len > toPos)\n+        -1  // backward copy\n+      else if (fromPos > toPos && toPos + len > fromPos)\n+        1 // forward copy\n+      else\n+        0\n     }\n-\n-  protected override def clone(): ObjectArray = {\n-    val newarr = ObjectArray.alloc(length)\n-    ObjectArray.copy(this, 0, newarr, 0, length)\n-    newarr\n+    else\n+      0\n   }\n+     \n+  /*\n+   * only used by ObjectArray\n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.alloc(arrinfo, arrsize)\n+    // set the length\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n+  } \n }\n \n-object ObjectArray {\n-  def copy(from: ObjectArray, fromPos: Int,\n-           to: ObjectArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+/*\n+ * \n+ */\n+ \n+abstract class PrimitiveArray[T] extends Array[T] {\n+  /** called by subclass::clone.  Allocate memory using GC_malloc_atomic and copy header and data */\n+  override protected def helperClone(sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.allocAtomic(arrsize)\n+    `llvm.memcpy.p0i8.p0i8.i64`(arr.cast[Ptr[Byte]], this.cast[Ptr[Byte]], arrsize, 1, false)\n+    arr\n+  }  \n+}\n \n-  def alloc(length: Int): ObjectArray = {\n-    val arrty = typeof[ObjectArray]\n-    val arrsize = sizeof[ArrayHeader] + sizeof[Object] * length\n-    val arr = runtime.alloc(arrty, arrsize)\n+/*\n+ * \n+ */\n+\n+object PrimitiveArray {\n+  /*\n+   * Primitive arrays don't contain pointers \n+   */   \n+  def alloc(length: Int, arrinfo:  Ptr[Type], sizeofElement: CSize): Ptr[_] = {\n+    val arrsize = sizeof[ArrayHeader] + sizeofElement * length\n+    val arr = runtime.allocAtomic(arrinfo, arrsize)\n     // set the length\n-    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length\n-    arr.cast[ObjectArray]\n+    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length    \n+    arr        \n   }\n }\n \n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 79)\n+/*\n+ *\n+ */\n+final class ObjectArray private () extends Array[Object] {\n+  def apply(i: Int): Object = ! (pointerAt(sizeof[Object], i).cast[Ptr[Object]])\n \n-final class BooleanArray private () extends Array[Boolean] {\n-  def apply(i: Int): Boolean =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Boolean]]\n-      headptr(i)\n-    }\n+  def update(i: Int, value: Object): Unit = ! (pointerAt(sizeof[Object], i).cast[Ptr[Object]]) = value\n \n-  def update(i: Int, value: Boolean): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Boolean]]\n-      headptr(i) = value\n-    }\n+  protected override def clone(): ObjectArray = helperClone (sizeof[Object]).cast[ObjectArray]  \n+}\n \n-  protected override def clone(): BooleanArray = {\n-    val newarr = BooleanArray.alloc(length)\n-    BooleanArray.copy(this, 0, newarr, 0, length)\n-    newarr\n-  }\n+object ObjectArray {\n+  def alloc(length: Int): ObjectArray = Array.alloc(length, typeof[ObjectArray], sizeof[Object]).cast[ObjectArray]\n }\n \n-object BooleanArray {\n-  def copy(from: BooleanArray, fromPos: Int,\n-           to: BooleanArray, toPos: Int, length: Int): Unit = {\n-    ???\n-  }\n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 210)\n \n-  def alloc(length: Int): BooleanArray = {\n-    val arrty = typeof[BooleanArray]\n-    val arrsize = sizeof[ArrayHeader] + sizeof[Boolean] * length\n-    val arr = runtime.allocAtomic(arrty, arrsize)\n-    // set the length\n-    !(arr.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]] = length\n-    arr.cast[BooleanArray]\n-  }\n-}\n+final class BooleanArray private () extends PrimitiveArray[Boolean] {\n+  def apply(i: Int): Boolean = ! (pointerAt(sizeof[Boolean], i).cast[Ptr[Boolean]])\n \n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 79)\n+  def update(i: Int, value: Boolean): Unit = ! (pointerAt(sizeof[Boolean], i).cast[Ptr[Boolean]]) = value\n \n-final class CharArray private () extends Array[Char] {\n-  def apply(i: Int): Char =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Char]]\n-      headptr(i)\n-    }\n+  protected override def clone(): BooleanArray = helperClone (sizeof[Boolean]).cast[BooleanArray]\n+  \n+  protected def copyTo (fromPos: Int, toPos: Int): Unit = update (toPos, apply(fromPos)) \n \n-  def update(i: Int, value: Char): Unit =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Char]]\n-      headptr(i) = value\n+  def sizeofElement: CSize = sizeof[Boolean]\n+\n+  def copyToArray (fromPos: Int, to : BooleanArray, toPos: Int, len: Int): Unit = { \n+    // methods for overlap copy (note: this == to) \n+    def forwardCopy() {\n+      var c = 0\n+           \n+      while (c < len) {\n+        copyTo (fromPos + c, toPos + c)\n+        c += 1\n+      }\n+    }\n+    \n+    def backwardCopy() {\n+      var c = len - 1\n+           \n+      while (c >= 0) {\n+        copyTo (fromPos + c, toPos + c)        \n+        c -= 1\n+      }\n     }\n+    \n+    // sanity check\n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val overlapDirection = Array.validateBoundaries (this, fromPos, to, toPos, len)\n+    \n+    val fromPtr: Ptr[Byte] = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeofElement * fromPos).cast[Ptr[Byte]]\n+    \n+    val toPtr: Ptr[Byte] = (to.cast[Ptr[Byte]] + sizeof[ArrayHeader] + sizeofElement * toPos).cast[Ptr[Byte]]\n+    \n+    if (overlapDirection == 0)\n+      // no overlap, use LLVM memcpy\n+      `llvm.memcpy.p0i8.p0i8.i64`(toPtr, fromPtr, sizeofElement * len, 1, false)\n+    else if (overlapDirection > 0)\n+      forwardCopy()\n+    else\n+      backwardCopy()"
  },
  {
    "id" : "488f76b9-14d2-4097-8fbf-d1aace5f06e5",
    "prId" : 184,
    "comments" : [
      {
        "id" : "6f850292-c23b-4d3c-b7aa-ef7e4e6036a6",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "I think message here is confusing. All the Scala-relevant semantics is already implemented. I think it's best not provide any error message here. \n",
        "createdAt" : "2016-06-25T10:13:14Z",
        "updatedAt" : "2016-06-26T21:08:47Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df99ebe472ae0f53b4650183e0d5a3b255014916",
    "line" : null,
    "diffHunk" : "@@ -1,411 +1,472 @@\n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 1)\n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 1)\n package scala.scalanative\n package runtime\n \n // Note 1:\n-// Arrays.scala is currently implemented as textual templating that is expanded through project/gyb.py script.\n+// Arrays.scala is currently implemented as textual templating that is expanded through project/gyb.py script. \n // Update Arrays.scala.gyb and re-generate the source\n+// $ ./project/gyb.py \\ \n+//     nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb > \\\n+//     nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala\n+\n \n // Note 2:\n // Array of primitiveTypes don't contain pointers, runtime.allocAtomic() is called for memory allocation\n // Array of Object do contain pointers. runtime.alloc() is called for memory allocation\n \n-// ###sourceLocation(file: \"/Users/Denys/.src/native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 16)\n+// Note 3:\n+// PrimitiveArray.helperClone can allocate memory with GC.malloc_atomic() because \n+// it will overwrite all data (no need to call llvm.memset)\n+\n \n import native._\n+import Intrinsics._\n \n @struct class ArrayHeader(val info: Ptr[_], val length: Int)\n \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 30)\n+\n sealed abstract class Array[T]\n     extends java.io.Serializable with java.lang.Cloneable {\n   /** Number of elements of the array. */\n   def length: Int =\n     // TODO: Update once we support ptr->field\n     !(this.cast[Ptr[Byte]] + sizeof[Ptr[_]]).cast[Ptr[Int]]\n-\n+    \n   /** Loads element at i, throws IndexOutOfBoundsException. */\n   def apply(i: Int): T\n \n   /** Stores value to element i, throws IndexOutOfBoundsException. */\n   def update(i: Int, value: T): Unit\n \n   /** Create a shallow of given array. */\n-  protected override def clone(): Array[T] = undefined\n+  protected override def clone(): Array[T] = undefined  \n }\n \n-final class ObjectArray private () extends Array[Object] {\n-  def apply(i: Int): Object =\n-    if (i < 0 || i >= length)\n-      throw new IndexOutOfBoundsException(i.toString)\n-    else {\n-      val headptr = (this.cast[Ptr[Byte]] + sizeof[ArrayHeader]).cast[Ptr[Object]]\n-      headptr(i)\n-    }\n+object Array {\n+  def copy (from: AnyRef, fromPos: Int, to: AnyRef, toPos: Int, length: Int): Unit = {\n+    if (from == null)\n+      throw new NullPointerException()\n+    \n+    if (to == null)\n+      throw new NullPointerException()\n+    \n+    val fromTypeId = instanceTypeId(from)\n+    val toTypeId = instanceTypeId(to)\n+    \n+    if (fromTypeId == arrayObjectTypeId && toTypeId == arrayObjectTypeId)\n+      from.asInstanceOf[ObjectArray].copyToArray (fromPos, to.asInstanceOf[ObjectArray], toPos, length)\n+    \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayBooleanTypeId && toTypeId == arrayBooleanTypeId) \n+      from.asInstanceOf[BooleanArray].copyToArray (fromPos, to.asInstanceOf[BooleanArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayCharTypeId && toTypeId == arrayCharTypeId) \n+      from.asInstanceOf[CharArray].copyToArray (fromPos, to.asInstanceOf[CharArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayByteTypeId && toTypeId == arrayByteTypeId) \n+      from.asInstanceOf[ByteArray].copyToArray (fromPos, to.asInstanceOf[ByteArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayShortTypeId && toTypeId == arrayShortTypeId) \n+      from.asInstanceOf[ShortArray].copyToArray (fromPos, to.asInstanceOf[ShortArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayIntTypeId && toTypeId == arrayIntTypeId) \n+      from.asInstanceOf[IntArray].copyToArray (fromPos, to.asInstanceOf[IntArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayLongTypeId && toTypeId == arrayLongTypeId) \n+      from.asInstanceOf[LongArray].copyToArray (fromPos, to.asInstanceOf[LongArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayFloatTypeId && toTypeId == arrayFloatTypeId) \n+      from.asInstanceOf[FloatArray].copyToArray (fromPos, to.asInstanceOf[FloatArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 63)\n+\n+    else if (fromTypeId == arrayDoubleTypeId && toTypeId == arrayDoubleTypeId) \n+      from.asInstanceOf[DoubleArray].copyToArray (fromPos, to.asInstanceOf[DoubleArray], toPos, length)\n+      \n+// ###sourceLocation(file: \"/home/francois/proyectos/oss/scala-native-fbd/scala-native/nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb\", line: 68)\n+\n+    else\n+      throw new ArrayStoreException (\"Not implemented yet.\")"
  }
]
[
  {
    "id" : "c5954d04-0627-4ee9-8b05-73edef35ea15",
    "prId" : 804,
    "comments" : [
      {
        "id" : "654194b6-d86c-426d-baab-3ee20f28dbe0",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Can you elaborate a bit more why is this the case?",
        "createdAt" : "2017-08-07T11:51:39Z",
        "updatedAt" : "2017-08-07T12:22:56Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "900e2200-0a92-46d6-986b-fcbb00cf957e",
        "parentId" : "654194b6-d86c-426d-baab-3ee20f28dbe0",
        "author" : {
          "login" : "matil019",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/28897240?v=4"
        },
        "body" : "Turned out that the comment is just copy-pasted from Harmony. I haven't tested whether it actually eats that much memory or not.",
        "createdAt" : "2017-08-07T12:05:07Z",
        "updatedAt" : "2017-08-07T12:22:56Z",
        "lastEditedBy" : {
          "login" : "matil019",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/28897240?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e8e064c0-5715-41bb-b122-0c9e63e3084e",
        "parentId" : "654194b6-d86c-426d-baab-3ee20f28dbe0",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Lets drop this comment, it's confusing and likely wrong. ",
        "createdAt" : "2017-08-07T12:06:26Z",
        "updatedAt" : "2017-08-07T12:22:56Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f8dba2ebf2d57ef8f753a811fb72cffc6e2ce047",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,3535 @@\n+package java.util\n+\n+// Ported from Harmony\n+// Modified to test Locale.US only. Please see FormatterSuite.scala for the original port\n+\n+import java.io.BufferedOutputStream\n+import java.io.ByteArrayOutputStream\n+import java.io.Closeable\n+import java.io.File\n+import java.io.FileNotFoundException\n+import java.io.FileOutputStream\n+import java.io.Flushable\n+import java.io.IOException\n+import java.io.OutputStream\n+import java.io.PrintStream\n+import java.io.UnsupportedEncodingException\n+import java.lang.StringBuilder\n+import java.math.BigDecimal\n+import java.math.BigInteger\n+import java.math.MathContext\n+import java.nio.charset.Charset\n+\n+object FormatterUSSuite extends tests.Suite {\n+  private var root: Boolean             = false\n+  private var notExist: File            = _\n+  private var fileWithContent: File     = _\n+  private var readOnly: File            = _\n+  private var defaultTimeZone: TimeZone = _\n+\n+  // setup resource files for testing\n+  protected def setUp(): Unit = {\n+    // disabled, doesn't work on Scala Native right now\n+    // root = System.getProperty(\"user.name\").equalsIgnoreCase(\"root\")\n+    notExist = File.createTempFile(\"notexist\", null)\n+    notExist.delete()\n+\n+    fileWithContent = File.createTempFile(\"filewithcontent\", null)\n+    val bw = new BufferedOutputStream(new FileOutputStream(fileWithContent))\n+    bw.write(1); // write something into the file\n+    bw.close()\n+\n+    readOnly = File.createTempFile(\"readonly\", null)\n+    readOnly.setReadOnly()\n+\n+    // ignores ??? until these are implemented\n+    try {\n+      defaultTimeZone = TimeZone.getDefault()\n+      val cst = TimeZone.getTimeZone(\"Asia/Shanghai\")\n+      TimeZone.setDefault(cst)\n+    } catch {\n+      case _: NotImplementedError =>\n+    }\n+  }\n+\n+  // delete the resource files if they exist\n+  protected def tearDown(): Unit = {\n+    if (notExist.exists()) notExist.delete()\n+    if (fileWithContent.exists()) fileWithContent.delete()\n+    if (readOnly.exists()) readOnly.delete()\n+    // TimeZone.setDefault(defaultTimeZone)\n+  }\n+\n+  override def test(name: String)(body: => Unit): Unit =\n+    super.test(name) {\n+      setUp()\n+      try {\n+        body\n+      } finally {\n+        tearDown()\n+      }\n+    }\n+\n+  override def testFails(name: String, issue: Int)(body: => Unit): Unit =\n+    super.testFails(name, issue) {\n+      setUp()\n+      try {\n+        body\n+      } finally {\n+        tearDown()\n+      }\n+    }\n+\n+  def assertNull[A](a: A): Unit =\n+    assert(a == null)\n+\n+  def assertNotNull[A](a: A): Unit =\n+    assertNot(a == null)\n+\n+  def assertTrue[A](a: A): Unit =\n+    assert(a == true)\n+\n+  private class MockAppendable extends Appendable {\n+    def append(arg0: CharSequence): Appendable = null\n+\n+    def append(arg0: Char): Appendable = null\n+\n+    def append(arg0: CharSequence, arg1: Int, arg2: Int): Appendable = null\n+  }\n+\n+  private class MockFormattable extends Formattable {\n+    def formatTo(formatter: Formatter,\n+                 flags: Int,\n+                 width: Int,\n+                 precision: Int): Unit = {\n+      if ((flags & FormattableFlags.UPPERCASE) != 0)\n+        formatter.format(\n+          \"CUSTOMIZED FORMAT FUNCTION\" + \" WIDTH: \" + width + \" PRECISION: \" + precision)\n+      else\n+        formatter.format(\n+          \"customized format function\" + \" width: \" + width + \" precision: \" + precision)\n+    }\n+\n+    override def toString(): String = \"formattable object\"\n+\n+    override def hashCode(): Int = 0xf\n+  }\n+\n+  private class MockDestination extends Appendable with Flushable {\n+    // Porting note: the content of MockDestination was stripped because it was no-op.\n+    def append(c: Char): Appendable = throw new IOException()\n+\n+    def append(csq: CharSequence): Appendable = throw new IOException()\n+\n+    def append(csq: CharSequence, start: Int, end: Int): Appendable =\n+      throw new IOException()\n+\n+    def flush(): Unit = throw new IOException(\"Always throw IOException\")\n+\n+    override def toString(): String = \"\"\n+  }\n+\n+  test(\"Constructor()\") {\n+    val f = new Formatter()\n+    assertNotNull(f)\n+    assertTrue(f.out().isInstanceOf[StringBuilder])\n+    assertEquals(f.locale(), Locale.getDefault())\n+    assertNotNull(f.toString())\n+  }\n+\n+  test(\"Constructor(Appendable)\") {\n+    val ma = new MockAppendable()\n+    val f1 = new Formatter(ma)\n+    assertEquals(ma, f1.out())\n+    assertEquals(f1.locale(), Locale.getDefault())\n+    assertNotNull(f1.toString())\n+\n+    val f2 = new Formatter(null.asInstanceOf[Appendable])\n+    /*\n+     * If a(the input param) is null then a StringBuilder will be created\n+     * and the output can be attained by invoking the out() method. But RI\n+     * raises an error of FormatterClosedException when invoking out() or\n+     * toString().\n+     */\n+    val sb = f2.out()\n+    assertTrue(sb.isInstanceOf[StringBuilder])\n+    assertNotNull(f2.toString())\n+  }\n+\n+  test(\"Constructor(Locale)\") {\n+    val f1 = new Formatter(Locale.US)\n+    assertTrue(f1.out().isInstanceOf[StringBuilder])\n+    assertEquals(f1.locale(), Locale.US)\n+    assertNotNull(f1.toString())\n+\n+    val f2 = new Formatter(null.asInstanceOf[Locale])\n+    assertNull(f2.locale())\n+    assertTrue(f2.out().isInstanceOf[StringBuilder])\n+    assertNotNull(f2.toString())\n+  }\n+\n+  test(\"Constructor(Appendable, Locale)\") {\n+    val ma = new MockAppendable()\n+    val f1 = new Formatter(ma, Locale.US)\n+    assertEquals(ma, f1.out())\n+    assertEquals(f1.locale(), Locale.US)\n+\n+    val f2 = new Formatter(ma, null)\n+    assertNull(f2.locale())\n+    assertEquals(ma, f1.out())\n+\n+    val f3 = new Formatter(null, Locale.US)\n+    assertEquals(f3.locale(), Locale.US)\n+    assertTrue(f3.out().isInstanceOf[StringBuilder])\n+  }\n+\n+  test(\"Constructor(String)\") {\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[String]))\n+\n+    locally {\n+      val f = new Formatter(notExist.getPath())\n+      assertEquals(f.locale(), Locale.getDefault())\n+      f.close()\n+    }\n+\n+    locally {\n+      val f = new Formatter(fileWithContent.getPath())\n+      assertEquals(0, fileWithContent.length())\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](new Formatter(readOnly.getPath()))\n+    }\n+  }\n+\n+  testFails(\"Constructor(String, String)\", 816) {\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[String],\n+                    Charset.defaultCharset().name()))\n+\n+    locally {\n+      val f =\n+        new Formatter(notExist.getPath(), Charset.defaultCharset().name())\n+      assertEquals(f.locale(), Locale.getDefault())\n+      f.close()\n+    }\n+\n+    assertThrows[UnsupportedEncodingException](\n+      new Formatter(notExist.getPath(), \"ISO 111-1\")) // fails #816\n+\n+    locally {\n+      val f = new Formatter(fileWithContent.getPath(), \"UTF-16BE\")\n+      assertEquals(0, fileWithContent.length())\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](\n+        new Formatter(readOnly.getPath(), \"UTF-16BE\"))\n+    }\n+  }\n+\n+  testFails(\"Constructor(String, String, Locale)\", 816) {\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[String],\n+                    Charset.defaultCharset().name(),\n+                    Locale.US))\n+\n+    locally {\n+      val f = new Formatter(notExist.getPath(),\n+                            Charset.defaultCharset().name(),\n+                            null)\n+      assertNotNull(f)\n+      f.close()\n+    }\n+\n+    locally {\n+      val f = new Formatter(notExist.getPath(),\n+                            Charset.defaultCharset().name(),\n+                            Locale.US)\n+      assertEquals(f.locale(), Locale.US)\n+      f.close()\n+    }\n+\n+    assertThrows[UnsupportedEncodingException](\n+      new Formatter(notExist.getPath(), \"ISO 1111-1\", Locale.US)) // fails #816\n+\n+    locally {\n+      val f = new Formatter(fileWithContent.getPath(), \"UTF-16BE\", Locale.US)\n+      assertEquals(0, fileWithContent.length())\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](\n+        new Formatter(readOnly.getPath(),\n+                      Charset.defaultCharset().name(),\n+                      Locale.US))\n+    }\n+  }\n+\n+  test(\"Constructor(File)\") {\n+    locally {\n+      val f = new Formatter(notExist)\n+      assertEquals(f.locale(), Locale.getDefault())\n+      f.close()\n+    }\n+\n+    locally {\n+      val f = new Formatter(fileWithContent)\n+      assertEquals(0, fileWithContent.length())\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](new Formatter(readOnly))\n+    }\n+  }\n+\n+  testFails(\"Constructor(File, String)\", 816) {\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+\n+    locally {\n+      val f = new Formatter(notExist, Charset.defaultCharset().name())\n+      assertEquals(f.locale(), Locale.getDefault)\n+      f.close()\n+    }\n+\n+    locally {\n+      val f = new Formatter(fileWithContent, \"UTF-16BE\")\n+      assertEquals(0, fileWithContent.length)\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](\n+        new Formatter(readOnly, Charset.defaultCharset().name()))\n+    }\n+\n+    try {\n+      assertThrows[UnsupportedEncodingException](\n+        new Formatter(notExist, \"ISO 1111-1\")) /// fails #816\n+    } finally if (notExist.exists()) {\n+      // Fail on RI on Windows, because output stream is created and\n+      // not closed when exception thrown\n+      assertTrue(notExist.delete())\n+    }\n+  }\n+\n+  testFails(\"Constructor(File, String, Locale)\", 816) {\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+\n+    locally {\n+      val f = new Formatter(notExist, Charset.defaultCharset().name(), null)\n+      assertNotNull(f)\n+      f.close()\n+    }\n+\n+    locally {\n+      val f =\n+        new Formatter(notExist, Charset.defaultCharset().name(), Locale.US)\n+      assertEquals(f.locale(), Locale.US)\n+      f.close()\n+    }\n+\n+    assertThrows[UnsupportedEncodingException](\n+      new Formatter(notExist, \"ISO 1111-1\", Locale.US)) // fails #816\n+\n+    locally {\n+      val f = new Formatter(fileWithContent.getPath, \"UTF-16BE\", Locale.US)\n+      assertEquals(0, fileWithContent.length)\n+      f.close()\n+    }\n+\n+    if (!root) {\n+      assertThrows[FileNotFoundException](\n+        new Formatter(readOnly.getPath,\n+                      Charset.defaultCharset().name(),\n+                      Locale.US))\n+    }\n+  }\n+\n+  test(\"Constructor(PrintStream)\") {\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[PrintStream]))\n+\n+    val ps = new PrintStream(notExist, \"UTF-16BE\")\n+    val f  = new Formatter(ps)\n+    assertEquals(Locale.getDefault(), f.locale())\n+    f.close()\n+  }\n+\n+  test(\"Constructor(OutputStream)\") {\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[OutputStream]))\n+\n+    val os = new FileOutputStream(notExist)\n+    val f  = new Formatter(os)\n+    assertEquals(Locale.getDefault(), f.locale())\n+    f.close()\n+  }\n+\n+  testFails(\"Constructor(OutputStream, String)\", 816) { // also 818\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+    // OutputStreamWriter should throw NPE if its argument is null\n+\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[OutputStream],\n+                    Charset.defaultCharset().name())) // fails #818\n+\n+    locally {\n+      // Porting note: PipedOutputStream is not essential to this test.\n+      // Since it doesn't exist on Scala Native yet, it is replaced with a harmless one.\n+      // val os = new PipedOutputStream()\n+      val os = new ByteArrayOutputStream\n+      assertThrows[UnsupportedEncodingException](new Formatter(os, \"TMP-1111\")) // fails #816\n+    }\n+\n+    locally {\n+      val os = new FileOutputStream(fileWithContent)\n+      val f  = new Formatter(os, \"UTF-16BE\")\n+      assertEquals(Locale.getDefault, f.locale())\n+      f.close()\n+    }\n+  }\n+\n+  testFails(\"Constructor(OutputStream, String, Locale)\", 816) { // also 818\n+    // OutputStreamWriter should throw UnsupportedEncodingException (NOT UnsupportedCharsetException)\n+    // OutputStreamWriter should throw NPE if its argument is null\n+\n+    assertThrows[NullPointerException](\n+      new Formatter(null.asInstanceOf[OutputStream],\n+                    Charset.defaultCharset().name(),\n+                    Locale.getDefault)) // fails #818\n+\n+    locally {\n+      val os = new FileOutputStream(notExist)\n+      val f  = new Formatter(os, Charset.defaultCharset().name(), null)\n+      f.close()\n+    }\n+\n+    locally {\n+      // Porting note: PipedOutputStream is not essential to this test.\n+      // Since it doesn't exist on Scala Native yet, it is replaced with a harmless one.\n+      // val os = new PipedOutputStream()\n+      val os = new ByteArrayOutputStream\n+      assertThrows[UnsupportedEncodingException](\n+        new Formatter(os, \"TMP-1111\", Locale.getDefault)) // fails #816\n+    }\n+\n+    locally {\n+      val os = new FileOutputStream(fileWithContent)\n+      val f  = new Formatter(os, \"UTF-16BE\", Locale.US)\n+      assertEquals(Locale.US, f.locale())\n+      f.close()\n+    }\n+  }\n+\n+  test(\"locale()\") {\n+    val f = new Formatter(null.asInstanceOf[Locale])\n+    assertNull(f.locale())\n+\n+    f.close()\n+    assertThrows[FormatterClosedException](f.locale())\n+  }\n+\n+  test(\"out()\") {\n+    val f = new Formatter()\n+    assertNotNull(f.out())\n+    assertTrue(f.out().isInstanceOf[StringBuilder])\n+    f.close()\n+    assertThrows[FormatterClosedException](f.out())\n+  }\n+\n+  test(\"flush()\") {\n+    locally {\n+      val f = new Formatter(notExist)\n+      assertTrue(f.isInstanceOf[Flushable])\n+      f.close()\n+      assertThrows[FormatterClosedException](f.out())\n+    }\n+\n+    locally {\n+      val f = new Formatter()\n+      // For destination that does not implement Flushable\n+      // No exception should be thrown\n+      f.flush()\n+    }\n+  }\n+\n+  test(\"close()\") {\n+    val f = new Formatter(notExist)\n+    assertTrue(f.isInstanceOf[Closeable])\n+    f.close()\n+    // close next time will not throw exception\n+    f.close()\n+    assertNull(f.ioException())\n+  }\n+\n+  test(\"toString()\") {\n+    val f = new Formatter()\n+    assertNotNull(f.toString())\n+    assertEquals(f.out().toString(), f.toString())\n+    f.close()\n+    assertThrows[FormatterClosedException](f.toString())\n+  }\n+\n+  test(\"ioException()\") {\n+    locally {\n+      val f = new Formatter(new MockDestination())\n+      assertNull(f.ioException())\n+      f.flush()\n+      assertNotNull(f.ioException())\n+      f.close()\n+    }\n+\n+    locally {\n+      val md = new MockDestination()\n+      val f  = new Formatter(md)\n+      f.format(\"%s%s\", \"1\", \"2\")\n+      // format stop working after IOException\n+      assertNotNull(f.ioException())\n+      assertEquals(\"\", f.toString())\n+    }\n+  }\n+\n+  test(\"format(String, Array[Object]) for null parameter\") {\n+    locally {\n+      val f = new Formatter()\n+      f.format(\"hello\", null.asInstanceOf[Array[Object]])\n+      assertEquals(\"hello\", f.toString())\n+    }\n+  }\n+\n+  test(\"format(String, Array[Object]) for argument index\") {\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%1$s%2$s%3$s%4$s%5$s%6$s%7$s%8$s%9$s%11$s%10$s\",\n+               \"1\",\n+               \"2\",\n+               \"3\",\n+               \"4\",\n+               \"5\",\n+               \"6\",\n+               \"7\",\n+               \"8\",\n+               \"9\",\n+               \"10\",\n+               \"11\")\n+      assertEquals(\"1234567891110\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%0$s\", \"hello\")\n+      assertEquals(\"hello\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      assertThrows[UnknownFormatConversionException](\n+        f.format(\"%-1$s\", \"1\", \"2\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      assertThrows[UnknownFormatConversionException](\n+        f.format(\"%$s\", \"hello\", \"2\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      assertThrows[UnknownFormatConversionException](f.format(\"%\", \"string\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%1$s%2$s%3$s%4$s%5$s%6$s%7$s%8$s%<s%s%s%<s\",\n+               \"1\",\n+               \"2\",\n+               \"3\",\n+               \"4\",\n+               \"5\",\n+               \"6\",\n+               \"7\",\n+               \"8\",\n+               \"9\",\n+               \"10\",\n+               \"11\")\n+      assertEquals(\"123456788122\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"xx%1$s22%2$s%s%<s%5$s%<s&%7$h%2$s%8$s%<s%s%s%<ssuffix\",\n+               \"1\",\n+               \"2\",\n+               \"3\",\n+               \"4\",\n+               \"5\",\n+               \"6\",\n+               7.asInstanceOf[Object], // this is intended\n+               \"8\",\n+               \"9\",\n+               \"10\",\n+               \"11\")\n+      assertEquals(\"xx12221155&7288233suffix\", f.toString())\n+      assertThrows[MissingFormatArgumentException](f.format(\"%<s\", \"hello\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      assertThrows[MissingFormatArgumentException](f.format(\"%123$s\", \"hello\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      // 2147483648 is the value of Integer.MAX_VALUE + 1\n+      assertThrows[MissingFormatArgumentException](\n+        f.format(\"%2147483648$s\", \"hello\"))\n+      // 2147483647 is the value of Integer.MAX_VALUE\n+      assertThrows[MissingFormatArgumentException](\n+        f.format(\"%2147483647$s\", \"hello\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      assertThrows[MissingFormatArgumentException](f.format(\"%s%s\", \"hello\"))\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"$100\", 100.asInstanceOf[Object])\n+      assertEquals(\"$100\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%01$s\", \"string\")\n+      assertEquals(\"string\", f.toString())\n+    }\n+  }\n+\n+  test(\"format(String, Array[Object]) for width\") {\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%1$8s\", \"1\")\n+      assertEquals(\"       1\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      f.format(\"%1$-1%\", \"string\")\n+      assertEquals(\"%\", f.toString())\n+    }\n+\n+    locally {\n+      val f = new Formatter(Locale.US)\n+      // 2147483648 is the value of Integer.MAX_VALUE + 1\n+      f.format(\"%2147483648s\", \"string\")\n+      assertEquals(\"string\", f.toString())\n+    }\n+\n+    // the value of Integer.MAX_VALUE will allocate about 4G bytes of\n+    // memory.\n+    // It may cause OutOfMemoryError, so this value is not tested"
  }
]
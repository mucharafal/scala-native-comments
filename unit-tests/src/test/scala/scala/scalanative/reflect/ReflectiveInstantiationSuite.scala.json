[
  {
    "id" : "35790745-774e-4eb8-88fa-63eb8624f1cc",
    "prId" : 1728,
    "comments" : [
      {
        "id" : "d4950c48-76ee-4bc8-a1c5-084963bbc99f",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider writing this as a `def`:\r\n```scala\r\ndef fn(idx: Int) = size - idx\r\n```\r\nOtherwise one wonders why you need a lambda.",
        "createdAt" : "2020-04-24T14:57:57Z",
        "updatedAt" : "2020-04-25T07:45:59Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cf340168e94cc4e2e720946e735664907e6bd955",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,445 @@\n+package scala.scalanative\n+\n+package reflect\n+\n+// Ported from Scala.js.\n+\n+import scala.scalanative.reflect._\n+import scala.scalanative.reflect.annotation._\n+import scala.scalanative.unsafe._\n+\n+object ReflectiveInstantiationSuite extends tests.Suite {\n+  import ReflectTest.{Accessors, PtrAccessors, VC}\n+\n+  private final val Prefix = \"scala.scalanative.reflect.ReflectTest$\"\n+\n+  private final val NameClassEnableDirect =\n+    Prefix + \"ClassEnableDirect\"\n+  private final val NameClassEnableDirectNoZeroArgCtor =\n+    Prefix + \"ClassEnableDirectNoZeroArgCtor\"\n+  private final val NameObjectEnableDirect =\n+    Prefix + \"ObjectEnableDirect$\"\n+  private final val NameTraitEnableDirect =\n+    Prefix + \"TraitEnableDirect\"\n+  private final val NameAbstractClassEnableDirect =\n+    Prefix + \"AbstractClassEnableDirect\"\n+  private final val NameClassNoPublicConstructorEnableDirect =\n+    Prefix + \"ClassNoPublicConstructorEnableDirect\"\n+\n+  private final val NameInnerClass = {\n+    Prefix + \"ClassWithInnerClassWithEnableReflectiveInstantiation$\" +\n+      \"InnerClassWithEnableReflectiveInstantiation\"\n+  }\n+\n+  private final val NameClassEnableIndirect =\n+    Prefix + \"ClassEnableIndirect\"\n+  private final val NameClassEnableIndirectNoZeroArgCtor =\n+    Prefix + \"ClassEnableIndirectNoZeroArgCtor\"\n+  private final val NameObjectEnableIndirect =\n+    Prefix + \"ObjectEnableIndirect$\"\n+  private final val NameTraitEnableIndirect =\n+    Prefix + \"TraitEnableIndirect\"\n+  private final val NameAbstractClassEnableIndirect =\n+    Prefix + \"AbstractClassEnableIndirect\"\n+  private final val NameClassNoPublicConstructorEnableIndirect =\n+    Prefix + \"ClassNoPublicConstructorEnableIndirect\"\n+\n+  private final val NameClassDisable =\n+    Prefix + \"ClassDisable\"\n+  private final val NameObjectDisable =\n+    Prefix + \"ObjectDisable$\"\n+  private final val NameTraitDisable =\n+    Prefix + \"TraitDisable\"\n+\n+  private final val NameInnerObject = {\n+    Prefix + \"ClassWithInnerObjectWithEnableReflectiveInstantiation$\" +\n+      \"InnerObjectWithEnableReflectiveInstantiation\"\n+  }\n+\n+  private final val NameClassWithPtrArg = {\n+    Prefix + \"ClassWithPtrArg\"\n+  }\n+\n+  test(\"testClassRuntimeClass\") {\n+    for {\n+      name <- Seq(NameClassEnableDirect,\n+                  NameClassEnableDirectNoZeroArgCtor,\n+                  NameClassEnableIndirect,\n+                  NameClassEnableIndirectNoZeroArgCtor)\n+    } {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val runtimeClass = optClassData.get.runtimeClass\n+      assertEquals(name, runtimeClass.getName)\n+    }\n+  }\n+\n+  test(\"testObjectRuntimeClass\") {\n+    for {\n+      name <- Seq(NameObjectEnableDirect, NameObjectEnableIndirect)\n+    } {\n+      val optClassData = Reflect.lookupLoadableModuleClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val runtimeClass = optClassData.get.runtimeClass\n+      assertEquals(name, runtimeClass.getName)\n+    }\n+  }\n+\n+  test(\"testClassCannotBeFound\") {\n+    for {\n+      name <- Seq(\n+        NameObjectEnableDirect,\n+        NameTraitEnableDirect,\n+        NameAbstractClassEnableDirect,\n+        NameClassNoPublicConstructorEnableDirect,\n+        NameObjectEnableIndirect,\n+        NameTraitEnableIndirect,\n+        NameAbstractClassEnableIndirect,\n+        NameClassNoPublicConstructorEnableIndirect,\n+        NameClassDisable,\n+        NameObjectDisable,\n+        NameTraitDisable\n+      )\n+    } {\n+      assertFalse(s\"$name should not be found\",\n+                  Reflect.lookupInstantiatableClass(name).isDefined)\n+    }\n+  }\n+\n+  test(\"testObjectCannotBeFound\") {\n+    for {\n+      name <- Seq(\n+        NameClassEnableDirect,\n+        NameClassEnableDirectNoZeroArgCtor,\n+        NameTraitEnableDirect,\n+        NameAbstractClassEnableDirect,\n+        NameClassNoPublicConstructorEnableDirect,\n+        NameClassEnableIndirect,\n+        NameTraitEnableIndirect,\n+        NameAbstractClassEnableIndirect,\n+        NameClassNoPublicConstructorEnableIndirect,\n+        NameClassDisable,\n+        NameObjectDisable,\n+        NameTraitDisable\n+      )\n+    } {\n+      assertFalse(s\"$name should not be found\",\n+                  Reflect.lookupLoadableModuleClass(name).isDefined)\n+    }\n+  }\n+\n+  test(\"testClassNoArgCtor\") {\n+    for (name <- Seq(NameClassEnableDirect, NameClassEnableIndirect)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val instance = classData.newInstance().asInstanceOf[Accessors]\n+      assertEquals(-1, instance.x)\n+      assertEquals(name.stripPrefix(Prefix), instance.y)\n+    }\n+  }\n+\n+  test(\"testClassNoArgCtorErrorCase\") {\n+    for (name <- Seq(NameClassEnableDirectNoZeroArgCtor,\n+                     NameClassEnableIndirectNoZeroArgCtor)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      expectThrows(classOf[InstantiationException], {\n+        classData.newInstance()\n+      })\n+    }\n+  }\n+\n+  test(\"testClassCtorWithArgs\") {\n+    for (name <- Seq(NameClassEnableDirect,\n+                     NameClassEnableDirectNoZeroArgCtor,\n+                     NameClassEnableIndirect,\n+                     NameClassEnableIndirectNoZeroArgCtor)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val optCtorIntString =\n+        classData.getConstructor(classOf[Int], classOf[String])\n+      assertTrue(optCtorIntString.isDefined)\n+      val instanceIntString =\n+        optCtorIntString.get.newInstance(543, \"foobar\").asInstanceOf[Accessors]\n+      assertEquals(543, instanceIntString.x)\n+      assertEquals(\"foobar\", instanceIntString.y)\n+\n+      val optCtorInt = classData.getConstructor(classOf[Int])\n+      assertTrue(optCtorInt.isDefined)\n+      val instanceInt =\n+        optCtorInt.get.newInstance(123).asInstanceOf[Accessors]\n+      assertEquals(123, instanceInt.x)\n+      assertEquals(name.stripPrefix(Prefix), instanceInt.y)\n+\n+      // Value class is seen as its underlying\n+      val optCtorShort = classData.getConstructor(classOf[Short])\n+      assertTrue(optCtorShort.isDefined)\n+      val instanceShort =\n+        optCtorShort.get.newInstance(21).asInstanceOf[Accessors]\n+      assertEquals(42, instanceShort.x)\n+      assertEquals(name.stripPrefix(Prefix), instanceShort.y)\n+\n+      // Non-existent\n+      assertFalse(classData.getConstructor(classOf[Boolean]).isDefined)\n+      assertFalse(classData.getConstructor(classOf[VC]).isDefined)\n+\n+      // Non-public\n+      assertFalse(classData.getConstructor(classOf[String]).isDefined)\n+      assertFalse(classData.getConstructor(classOf[Double]).isDefined)\n+    }\n+  }\n+\n+  test(\"testClassCtorWthPtrArg\") {\n+    import ReflectTest.ClassWithPtrArg\n+\n+    val optClassData = Reflect.lookupInstantiatableClass(NameClassWithPtrArg)\n+    assertTrue(optClassData.isDefined)\n+    val classData = optClassData.get\n+\n+    // test with array of bytes\n+    Zone { implicit z =>\n+      val size   = 64\n+      val buffer = alloc[Byte](size)\n+\n+      val fn = { idx: Int =>\n+        size - idx\n+      }"
  },
  {
    "id" : "7428b856-3d5a-4185-b24d-da5eda68830c",
    "prId" : 1728,
    "comments" : [
      {
        "id" : "468a095c-07bc-4c5b-b7ee-b9b925e63888",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n        buffer(i) = fn(i).toByte\r\n```",
        "createdAt" : "2020-04-24T14:59:11Z",
        "updatedAt" : "2020-04-25T07:45:59Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cf340168e94cc4e2e720946e735664907e6bd955",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,445 @@\n+package scala.scalanative\n+\n+package reflect\n+\n+// Ported from Scala.js.\n+\n+import scala.scalanative.reflect._\n+import scala.scalanative.reflect.annotation._\n+import scala.scalanative.unsafe._\n+\n+object ReflectiveInstantiationSuite extends tests.Suite {\n+  import ReflectTest.{Accessors, PtrAccessors, VC}\n+\n+  private final val Prefix = \"scala.scalanative.reflect.ReflectTest$\"\n+\n+  private final val NameClassEnableDirect =\n+    Prefix + \"ClassEnableDirect\"\n+  private final val NameClassEnableDirectNoZeroArgCtor =\n+    Prefix + \"ClassEnableDirectNoZeroArgCtor\"\n+  private final val NameObjectEnableDirect =\n+    Prefix + \"ObjectEnableDirect$\"\n+  private final val NameTraitEnableDirect =\n+    Prefix + \"TraitEnableDirect\"\n+  private final val NameAbstractClassEnableDirect =\n+    Prefix + \"AbstractClassEnableDirect\"\n+  private final val NameClassNoPublicConstructorEnableDirect =\n+    Prefix + \"ClassNoPublicConstructorEnableDirect\"\n+\n+  private final val NameInnerClass = {\n+    Prefix + \"ClassWithInnerClassWithEnableReflectiveInstantiation$\" +\n+      \"InnerClassWithEnableReflectiveInstantiation\"\n+  }\n+\n+  private final val NameClassEnableIndirect =\n+    Prefix + \"ClassEnableIndirect\"\n+  private final val NameClassEnableIndirectNoZeroArgCtor =\n+    Prefix + \"ClassEnableIndirectNoZeroArgCtor\"\n+  private final val NameObjectEnableIndirect =\n+    Prefix + \"ObjectEnableIndirect$\"\n+  private final val NameTraitEnableIndirect =\n+    Prefix + \"TraitEnableIndirect\"\n+  private final val NameAbstractClassEnableIndirect =\n+    Prefix + \"AbstractClassEnableIndirect\"\n+  private final val NameClassNoPublicConstructorEnableIndirect =\n+    Prefix + \"ClassNoPublicConstructorEnableIndirect\"\n+\n+  private final val NameClassDisable =\n+    Prefix + \"ClassDisable\"\n+  private final val NameObjectDisable =\n+    Prefix + \"ObjectDisable$\"\n+  private final val NameTraitDisable =\n+    Prefix + \"TraitDisable\"\n+\n+  private final val NameInnerObject = {\n+    Prefix + \"ClassWithInnerObjectWithEnableReflectiveInstantiation$\" +\n+      \"InnerObjectWithEnableReflectiveInstantiation\"\n+  }\n+\n+  private final val NameClassWithPtrArg = {\n+    Prefix + \"ClassWithPtrArg\"\n+  }\n+\n+  test(\"testClassRuntimeClass\") {\n+    for {\n+      name <- Seq(NameClassEnableDirect,\n+                  NameClassEnableDirectNoZeroArgCtor,\n+                  NameClassEnableIndirect,\n+                  NameClassEnableIndirectNoZeroArgCtor)\n+    } {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val runtimeClass = optClassData.get.runtimeClass\n+      assertEquals(name, runtimeClass.getName)\n+    }\n+  }\n+\n+  test(\"testObjectRuntimeClass\") {\n+    for {\n+      name <- Seq(NameObjectEnableDirect, NameObjectEnableIndirect)\n+    } {\n+      val optClassData = Reflect.lookupLoadableModuleClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val runtimeClass = optClassData.get.runtimeClass\n+      assertEquals(name, runtimeClass.getName)\n+    }\n+  }\n+\n+  test(\"testClassCannotBeFound\") {\n+    for {\n+      name <- Seq(\n+        NameObjectEnableDirect,\n+        NameTraitEnableDirect,\n+        NameAbstractClassEnableDirect,\n+        NameClassNoPublicConstructorEnableDirect,\n+        NameObjectEnableIndirect,\n+        NameTraitEnableIndirect,\n+        NameAbstractClassEnableIndirect,\n+        NameClassNoPublicConstructorEnableIndirect,\n+        NameClassDisable,\n+        NameObjectDisable,\n+        NameTraitDisable\n+      )\n+    } {\n+      assertFalse(s\"$name should not be found\",\n+                  Reflect.lookupInstantiatableClass(name).isDefined)\n+    }\n+  }\n+\n+  test(\"testObjectCannotBeFound\") {\n+    for {\n+      name <- Seq(\n+        NameClassEnableDirect,\n+        NameClassEnableDirectNoZeroArgCtor,\n+        NameTraitEnableDirect,\n+        NameAbstractClassEnableDirect,\n+        NameClassNoPublicConstructorEnableDirect,\n+        NameClassEnableIndirect,\n+        NameTraitEnableIndirect,\n+        NameAbstractClassEnableIndirect,\n+        NameClassNoPublicConstructorEnableIndirect,\n+        NameClassDisable,\n+        NameObjectDisable,\n+        NameTraitDisable\n+      )\n+    } {\n+      assertFalse(s\"$name should not be found\",\n+                  Reflect.lookupLoadableModuleClass(name).isDefined)\n+    }\n+  }\n+\n+  test(\"testClassNoArgCtor\") {\n+    for (name <- Seq(NameClassEnableDirect, NameClassEnableIndirect)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val instance = classData.newInstance().asInstanceOf[Accessors]\n+      assertEquals(-1, instance.x)\n+      assertEquals(name.stripPrefix(Prefix), instance.y)\n+    }\n+  }\n+\n+  test(\"testClassNoArgCtorErrorCase\") {\n+    for (name <- Seq(NameClassEnableDirectNoZeroArgCtor,\n+                     NameClassEnableIndirectNoZeroArgCtor)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      expectThrows(classOf[InstantiationException], {\n+        classData.newInstance()\n+      })\n+    }\n+  }\n+\n+  test(\"testClassCtorWithArgs\") {\n+    for (name <- Seq(NameClassEnableDirect,\n+                     NameClassEnableDirectNoZeroArgCtor,\n+                     NameClassEnableIndirect,\n+                     NameClassEnableIndirectNoZeroArgCtor)) {\n+      val optClassData = Reflect.lookupInstantiatableClass(name)\n+      assertTrue(optClassData.isDefined)\n+      val classData = optClassData.get\n+\n+      val optCtorIntString =\n+        classData.getConstructor(classOf[Int], classOf[String])\n+      assertTrue(optCtorIntString.isDefined)\n+      val instanceIntString =\n+        optCtorIntString.get.newInstance(543, \"foobar\").asInstanceOf[Accessors]\n+      assertEquals(543, instanceIntString.x)\n+      assertEquals(\"foobar\", instanceIntString.y)\n+\n+      val optCtorInt = classData.getConstructor(classOf[Int])\n+      assertTrue(optCtorInt.isDefined)\n+      val instanceInt =\n+        optCtorInt.get.newInstance(123).asInstanceOf[Accessors]\n+      assertEquals(123, instanceInt.x)\n+      assertEquals(name.stripPrefix(Prefix), instanceInt.y)\n+\n+      // Value class is seen as its underlying\n+      val optCtorShort = classData.getConstructor(classOf[Short])\n+      assertTrue(optCtorShort.isDefined)\n+      val instanceShort =\n+        optCtorShort.get.newInstance(21).asInstanceOf[Accessors]\n+      assertEquals(42, instanceShort.x)\n+      assertEquals(name.stripPrefix(Prefix), instanceShort.y)\n+\n+      // Non-existent\n+      assertFalse(classData.getConstructor(classOf[Boolean]).isDefined)\n+      assertFalse(classData.getConstructor(classOf[VC]).isDefined)\n+\n+      // Non-public\n+      assertFalse(classData.getConstructor(classOf[String]).isDefined)\n+      assertFalse(classData.getConstructor(classOf[Double]).isDefined)\n+    }\n+  }\n+\n+  test(\"testClassCtorWthPtrArg\") {\n+    import ReflectTest.ClassWithPtrArg\n+\n+    val optClassData = Reflect.lookupInstantiatableClass(NameClassWithPtrArg)\n+    assertTrue(optClassData.isDefined)\n+    val classData = optClassData.get\n+\n+    // test with array of bytes\n+    Zone { implicit z =>\n+      val size   = 64\n+      val buffer = alloc[Byte](size)\n+\n+      val fn = { idx: Int =>\n+        size - idx\n+      }\n+\n+      for (i <- 0 until size) {\n+        buffer(i) = (fn(i)).toByte"
  }
]
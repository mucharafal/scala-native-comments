[
  {
    "id" : "f0f26965-8925-4a01-9ba6-00f638db3459",
    "prId" : 759,
    "comments" : [
      {
        "id" : "16e49b2f-8ede-4196-a2e2-4f865172bf40",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "We usually don't include javadoc as it will not be visible to anyone. If you have comments about the logic in your code, we use `// comments` to describe what's going on close the the code.",
        "createdAt" : "2017-05-30T23:06:37Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**"
  },
  {
    "id" : "53fa4791-ef26-4a89-9a31-64f6ee434e38",
    "prId" : 759,
    "comments" : [
      {
        "id" : "86e3d9f6-64bf-4eac-bdde-b0a44a63c12c",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "These values don't appear in the Javadoc, so I think they should be made `private`",
        "createdAt" : "2017-05-30T23:12:25Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$"
  },
  {
    "id" : "fe766bd4-42d6-4bf9-9b45-e0c2c2edc4a5",
    "prId" : 759,
    "comments" : [
      {
        "id" : "12300506-3f1f-49e0-9f1b-a97e9a709dab",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "The `@throws` annotations are only affecting the scaladoc, so you should get rid of them too.",
        "createdAt" : "2017-05-30T23:17:15Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(uri: String) = {\n+    this()\n+    new Helper().parseURI(uri, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]scheme-specific-part[#fragment]}\n+   *\n+   * @param scheme\n+   * the scheme part of the URI.\n+   * @param ssp\n+   * the scheme-specific-part of the URI.\n+   * @param frag\n+   * the fragment part of the URI.\n+   * @throws URISyntaxException\n+   * if the temporary created string doesn't fit to the\n+   * specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, ssp: String, frag: String) = {\n+    this()\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (ssp != null) {\n+      uri.append(quoteComponent(ssp, allLegal))\n+    }\n+    if (frag != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(frag, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param userinfo\n+   *            the user information of the URI for authentication and\n+   *            authorization.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param port\n+   *            the port number of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           userinfo: String,\n+           host: String,\n+           port: Int,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    var hostVar   = host\n+    var earlyStop = false\n+    if (scheme == null && userinfo == null && host == null && path == null &&\n+        query == null &&\n+        fragment == null) {\n+      this.path = \"\"\n+      earlyStop = true\n+    }\n+    if (!earlyStop) {\n+      if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+        throw new URISyntaxException(path, \"Relative path\")\n+      }\n+      val uri: StringBuilder = new StringBuilder()\n+      if (scheme != null) {\n+        uri.append(scheme)\n+        uri.append(':')\n+      }\n+      if (userinfo != null || host != null || port != -1) {\n+        uri.append(\"//\")\n+      }\n+      if (userinfo != null) {\n+        uri.append(quoteComponent(userinfo, someLegal))\n+        uri.append('@')\n+      }\n+      if (host != null) {\n+        if (host.indexOf(':') != -1 && host.indexOf(']') == -1 && host.indexOf(\n+              '[') == -1) {\n+          hostVar = \"[\" + host + \"]\"\n+        }\n+        uri.append(hostVar)\n+      }\n+      if (port != -1) {\n+        uri.append(':')\n+        uri.append(port)\n+      }\n+      if (path != null) {\n+        uri.append(quoteComponent(path, \"/@\" + someLegal))\n+      }\n+      if (query != null) {\n+        uri.append('?')\n+        uri.append(quoteComponent(query, allLegal))\n+      }\n+      if (fragment != null) {\n+        uri.append('#')\n+        uri.append(quoteComponent(fragment, allLegal))\n+      }\n+      new Helper().parseURI(uri.toString, true)\n+    }\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]host[path][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, host: String, path: String, fragment: String) =\n+    this(scheme, null, host, -1, path, null, fragment)\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][//authority][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param authority\n+   *            the authority part of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           authority: String,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+      throw new URISyntaxException(path, \"Relative path\")\n+    }\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (authority != null) {\n+      uri.append(\"//\")\n+      uri.append(quoteComponent(authority, \"@[]\" + someLegal))\n+    }\n+    if (path != null) {\n+      uri.append(quoteComponent(path, \"/@\" + someLegal))\n+    }\n+    if (query != null) {\n+      uri.append('?')\n+      uri.append(quoteComponent(query, allLegal))\n+    }\n+    if (fragment != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(fragment, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  private class Helper {\n+\n+    @throws(classOf[URISyntaxException])"
  },
  {
    "id" : "31cf414f-071a-4968-8512-f963ee5aea06",
    "prId" : 759,
    "comments" : [
      {
        "id" : "2943687e-fcb0-4b75-9e6b-d8d8c3aac9ba",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "I think this could be an object. I doesn't keep any state.",
        "createdAt" : "2017-05-30T23:23:23Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(uri: String) = {\n+    this()\n+    new Helper().parseURI(uri, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]scheme-specific-part[#fragment]}\n+   *\n+   * @param scheme\n+   * the scheme part of the URI.\n+   * @param ssp\n+   * the scheme-specific-part of the URI.\n+   * @param frag\n+   * the fragment part of the URI.\n+   * @throws URISyntaxException\n+   * if the temporary created string doesn't fit to the\n+   * specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, ssp: String, frag: String) = {\n+    this()\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (ssp != null) {\n+      uri.append(quoteComponent(ssp, allLegal))\n+    }\n+    if (frag != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(frag, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param userinfo\n+   *            the user information of the URI for authentication and\n+   *            authorization.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param port\n+   *            the port number of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           userinfo: String,\n+           host: String,\n+           port: Int,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    var hostVar   = host\n+    var earlyStop = false\n+    if (scheme == null && userinfo == null && host == null && path == null &&\n+        query == null &&\n+        fragment == null) {\n+      this.path = \"\"\n+      earlyStop = true\n+    }\n+    if (!earlyStop) {\n+      if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+        throw new URISyntaxException(path, \"Relative path\")\n+      }\n+      val uri: StringBuilder = new StringBuilder()\n+      if (scheme != null) {\n+        uri.append(scheme)\n+        uri.append(':')\n+      }\n+      if (userinfo != null || host != null || port != -1) {\n+        uri.append(\"//\")\n+      }\n+      if (userinfo != null) {\n+        uri.append(quoteComponent(userinfo, someLegal))\n+        uri.append('@')\n+      }\n+      if (host != null) {\n+        if (host.indexOf(':') != -1 && host.indexOf(']') == -1 && host.indexOf(\n+              '[') == -1) {\n+          hostVar = \"[\" + host + \"]\"\n+        }\n+        uri.append(hostVar)\n+      }\n+      if (port != -1) {\n+        uri.append(':')\n+        uri.append(port)\n+      }\n+      if (path != null) {\n+        uri.append(quoteComponent(path, \"/@\" + someLegal))\n+      }\n+      if (query != null) {\n+        uri.append('?')\n+        uri.append(quoteComponent(query, allLegal))\n+      }\n+      if (fragment != null) {\n+        uri.append('#')\n+        uri.append(quoteComponent(fragment, allLegal))\n+      }\n+      new Helper().parseURI(uri.toString, true)\n+    }\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]host[path][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, host: String, path: String, fragment: String) =\n+    this(scheme, null, host, -1, path, null, fragment)\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][//authority][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param authority\n+   *            the authority part of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           authority: String,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+      throw new URISyntaxException(path, \"Relative path\")\n+    }\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (authority != null) {\n+      uri.append(\"//\")\n+      uri.append(quoteComponent(authority, \"@[]\" + someLegal))\n+    }\n+    if (path != null) {\n+      uri.append(quoteComponent(path, \"/@\" + someLegal))\n+    }\n+    if (query != null) {\n+      uri.append('?')\n+      uri.append(quoteComponent(query, allLegal))\n+    }\n+    if (fragment != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(fragment, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  private class Helper {"
  },
  {
    "id" : "0a3cf9fc-035a-47ad-8014-8e965554544f",
    "prId" : 759,
    "comments" : [
      {
        "id" : "bbde9545-c54a-4ef9-8816-23019a033b02",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "It looks like there's an implementation missing here. Did you copy/paste the javadoc twice or did you forget a method?",
        "createdAt" : "2017-05-30T23:30:23Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b7355e4a-2a22-4e41-8985-5020399905ab",
        "parentId" : "bbde9545-c54a-4ef9-8816-23019a033b02",
        "author" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "body" : "It was the former, fixed in the next commit",
        "createdAt" : "2017-05-31T13:05:51Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */"
  },
  {
    "id" : "5b0727f0-777a-4c4b-9f4e-c44152244059",
    "prId" : 759,
    "comments" : [
      {
        "id" : "391091c0-d522-4ad0-bad9-2b55c0bd6042",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "I'm pretty sure there's something wrong with this method. You're probably missing some `return`s. The body of the two conditions at lines 744 and 746 won't return `-1` or `1` if they evaluate to `true`. The value will just be discarded. I guess that's not expected. Could you refactor or fix that code?",
        "createdAt" : "2017-05-30T23:39:50Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "16a37ec6-09d5-4c08-8c1b-6aaa31344301",
        "parentId" : "391091c0-d522-4ad0-bad9-2b55c0bd6042",
        "author" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "body" : "Yup, when porting I forgot about the \"return\" difference in Java and Scala. I have corrected most of it, but I have missed some cases. I will fix them and double check.",
        "createdAt" : "2017-05-31T11:54:53Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : 646,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(uri: String) = {\n+    this()\n+    new Helper().parseURI(uri, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]scheme-specific-part[#fragment]}\n+   *\n+   * @param scheme\n+   * the scheme part of the URI.\n+   * @param ssp\n+   * the scheme-specific-part of the URI.\n+   * @param frag\n+   * the fragment part of the URI.\n+   * @throws URISyntaxException\n+   * if the temporary created string doesn't fit to the\n+   * specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, ssp: String, frag: String) = {\n+    this()\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (ssp != null) {\n+      uri.append(quoteComponent(ssp, allLegal))\n+    }\n+    if (frag != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(frag, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param userinfo\n+   *            the user information of the URI for authentication and\n+   *            authorization.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param port\n+   *            the port number of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           userinfo: String,\n+           host: String,\n+           port: Int,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    var hostVar   = host\n+    var earlyStop = false\n+    if (scheme == null && userinfo == null && host == null && path == null &&\n+        query == null &&\n+        fragment == null) {\n+      this.path = \"\"\n+      earlyStop = true\n+    }\n+    if (!earlyStop) {\n+      if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+        throw new URISyntaxException(path, \"Relative path\")\n+      }\n+      val uri: StringBuilder = new StringBuilder()\n+      if (scheme != null) {\n+        uri.append(scheme)\n+        uri.append(':')\n+      }\n+      if (userinfo != null || host != null || port != -1) {\n+        uri.append(\"//\")\n+      }\n+      if (userinfo != null) {\n+        uri.append(quoteComponent(userinfo, someLegal))\n+        uri.append('@')\n+      }\n+      if (host != null) {\n+        if (host.indexOf(':') != -1 && host.indexOf(']') == -1 && host.indexOf(\n+              '[') == -1) {\n+          hostVar = \"[\" + host + \"]\"\n+        }\n+        uri.append(hostVar)\n+      }\n+      if (port != -1) {\n+        uri.append(':')\n+        uri.append(port)\n+      }\n+      if (path != null) {\n+        uri.append(quoteComponent(path, \"/@\" + someLegal))\n+      }\n+      if (query != null) {\n+        uri.append('?')\n+        uri.append(quoteComponent(query, allLegal))\n+      }\n+      if (fragment != null) {\n+        uri.append('#')\n+        uri.append(quoteComponent(fragment, allLegal))\n+      }\n+      new Helper().parseURI(uri.toString, true)\n+    }\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]host[path][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, host: String, path: String, fragment: String) =\n+    this(scheme, null, host, -1, path, null, fragment)\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][//authority][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param authority\n+   *            the authority part of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           authority: String,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+      throw new URISyntaxException(path, \"Relative path\")\n+    }\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (authority != null) {\n+      uri.append(\"//\")\n+      uri.append(quoteComponent(authority, \"@[]\" + someLegal))\n+    }\n+    if (path != null) {\n+      uri.append(quoteComponent(path, \"/@\" + someLegal))\n+    }\n+    if (query != null) {\n+      uri.append('?')\n+      uri.append(quoteComponent(query, allLegal))\n+    }\n+    if (fragment != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(fragment, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  private class Helper {\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseURI(uri: String, forceServer: Boolean): Unit = {\n+      var temp: String = uri\n+      string = uri\n+      var index: Int  = 0\n+      var index1: Int = 0\n+      var index2: Int = 0\n+      var index3: Int = 0\n+\n+      index = temp.indexOf('#')\n+      if (index != -1) {\n+        fragment = temp.substring(index + 1)\n+        validateFragment(uri, fragment, index + 1)\n+        temp = temp.substring(0, index)\n+      }\n+      index = temp.indexOf(':')\n+      index1 = index\n+      index2 = temp.indexOf('/')\n+      index3 = temp.indexOf('?')\n+      if (index != -1 && (index2 >= index || index2 == -1) && (index3 >= index || index3 == -1)) {\n+        absolute = true\n+        scheme = temp.substring(0, index)\n+        if (scheme.length == 0) {\n+          throw new URISyntaxException(uri, \"Scheme expected\", index)\n+        }\n+        validateScheme(uri, scheme, 0)\n+        schemespecificpart = temp.substring(index + 1)\n+        if (schemespecificpart.length == 0) {\n+          throw new URISyntaxException(uri,\n+                                       \"Scheme-specific part expected\",\n+                                       index + 1)\n+        }\n+      } else {\n+        absolute = false\n+        schemespecificpart = temp\n+      }\n+\n+      if (scheme == null || schemespecificpart.length > 0 && schemespecificpart\n+            .charAt(0) == '/') {\n+        opaque = false\n+\n+        temp = schemespecificpart\n+        index = temp.indexOf('?')\n+        if (index != -1) {\n+          query = temp.substring(index + 1)\n+          temp = temp.substring(0, index)\n+          validateQuery(uri, query, index2 + 1 + index)\n+        }\n+\n+        if (temp.startsWith(\"//\")) {\n+          index = temp.indexOf('/', 2)\n+          if (index != -1) {\n+            authority = temp.substring(2, index)\n+            path = temp.substring(index)\n+          } else {\n+            authority = temp.substring(2)\n+            if (authority.length() == 0 && query == null\n+                && fragment == null) {\n+              throw new URISyntaxException(uri,\n+                                           \"Authority expected\",\n+                                           uri.length())\n+            }\n+\n+            path = \"\";\n+          }\n+\n+          if (authority.length() == 0) {\n+            authority = null\n+          } else {\n+            validateAuthority(uri, authority, index1 + 3)\n+          }\n+        } else {\n+          path = temp\n+        }\n+\n+        var pathIndex: Int = 0\n+        if (index2 > -1) {\n+          pathIndex += index2\n+        }\n+        if (index > -1) {\n+          pathIndex += index\n+        }\n+        validatePath(uri, path, pathIndex)\n+      } else { // if not hierarchical, URI is opaque\n+        opaque = true\n+        validateSsp(uri, schemespecificpart, index2 + 2 + index)\n+      }\n+\n+      parseAuthority(forceServer)\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateScheme(uri: String, scheme: String, index: Int): Unit = {\n+      val ch: Char = scheme.charAt(0)\n+      if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))) {\n+        throw new URISyntaxException(uri, \"Illegal character in scheme\", 0)\n+      }\n+\n+      try {\n+        URIEncoderDecoder.validateSimple(scheme, \"+-.\");\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in scheme\",\n+                                       index\n+                                         + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateSsp(uri: String, ssp: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(ssp, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(\n+            uri,\n+            e.getReason + \" in scheme specific part\",\n+            index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateAuthority(uri: String, authority: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(authority, \"@[]\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in authority\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validatePath(uri: String, path: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(path, \"/@\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in path\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateQuery(uri: String, query: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(query, queryLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in query\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateFragment(uri: String, fragment: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(fragment, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in fragment\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseAuthority(forceServer: Boolean): Unit = {\n+      if (authority == null) {\n+        return\n+      }\n+      var temp: String         = null\n+      var tempUserinfo: String = null\n+      var tempHost: String     = null\n+      var index: Int           = 0\n+      var hostindex: Int       = 0\n+      var tempPort: Int        = -1\n+      temp = authority\n+      index = temp.indexOf('@')\n+      if (index != -1) {\n+        tempUserinfo = temp.substring(0, index)\n+        validateUserinfo(authority, tempUserinfo, 0)\n+        temp = temp.substring(index + 1)\n+        hostindex = index + 1\n+      }\n+      index = temp.lastIndexOf(':')\n+      val endindex: Int = temp.indexOf(']')\n+      if (index != -1 && endindex < index) {\n+        tempHost = temp.substring(0, index)\n+        if (index < (temp.length - 1)) {\n+          try {\n+            tempPort = java.lang.Integer.parseInt(temp.substring(index + 1))\n+            if (tempPort < 0) {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+          } catch {\n+            case e: NumberFormatException => {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+\n+          }\n+        }\n+      } else {\n+        tempHost = temp\n+      }\n+      if (tempHost == \"\") {\n+        if (forceServer) {\n+          throw new URISyntaxException(authority, \"Expected host\", hostindex)\n+        }\n+        return\n+      }\n+      if (!isValidHost(forceServer, tempHost)) {\n+        return\n+      }\n+\n+      userinfo = tempUserinfo\n+      host = tempHost\n+      port = tempPort\n+      serverAuthority = true\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateUserinfo(uri: String, userinfo: String, index: Int): Unit = {\n+      for (i <- 0 until userinfo.length) {\n+        val ch: Char = userinfo.charAt(i)\n+        if (ch == ']' || ch == '[') {\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in userinfo\",\n+                                       index + i)\n+        }\n+      }\n+    }\n+\n+    def isValidHost(forceServer: Boolean, host: String): Boolean = {\n+      if (host.charAt(0) == '[') {\n+        if (host.charAt(host.length - 1) != ']') {\n+          throw new URISyntaxException(\n+            host,\n+            \"Expected a closing square bracket for ipv6 address\",\n+            0)\n+        }\n+        if (!isValidIP6Address(host)) {\n+          throw new URISyntaxException(host, \"Malformed ipv6 address\")\n+        }\n+        return true\n+      }\n+      if (host.indexOf('[') != -1 || host.indexOf(']') != -1) {\n+        throw new URISyntaxException(host, \"Illegal character in host name\", 0)\n+      }\n+      val index: Int = host.lastIndexOf('.')\n+      if (index < 0 || index == host.length - 1 ||\n+          !java.lang.Character.isDigit(host.charAt(index + 1))) {\n+        if (isValidDomainName(host)) {\n+          return true\n+        }\n+        if (forceServer) {\n+          throw new URISyntaxException(host,\n+                                       \"Illegal character in host name\",\n+                                       0)\n+        }\n+        return false\n+      }\n+      if (isValidIPv4Address(host)) {\n+        return true\n+      }\n+      if (forceServer) {\n+        throw new URISyntaxException(host, \"Malformed ipv4 address\", 0)\n+      }\n+      false\n+    }\n+\n+    def isValidDomainName(host: String): Boolean = {\n+      try {\n+        URIEncoderDecoder.validateSimple(host, \"-.\")\n+      } catch {\n+        case e: URISyntaxException => return false\n+      }\n+      var label: String       = null\n+      val st: StringTokenizer = new StringTokenizer(host, \".\")\n+      while (st.hasMoreTokens) {\n+        label = st.nextToken()\n+        if (label.startsWith(\"-\") || label.endsWith(\"-\")) {\n+          return false\n+        }\n+      }\n+      if (label != host) {\n+        val ch: Char = label.charAt(0)\n+        if (ch >= '0' && ch <= '9') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIPv4Address(host: String): Boolean = {\n+      var index: Int  = 0\n+      var index2: Int = 0\n+      try {\n+        var num: Int = 0\n+        index = host.indexOf('.')\n+        num = java.lang.Integer.parseInt(host.substring(0, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index2 = host.indexOf('.', index + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index + 1, index2))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index = host.indexOf('.', index2 + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index2 + 1, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        num = java.lang.Integer.parseInt(host.substring(index + 1))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+      } catch {\n+        case e: Exception => false\n+\n+      }\n+      true\n+    }\n+\n+    def isValidIP6Address(ipAddress: String): Boolean = {\n+      val length: Int          = ipAddress.length\n+      var doubleColon: Boolean = false\n+      var numberOfColons: Int  = 0\n+      var numberOfPeriods: Int = 0\n+      var word: String         = \"\"\n+      var c: Char              = 0\n+      var prevChar: Char       = 0\n+      var offset: Int          = 0\n+      if (length < 2) {\n+        return false\n+      }\n+      for (i <- 0 until length) {\n+        prevChar = c\n+        c = ipAddress.charAt(i)\n+        c match {\n+          case '[' =>\n+            if (i != 0) {\n+              return false\n+            }\n+            if (ipAddress.charAt(length - 1) != ']') {\n+              return false\n+            }\n+            if ((ipAddress.charAt(1) == ':') && (ipAddress.charAt(2) != ':')) {\n+              return false\n+            }\n+            offset = 1\n+            if (length < 4) {\n+              return false\n+            }\n+          case ']' =>\n+            if (i != length - 1) {\n+              return false\n+            }\n+            if (ipAddress.charAt(0) != '[') {\n+              return false\n+            }\n+          case '.' => { numberOfPeriods += 1; numberOfPeriods - 1 }\n+          if (numberOfPeriods > 3) {\n+            return false\n+          }\n+          if (!isValidIP4Word(word)) {\n+            return false\n+          }\n+          if (numberOfColons != 6 && !doubleColon) {\n+            return false\n+          }\n+          if (numberOfColons == 7 && ipAddress.charAt(0 + offset) != ':' &&\n+              ipAddress.charAt(1 + offset) != ':') {\n+            return false\n+          }\n+          word = \"\"\n+        case ':' => { numberOfColons += 1; numberOfColons - 1 }\n+          if (numberOfColons > 7) {\n+            return false\n+          }\n+          if (numberOfPeriods > 0) {\n+            return false\n+          }\n+          if (prevChar == ':') {\n+            if (doubleColon) {\n+              return false\n+            }\n+            doubleColon = true\n+          }\n+          word = \"\"\n+        case _ =>\n+            if (word.length > 3) {\n+              return false\n+            }\n+            if (!isValidHexChar(c)) {\n+              return false\n+            }\n+            word += c\n+\n+        }\n+      }\n+      if (numberOfPeriods > 0) {\n+        if (numberOfPeriods != 3 || !isValidIP4Word(word)) {\n+          return false\n+        }\n+      } else {\n+        if (numberOfColons != 7 && !doubleColon) {\n+          return false\n+        }\n+        if (word == \"\" && ipAddress.charAt(length - 1 - offset) != ':' &&\n+            ipAddress.charAt(length - 2 - offset) != ':') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIP4Word(word: String): Boolean = {\n+      var c: Char = 0\n+      if (word.length < 1 || word.length > 3) {\n+        return false\n+      }\n+      for (i <- 0 until word.length) {\n+        c = word.charAt(i)\n+        if (!(c >= '0' && c <= '9')) {\n+          return false\n+        }\n+      }\n+      if (java.lang.Integer.parseInt(word) > 255) {\n+        return false\n+      }\n+      true\n+    }\n+\n+    def isValidHexChar(c: Char): Boolean =\n+      (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')\n+\n+  }\n+\n+  private def quoteComponent(component: String, legalset: String): String = {\n+    try {\n+      URIEncoderDecoder.quoteIllegal(component, legalset);\n+    } catch {\n+      case e: UnsupportedOperationException =>\n+        throw new RuntimeException(e.toString)\n+    }\n+  }\n+\n+  def compareTo(uri: URI): Int = {"
  },
  {
    "id" : "dda89a68-529e-4d27-b56e-65bfd301d658",
    "prId" : 759,
    "comments" : [
      {
        "id" : "b207e264-83aa-4f0a-b435-3d4cd8399f4c",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "You probably want a `return` in here. Otherwise the value of `s` is just going to be ignored, and execution will continue.",
        "createdAt" : "2017-05-30T23:43:00Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(uri: String) = {\n+    this()\n+    new Helper().parseURI(uri, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]scheme-specific-part[#fragment]}\n+   *\n+   * @param scheme\n+   * the scheme part of the URI.\n+   * @param ssp\n+   * the scheme-specific-part of the URI.\n+   * @param frag\n+   * the fragment part of the URI.\n+   * @throws URISyntaxException\n+   * if the temporary created string doesn't fit to the\n+   * specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, ssp: String, frag: String) = {\n+    this()\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (ssp != null) {\n+      uri.append(quoteComponent(ssp, allLegal))\n+    }\n+    if (frag != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(frag, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param userinfo\n+   *            the user information of the URI for authentication and\n+   *            authorization.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param port\n+   *            the port number of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           userinfo: String,\n+           host: String,\n+           port: Int,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    var hostVar   = host\n+    var earlyStop = false\n+    if (scheme == null && userinfo == null && host == null && path == null &&\n+        query == null &&\n+        fragment == null) {\n+      this.path = \"\"\n+      earlyStop = true\n+    }\n+    if (!earlyStop) {\n+      if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+        throw new URISyntaxException(path, \"Relative path\")\n+      }\n+      val uri: StringBuilder = new StringBuilder()\n+      if (scheme != null) {\n+        uri.append(scheme)\n+        uri.append(':')\n+      }\n+      if (userinfo != null || host != null || port != -1) {\n+        uri.append(\"//\")\n+      }\n+      if (userinfo != null) {\n+        uri.append(quoteComponent(userinfo, someLegal))\n+        uri.append('@')\n+      }\n+      if (host != null) {\n+        if (host.indexOf(':') != -1 && host.indexOf(']') == -1 && host.indexOf(\n+              '[') == -1) {\n+          hostVar = \"[\" + host + \"]\"\n+        }\n+        uri.append(hostVar)\n+      }\n+      if (port != -1) {\n+        uri.append(':')\n+        uri.append(port)\n+      }\n+      if (path != null) {\n+        uri.append(quoteComponent(path, \"/@\" + someLegal))\n+      }\n+      if (query != null) {\n+        uri.append('?')\n+        uri.append(quoteComponent(query, allLegal))\n+      }\n+      if (fragment != null) {\n+        uri.append('#')\n+        uri.append(quoteComponent(fragment, allLegal))\n+      }\n+      new Helper().parseURI(uri.toString, true)\n+    }\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]host[path][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, host: String, path: String, fragment: String) =\n+    this(scheme, null, host, -1, path, null, fragment)\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][//authority][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param authority\n+   *            the authority part of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           authority: String,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+      throw new URISyntaxException(path, \"Relative path\")\n+    }\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (authority != null) {\n+      uri.append(\"//\")\n+      uri.append(quoteComponent(authority, \"@[]\" + someLegal))\n+    }\n+    if (path != null) {\n+      uri.append(quoteComponent(path, \"/@\" + someLegal))\n+    }\n+    if (query != null) {\n+      uri.append('?')\n+      uri.append(quoteComponent(query, allLegal))\n+    }\n+    if (fragment != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(fragment, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  private class Helper {\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseURI(uri: String, forceServer: Boolean): Unit = {\n+      var temp: String = uri\n+      string = uri\n+      var index: Int  = 0\n+      var index1: Int = 0\n+      var index2: Int = 0\n+      var index3: Int = 0\n+\n+      index = temp.indexOf('#')\n+      if (index != -1) {\n+        fragment = temp.substring(index + 1)\n+        validateFragment(uri, fragment, index + 1)\n+        temp = temp.substring(0, index)\n+      }\n+      index = temp.indexOf(':')\n+      index1 = index\n+      index2 = temp.indexOf('/')\n+      index3 = temp.indexOf('?')\n+      if (index != -1 && (index2 >= index || index2 == -1) && (index3 >= index || index3 == -1)) {\n+        absolute = true\n+        scheme = temp.substring(0, index)\n+        if (scheme.length == 0) {\n+          throw new URISyntaxException(uri, \"Scheme expected\", index)\n+        }\n+        validateScheme(uri, scheme, 0)\n+        schemespecificpart = temp.substring(index + 1)\n+        if (schemespecificpart.length == 0) {\n+          throw new URISyntaxException(uri,\n+                                       \"Scheme-specific part expected\",\n+                                       index + 1)\n+        }\n+      } else {\n+        absolute = false\n+        schemespecificpart = temp\n+      }\n+\n+      if (scheme == null || schemespecificpart.length > 0 && schemespecificpart\n+            .charAt(0) == '/') {\n+        opaque = false\n+\n+        temp = schemespecificpart\n+        index = temp.indexOf('?')\n+        if (index != -1) {\n+          query = temp.substring(index + 1)\n+          temp = temp.substring(0, index)\n+          validateQuery(uri, query, index2 + 1 + index)\n+        }\n+\n+        if (temp.startsWith(\"//\")) {\n+          index = temp.indexOf('/', 2)\n+          if (index != -1) {\n+            authority = temp.substring(2, index)\n+            path = temp.substring(index)\n+          } else {\n+            authority = temp.substring(2)\n+            if (authority.length() == 0 && query == null\n+                && fragment == null) {\n+              throw new URISyntaxException(uri,\n+                                           \"Authority expected\",\n+                                           uri.length())\n+            }\n+\n+            path = \"\";\n+          }\n+\n+          if (authority.length() == 0) {\n+            authority = null\n+          } else {\n+            validateAuthority(uri, authority, index1 + 3)\n+          }\n+        } else {\n+          path = temp\n+        }\n+\n+        var pathIndex: Int = 0\n+        if (index2 > -1) {\n+          pathIndex += index2\n+        }\n+        if (index > -1) {\n+          pathIndex += index\n+        }\n+        validatePath(uri, path, pathIndex)\n+      } else { // if not hierarchical, URI is opaque\n+        opaque = true\n+        validateSsp(uri, schemespecificpart, index2 + 2 + index)\n+      }\n+\n+      parseAuthority(forceServer)\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateScheme(uri: String, scheme: String, index: Int): Unit = {\n+      val ch: Char = scheme.charAt(0)\n+      if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))) {\n+        throw new URISyntaxException(uri, \"Illegal character in scheme\", 0)\n+      }\n+\n+      try {\n+        URIEncoderDecoder.validateSimple(scheme, \"+-.\");\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in scheme\",\n+                                       index\n+                                         + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateSsp(uri: String, ssp: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(ssp, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(\n+            uri,\n+            e.getReason + \" in scheme specific part\",\n+            index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateAuthority(uri: String, authority: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(authority, \"@[]\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in authority\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validatePath(uri: String, path: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(path, \"/@\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in path\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateQuery(uri: String, query: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(query, queryLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in query\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateFragment(uri: String, fragment: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(fragment, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in fragment\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseAuthority(forceServer: Boolean): Unit = {\n+      if (authority == null) {\n+        return\n+      }\n+      var temp: String         = null\n+      var tempUserinfo: String = null\n+      var tempHost: String     = null\n+      var index: Int           = 0\n+      var hostindex: Int       = 0\n+      var tempPort: Int        = -1\n+      temp = authority\n+      index = temp.indexOf('@')\n+      if (index != -1) {\n+        tempUserinfo = temp.substring(0, index)\n+        validateUserinfo(authority, tempUserinfo, 0)\n+        temp = temp.substring(index + 1)\n+        hostindex = index + 1\n+      }\n+      index = temp.lastIndexOf(':')\n+      val endindex: Int = temp.indexOf(']')\n+      if (index != -1 && endindex < index) {\n+        tempHost = temp.substring(0, index)\n+        if (index < (temp.length - 1)) {\n+          try {\n+            tempPort = java.lang.Integer.parseInt(temp.substring(index + 1))\n+            if (tempPort < 0) {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+          } catch {\n+            case e: NumberFormatException => {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+\n+          }\n+        }\n+      } else {\n+        tempHost = temp\n+      }\n+      if (tempHost == \"\") {\n+        if (forceServer) {\n+          throw new URISyntaxException(authority, \"Expected host\", hostindex)\n+        }\n+        return\n+      }\n+      if (!isValidHost(forceServer, tempHost)) {\n+        return\n+      }\n+\n+      userinfo = tempUserinfo\n+      host = tempHost\n+      port = tempPort\n+      serverAuthority = true\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateUserinfo(uri: String, userinfo: String, index: Int): Unit = {\n+      for (i <- 0 until userinfo.length) {\n+        val ch: Char = userinfo.charAt(i)\n+        if (ch == ']' || ch == '[') {\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in userinfo\",\n+                                       index + i)\n+        }\n+      }\n+    }\n+\n+    def isValidHost(forceServer: Boolean, host: String): Boolean = {\n+      if (host.charAt(0) == '[') {\n+        if (host.charAt(host.length - 1) != ']') {\n+          throw new URISyntaxException(\n+            host,\n+            \"Expected a closing square bracket for ipv6 address\",\n+            0)\n+        }\n+        if (!isValidIP6Address(host)) {\n+          throw new URISyntaxException(host, \"Malformed ipv6 address\")\n+        }\n+        return true\n+      }\n+      if (host.indexOf('[') != -1 || host.indexOf(']') != -1) {\n+        throw new URISyntaxException(host, \"Illegal character in host name\", 0)\n+      }\n+      val index: Int = host.lastIndexOf('.')\n+      if (index < 0 || index == host.length - 1 ||\n+          !java.lang.Character.isDigit(host.charAt(index + 1))) {\n+        if (isValidDomainName(host)) {\n+          return true\n+        }\n+        if (forceServer) {\n+          throw new URISyntaxException(host,\n+                                       \"Illegal character in host name\",\n+                                       0)\n+        }\n+        return false\n+      }\n+      if (isValidIPv4Address(host)) {\n+        return true\n+      }\n+      if (forceServer) {\n+        throw new URISyntaxException(host, \"Malformed ipv4 address\", 0)\n+      }\n+      false\n+    }\n+\n+    def isValidDomainName(host: String): Boolean = {\n+      try {\n+        URIEncoderDecoder.validateSimple(host, \"-.\")\n+      } catch {\n+        case e: URISyntaxException => return false\n+      }\n+      var label: String       = null\n+      val st: StringTokenizer = new StringTokenizer(host, \".\")\n+      while (st.hasMoreTokens) {\n+        label = st.nextToken()\n+        if (label.startsWith(\"-\") || label.endsWith(\"-\")) {\n+          return false\n+        }\n+      }\n+      if (label != host) {\n+        val ch: Char = label.charAt(0)\n+        if (ch >= '0' && ch <= '9') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIPv4Address(host: String): Boolean = {\n+      var index: Int  = 0\n+      var index2: Int = 0\n+      try {\n+        var num: Int = 0\n+        index = host.indexOf('.')\n+        num = java.lang.Integer.parseInt(host.substring(0, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index2 = host.indexOf('.', index + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index + 1, index2))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index = host.indexOf('.', index2 + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index2 + 1, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        num = java.lang.Integer.parseInt(host.substring(index + 1))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+      } catch {\n+        case e: Exception => false\n+\n+      }\n+      true\n+    }\n+\n+    def isValidIP6Address(ipAddress: String): Boolean = {\n+      val length: Int          = ipAddress.length\n+      var doubleColon: Boolean = false\n+      var numberOfColons: Int  = 0\n+      var numberOfPeriods: Int = 0\n+      var word: String         = \"\"\n+      var c: Char              = 0\n+      var prevChar: Char       = 0\n+      var offset: Int          = 0\n+      if (length < 2) {\n+        return false\n+      }\n+      for (i <- 0 until length) {\n+        prevChar = c\n+        c = ipAddress.charAt(i)\n+        c match {\n+          case '[' =>\n+            if (i != 0) {\n+              return false\n+            }\n+            if (ipAddress.charAt(length - 1) != ']') {\n+              return false\n+            }\n+            if ((ipAddress.charAt(1) == ':') && (ipAddress.charAt(2) != ':')) {\n+              return false\n+            }\n+            offset = 1\n+            if (length < 4) {\n+              return false\n+            }\n+          case ']' =>\n+            if (i != length - 1) {\n+              return false\n+            }\n+            if (ipAddress.charAt(0) != '[') {\n+              return false\n+            }\n+          case '.' => { numberOfPeriods += 1; numberOfPeriods - 1 }\n+          if (numberOfPeriods > 3) {\n+            return false\n+          }\n+          if (!isValidIP4Word(word)) {\n+            return false\n+          }\n+          if (numberOfColons != 6 && !doubleColon) {\n+            return false\n+          }\n+          if (numberOfColons == 7 && ipAddress.charAt(0 + offset) != ':' &&\n+              ipAddress.charAt(1 + offset) != ':') {\n+            return false\n+          }\n+          word = \"\"\n+        case ':' => { numberOfColons += 1; numberOfColons - 1 }\n+          if (numberOfColons > 7) {\n+            return false\n+          }\n+          if (numberOfPeriods > 0) {\n+            return false\n+          }\n+          if (prevChar == ':') {\n+            if (doubleColon) {\n+              return false\n+            }\n+            doubleColon = true\n+          }\n+          word = \"\"\n+        case _ =>\n+            if (word.length > 3) {\n+              return false\n+            }\n+            if (!isValidHexChar(c)) {\n+              return false\n+            }\n+            word += c\n+\n+        }\n+      }\n+      if (numberOfPeriods > 0) {\n+        if (numberOfPeriods != 3 || !isValidIP4Word(word)) {\n+          return false\n+        }\n+      } else {\n+        if (numberOfColons != 7 && !doubleColon) {\n+          return false\n+        }\n+        if (word == \"\" && ipAddress.charAt(length - 1 - offset) != ':' &&\n+            ipAddress.charAt(length - 2 - offset) != ':') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIP4Word(word: String): Boolean = {\n+      var c: Char = 0\n+      if (word.length < 1 || word.length > 3) {\n+        return false\n+      }\n+      for (i <- 0 until word.length) {\n+        c = word.charAt(i)\n+        if (!(c >= '0' && c <= '9')) {\n+          return false\n+        }\n+      }\n+      if (java.lang.Integer.parseInt(word) > 255) {\n+        return false\n+      }\n+      true\n+    }\n+\n+    def isValidHexChar(c: Char): Boolean =\n+      (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')\n+\n+  }\n+\n+  private def quoteComponent(component: String, legalset: String): String = {\n+    try {\n+      URIEncoderDecoder.quoteIllegal(component, legalset);\n+    } catch {\n+      case e: UnsupportedOperationException =>\n+        throw new RuntimeException(e.toString)\n+    }\n+  }\n+\n+  def compareTo(uri: URI): Int = {\n+    var ret: Int = 0\n+    if (scheme == null && uri.scheme != null) {\n+      -1\n+    } else if (scheme != null && uri.scheme == null) {\n+      1\n+    } else if (scheme != null && uri.scheme != null) {\n+      ret = scheme.compareToIgnoreCase(uri.scheme)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    }\n+    if (!opaque && uri.opaque) {\n+      -1\n+    } else if (opaque && !uri.opaque) {\n+      1\n+    } else if (opaque && uri.opaque) {\n+      ret = schemespecificpart.compareTo(uri.schemespecificpart)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    } else {\n+      if (authority != null && uri.authority == null) {\n+        1\n+      } else if (authority == null && uri.authority != null) {\n+        -1\n+      } else if (authority != null && uri.authority != null) {\n+        if (host != null && uri.host != null) {\n+          if (userinfo != null && uri.userinfo == null) {\n+            1\n+          } else if (userinfo == null && uri.userinfo != null) {\n+            -1\n+          } else if (userinfo != null && uri.userinfo != null) {\n+            ret = userinfo.compareTo(uri.userinfo)\n+            if (ret != 0) {\n+              return ret\n+            }\n+          }\n+          ret = host.compareToIgnoreCase(uri.host)\n+          if (ret != 0) {\n+            return ret\n+          }\n+          if (port != uri.port) {\n+            port - uri.port\n+          }\n+        } else {\n+          ret = authority.compareTo(uri.authority)\n+          if (ret != 0) {\n+            return ret\n+          }\n+        }\n+      }\n+      ret = path.compareTo(uri.path)\n+      if (ret != 0) {\n+        return ret\n+      }\n+      if (query != null && uri.query == null) {\n+        1\n+      } else if (query == null && uri.query != null) {\n+        -1\n+      } else if (query != null && uri.query != null) {\n+        ret = query.compareTo(uri.query)\n+        if (ret != 0) {\n+          return ret\n+        }\n+      }\n+    }\n+    if (fragment != null && uri.fragment == null) {\n+      1\n+    } else if (fragment == null && uri.fragment != null) {\n+      -1\n+    } else if (fragment != null && uri.fragment != null) {\n+      ret = fragment.compareTo(uri.fragment)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    }\n+    0\n+  }\n+\n+  private def duplicate(): URI = {\n+    val clone: URI = new URI()\n+    clone.absolute = absolute\n+    clone.authority = authority\n+    clone.fragment = fragment\n+    clone.host = host\n+    clone.opaque = opaque\n+    clone.path = path\n+    clone.port = port\n+    clone.query = query\n+    clone.scheme = scheme\n+    clone.schemespecificpart = schemespecificpart\n+    clone.userinfo = userinfo\n+    clone.serverAuthority = serverAuthority\n+    clone\n+  }\n+\n+  /*\n+   * Takes a string that may contain hex sequences like %F1 or %2b and\n+   * converts the hex values following the '%' to lowercase\n+   */\n+\n+  private def convertHexToLowerCase(s: String): String = {\n+    val result: StringBuilder = new StringBuilder(\"\")\n+    if (s.indexOf('%') == -1) {\n+      s"
  },
  {
    "id" : "4b51be37-2806-43c4-af03-8d7aeb33fd3a",
    "prId" : 759,
    "comments" : [
      {
        "id" : "843372df-7249-4d74-9942-5753eb1c2129",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "You're probably missing a `return` here too.",
        "createdAt" : "2017-05-30T23:45:08Z",
        "updatedAt" : "2017-06-01T18:50:57Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e5c33328fce67383bf601a0b10c7f4e6576fecbb",
    "line" : null,
    "diffHunk" : "@@ -1,33 +1,1415 @@\n package java.net\n \n-final class URI(scheme: String,\n-                userInfo: String,\n-                host: String,\n-                port: Int,\n-                path: String,\n-                query: String,\n-                fragment: String)\n-    extends Serializable {\n+import java.io.IOException\n+import java.io.Serializable\n+import java.io.UnsupportedEncodingException\n+import java.util.StringTokenizer\n \n-  def getFragment(): String =\n-    fragment\n+object URI {\n+  val unreserved: String = \"_-!.~\\'()*\" //$NON-NLS-1$\n \n-  def getHost(): String =\n-    host\n+  val punct: String = \",;:$&+=\" //$NON-NLS-1$\n \n-  def getPath(): String =\n-    path\n+  val reserved: String = punct + \"?/[]@\" //$NON-NLS-1$\n \n-  def getPort(): Int =\n-    port\n+  val someLegal: String = unreserved + punct\n \n-  def getQuery(): String =\n-    query\n+  val queryLegal: String = unreserved + reserved + \"\\\\\\\"\" //$NON-NLS-1$\n \n-  def getScheme(): String =\n-    scheme\n+  val allLegal: String = unreserved + reserved\n \n-  def getUserInfo(): String =\n-    userInfo\n+  /**\n+   * Parses the given argument {@code uri} and creates an appropriate URI\n+   * instance.\n+   *\n+   * @param uri\n+   *            the string which has to be parsed to create the URI instance.\n+   * @return the created instance representing the given URI.\n+   */\n+  def create(uri: String): URI = {\n+    var result: URI = null\n+    result = new URI(uri)\n+    result\n+  }\n+\n+}\n+\n+final class URI extends Comparable[URI] with Serializable {\n+\n+  import URI._\n+\n+  private val serialVersionUID = -6052424284110960213l\n+\n+  private var string: String = _\n+\n+  @transient private var scheme: String             = _\n+  @transient private var schemespecificpart: String = _\n+  @transient private var authority: String          = _\n+  @transient private var userinfo: String           = _\n+  @transient private var host: String               = _\n+  @transient private var port: Int                  = -1\n+  @transient private var path: String               = _\n+  @transient private var query: String              = _\n+  @transient private var fragment: String           = _\n+  @transient private var opaque: Boolean            = _\n+  @transient private var absolute: Boolean          = _\n+  @transient private var serverAuthority: Boolean   = false\n+  @transient private var hash: Int                  = -1\n+\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  /**\n+   * Creates a new URI instance according to the given string {@code uri}.\n+   *\n+   * @param uri\n+   * the textual URI representation to be parsed into a URI object.\n+   * @throws URISyntaxException\n+   * if the given string { @code uri} doesn't fit to the\n+   *                             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(uri: String) = {\n+    this()\n+    new Helper().parseURI(uri, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]scheme-specific-part[#fragment]}\n+   *\n+   * @param scheme\n+   * the scheme part of the URI.\n+   * @param ssp\n+   * the scheme-specific-part of the URI.\n+   * @param frag\n+   * the fragment part of the URI.\n+   * @throws URISyntaxException\n+   * if the temporary created string doesn't fit to the\n+   * specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, ssp: String, frag: String) = {\n+    this()\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (ssp != null) {\n+      uri.append(quoteComponent(ssp, allLegal))\n+    }\n+    if (frag != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(frag, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][user-info@]host[:port][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param userinfo\n+   *            the user information of the URI for authentication and\n+   *            authorization.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param port\n+   *            the port number of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           userinfo: String,\n+           host: String,\n+           port: Int,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    var hostVar   = host\n+    var earlyStop = false\n+    if (scheme == null && userinfo == null && host == null && path == null &&\n+        query == null &&\n+        fragment == null) {\n+      this.path = \"\"\n+      earlyStop = true\n+    }\n+    if (!earlyStop) {\n+      if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+        throw new URISyntaxException(path, \"Relative path\")\n+      }\n+      val uri: StringBuilder = new StringBuilder()\n+      if (scheme != null) {\n+        uri.append(scheme)\n+        uri.append(':')\n+      }\n+      if (userinfo != null || host != null || port != -1) {\n+        uri.append(\"//\")\n+      }\n+      if (userinfo != null) {\n+        uri.append(quoteComponent(userinfo, someLegal))\n+        uri.append('@')\n+      }\n+      if (host != null) {\n+        if (host.indexOf(':') != -1 && host.indexOf(']') == -1 && host.indexOf(\n+              '[') == -1) {\n+          hostVar = \"[\" + host + \"]\"\n+        }\n+        uri.append(hostVar)\n+      }\n+      if (port != -1) {\n+        uri.append(':')\n+        uri.append(port)\n+      }\n+      if (path != null) {\n+        uri.append(quoteComponent(path, \"/@\" + someLegal))\n+      }\n+      if (query != null) {\n+        uri.append('?')\n+        uri.append(quoteComponent(query, allLegal))\n+      }\n+      if (fragment != null) {\n+        uri.append('#')\n+        uri.append(quoteComponent(fragment, allLegal))\n+      }\n+      new Helper().parseURI(uri.toString, true)\n+    }\n+  }\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:]host[path][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param host\n+   *            the host name of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String, host: String, path: String, fragment: String) =\n+    this(scheme, null, host, -1, path, null, fragment)\n+\n+  /**\n+   * Creates a new URI instance using the given arguments. This constructor\n+   * first creates a temporary URI string from the given components. This\n+   * string will be parsed later on to create the URI instance.\n+   * <p>\n+   * {@code [scheme:][//authority][path][?query][#fragment]}\n+   *\n+   * @param scheme\n+   *            the scheme part of the URI.\n+   * @param authority\n+   *            the authority part of the URI.\n+   * @param path\n+   *            the path to the resource on the host.\n+   * @param query\n+   *            the query part of the URI to specify parameters for the\n+   *            resource.\n+   * @param fragment\n+   *            the fragment part of the URI.\n+   * @throws URISyntaxException\n+   *             if the temporary created string doesn't fit to the\n+   *             specification RFC2396 or could not be parsed correctly.\n+   */\n+  def this(scheme: String,\n+           authority: String,\n+           path: String,\n+           query: String,\n+           fragment: String) = {\n+    this()\n+    if (scheme != null && path != null && path.length > 0 && path.charAt(0) != '/') {\n+      throw new URISyntaxException(path, \"Relative path\")\n+    }\n+    val uri: StringBuilder = new StringBuilder()\n+    if (scheme != null) {\n+      uri.append(scheme)\n+      uri.append(':')\n+    }\n+    if (authority != null) {\n+      uri.append(\"//\")\n+      uri.append(quoteComponent(authority, \"@[]\" + someLegal))\n+    }\n+    if (path != null) {\n+      uri.append(quoteComponent(path, \"/@\" + someLegal))\n+    }\n+    if (query != null) {\n+      uri.append('?')\n+      uri.append(quoteComponent(query, allLegal))\n+    }\n+    if (fragment != null) {\n+      uri.append('#')\n+      uri.append(quoteComponent(fragment, allLegal))\n+    }\n+    new Helper().parseURI(uri.toString, false)\n+  }\n+\n+  private class Helper {\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseURI(uri: String, forceServer: Boolean): Unit = {\n+      var temp: String = uri\n+      string = uri\n+      var index: Int  = 0\n+      var index1: Int = 0\n+      var index2: Int = 0\n+      var index3: Int = 0\n+\n+      index = temp.indexOf('#')\n+      if (index != -1) {\n+        fragment = temp.substring(index + 1)\n+        validateFragment(uri, fragment, index + 1)\n+        temp = temp.substring(0, index)\n+      }\n+      index = temp.indexOf(':')\n+      index1 = index\n+      index2 = temp.indexOf('/')\n+      index3 = temp.indexOf('?')\n+      if (index != -1 && (index2 >= index || index2 == -1) && (index3 >= index || index3 == -1)) {\n+        absolute = true\n+        scheme = temp.substring(0, index)\n+        if (scheme.length == 0) {\n+          throw new URISyntaxException(uri, \"Scheme expected\", index)\n+        }\n+        validateScheme(uri, scheme, 0)\n+        schemespecificpart = temp.substring(index + 1)\n+        if (schemespecificpart.length == 0) {\n+          throw new URISyntaxException(uri,\n+                                       \"Scheme-specific part expected\",\n+                                       index + 1)\n+        }\n+      } else {\n+        absolute = false\n+        schemespecificpart = temp\n+      }\n+\n+      if (scheme == null || schemespecificpart.length > 0 && schemespecificpart\n+            .charAt(0) == '/') {\n+        opaque = false\n+\n+        temp = schemespecificpart\n+        index = temp.indexOf('?')\n+        if (index != -1) {\n+          query = temp.substring(index + 1)\n+          temp = temp.substring(0, index)\n+          validateQuery(uri, query, index2 + 1 + index)\n+        }\n+\n+        if (temp.startsWith(\"//\")) {\n+          index = temp.indexOf('/', 2)\n+          if (index != -1) {\n+            authority = temp.substring(2, index)\n+            path = temp.substring(index)\n+          } else {\n+            authority = temp.substring(2)\n+            if (authority.length() == 0 && query == null\n+                && fragment == null) {\n+              throw new URISyntaxException(uri,\n+                                           \"Authority expected\",\n+                                           uri.length())\n+            }\n+\n+            path = \"\";\n+          }\n+\n+          if (authority.length() == 0) {\n+            authority = null\n+          } else {\n+            validateAuthority(uri, authority, index1 + 3)\n+          }\n+        } else {\n+          path = temp\n+        }\n+\n+        var pathIndex: Int = 0\n+        if (index2 > -1) {\n+          pathIndex += index2\n+        }\n+        if (index > -1) {\n+          pathIndex += index\n+        }\n+        validatePath(uri, path, pathIndex)\n+      } else { // if not hierarchical, URI is opaque\n+        opaque = true\n+        validateSsp(uri, schemespecificpart, index2 + 2 + index)\n+      }\n+\n+      parseAuthority(forceServer)\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateScheme(uri: String, scheme: String, index: Int): Unit = {\n+      val ch: Char = scheme.charAt(0)\n+      if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))) {\n+        throw new URISyntaxException(uri, \"Illegal character in scheme\", 0)\n+      }\n+\n+      try {\n+        URIEncoderDecoder.validateSimple(scheme, \"+-.\");\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in scheme\",\n+                                       index\n+                                         + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateSsp(uri: String, ssp: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(ssp, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(\n+            uri,\n+            e.getReason + \" in scheme specific part\",\n+            index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateAuthority(uri: String, authority: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(authority, \"@[]\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in authority\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validatePath(uri: String, path: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(path, \"/@\" + someLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in path\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateQuery(uri: String, query: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(query, queryLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in query\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateFragment(uri: String, fragment: String, index: Int): Unit = {\n+      try {\n+        URIEncoderDecoder.validate(fragment, allLegal)\n+      } catch {\n+        case e: URISyntaxException =>\n+          throw new URISyntaxException(uri,\n+                                       e.getReason + \" in fragment\",\n+                                       index + e.getIndex)\n+      }\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def parseAuthority(forceServer: Boolean): Unit = {\n+      if (authority == null) {\n+        return\n+      }\n+      var temp: String         = null\n+      var tempUserinfo: String = null\n+      var tempHost: String     = null\n+      var index: Int           = 0\n+      var hostindex: Int       = 0\n+      var tempPort: Int        = -1\n+      temp = authority\n+      index = temp.indexOf('@')\n+      if (index != -1) {\n+        tempUserinfo = temp.substring(0, index)\n+        validateUserinfo(authority, tempUserinfo, 0)\n+        temp = temp.substring(index + 1)\n+        hostindex = index + 1\n+      }\n+      index = temp.lastIndexOf(':')\n+      val endindex: Int = temp.indexOf(']')\n+      if (index != -1 && endindex < index) {\n+        tempHost = temp.substring(0, index)\n+        if (index < (temp.length - 1)) {\n+          try {\n+            tempPort = java.lang.Integer.parseInt(temp.substring(index + 1))\n+            if (tempPort < 0) {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+          } catch {\n+            case e: NumberFormatException => {\n+              if (forceServer) {\n+                throw new URISyntaxException(authority,\n+                                             \"Invalid port number\",\n+                                             hostindex + index + 1)\n+              }\n+              return\n+            }\n+\n+          }\n+        }\n+      } else {\n+        tempHost = temp\n+      }\n+      if (tempHost == \"\") {\n+        if (forceServer) {\n+          throw new URISyntaxException(authority, \"Expected host\", hostindex)\n+        }\n+        return\n+      }\n+      if (!isValidHost(forceServer, tempHost)) {\n+        return\n+      }\n+\n+      userinfo = tempUserinfo\n+      host = tempHost\n+      port = tempPort\n+      serverAuthority = true\n+    }\n+\n+    @throws(classOf[URISyntaxException])\n+    def validateUserinfo(uri: String, userinfo: String, index: Int): Unit = {\n+      for (i <- 0 until userinfo.length) {\n+        val ch: Char = userinfo.charAt(i)\n+        if (ch == ']' || ch == '[') {\n+          throw new URISyntaxException(uri,\n+                                       \"Illegal character in userinfo\",\n+                                       index + i)\n+        }\n+      }\n+    }\n+\n+    def isValidHost(forceServer: Boolean, host: String): Boolean = {\n+      if (host.charAt(0) == '[') {\n+        if (host.charAt(host.length - 1) != ']') {\n+          throw new URISyntaxException(\n+            host,\n+            \"Expected a closing square bracket for ipv6 address\",\n+            0)\n+        }\n+        if (!isValidIP6Address(host)) {\n+          throw new URISyntaxException(host, \"Malformed ipv6 address\")\n+        }\n+        return true\n+      }\n+      if (host.indexOf('[') != -1 || host.indexOf(']') != -1) {\n+        throw new URISyntaxException(host, \"Illegal character in host name\", 0)\n+      }\n+      val index: Int = host.lastIndexOf('.')\n+      if (index < 0 || index == host.length - 1 ||\n+          !java.lang.Character.isDigit(host.charAt(index + 1))) {\n+        if (isValidDomainName(host)) {\n+          return true\n+        }\n+        if (forceServer) {\n+          throw new URISyntaxException(host,\n+                                       \"Illegal character in host name\",\n+                                       0)\n+        }\n+        return false\n+      }\n+      if (isValidIPv4Address(host)) {\n+        return true\n+      }\n+      if (forceServer) {\n+        throw new URISyntaxException(host, \"Malformed ipv4 address\", 0)\n+      }\n+      false\n+    }\n+\n+    def isValidDomainName(host: String): Boolean = {\n+      try {\n+        URIEncoderDecoder.validateSimple(host, \"-.\")\n+      } catch {\n+        case e: URISyntaxException => return false\n+      }\n+      var label: String       = null\n+      val st: StringTokenizer = new StringTokenizer(host, \".\")\n+      while (st.hasMoreTokens) {\n+        label = st.nextToken()\n+        if (label.startsWith(\"-\") || label.endsWith(\"-\")) {\n+          return false\n+        }\n+      }\n+      if (label != host) {\n+        val ch: Char = label.charAt(0)\n+        if (ch >= '0' && ch <= '9') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIPv4Address(host: String): Boolean = {\n+      var index: Int  = 0\n+      var index2: Int = 0\n+      try {\n+        var num: Int = 0\n+        index = host.indexOf('.')\n+        num = java.lang.Integer.parseInt(host.substring(0, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index2 = host.indexOf('.', index + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index + 1, index2))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        index = host.indexOf('.', index2 + 1)\n+        num = java.lang.Integer.parseInt(host.substring(index2 + 1, index))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+        num = java.lang.Integer.parseInt(host.substring(index + 1))\n+        if (num < 0 || num > 255) {\n+          return false\n+        }\n+      } catch {\n+        case e: Exception => false\n+\n+      }\n+      true\n+    }\n+\n+    def isValidIP6Address(ipAddress: String): Boolean = {\n+      val length: Int          = ipAddress.length\n+      var doubleColon: Boolean = false\n+      var numberOfColons: Int  = 0\n+      var numberOfPeriods: Int = 0\n+      var word: String         = \"\"\n+      var c: Char              = 0\n+      var prevChar: Char       = 0\n+      var offset: Int          = 0\n+      if (length < 2) {\n+        return false\n+      }\n+      for (i <- 0 until length) {\n+        prevChar = c\n+        c = ipAddress.charAt(i)\n+        c match {\n+          case '[' =>\n+            if (i != 0) {\n+              return false\n+            }\n+            if (ipAddress.charAt(length - 1) != ']') {\n+              return false\n+            }\n+            if ((ipAddress.charAt(1) == ':') && (ipAddress.charAt(2) != ':')) {\n+              return false\n+            }\n+            offset = 1\n+            if (length < 4) {\n+              return false\n+            }\n+          case ']' =>\n+            if (i != length - 1) {\n+              return false\n+            }\n+            if (ipAddress.charAt(0) != '[') {\n+              return false\n+            }\n+          case '.' => { numberOfPeriods += 1; numberOfPeriods - 1 }\n+          if (numberOfPeriods > 3) {\n+            return false\n+          }\n+          if (!isValidIP4Word(word)) {\n+            return false\n+          }\n+          if (numberOfColons != 6 && !doubleColon) {\n+            return false\n+          }\n+          if (numberOfColons == 7 && ipAddress.charAt(0 + offset) != ':' &&\n+              ipAddress.charAt(1 + offset) != ':') {\n+            return false\n+          }\n+          word = \"\"\n+        case ':' => { numberOfColons += 1; numberOfColons - 1 }\n+          if (numberOfColons > 7) {\n+            return false\n+          }\n+          if (numberOfPeriods > 0) {\n+            return false\n+          }\n+          if (prevChar == ':') {\n+            if (doubleColon) {\n+              return false\n+            }\n+            doubleColon = true\n+          }\n+          word = \"\"\n+        case _ =>\n+            if (word.length > 3) {\n+              return false\n+            }\n+            if (!isValidHexChar(c)) {\n+              return false\n+            }\n+            word += c\n+\n+        }\n+      }\n+      if (numberOfPeriods > 0) {\n+        if (numberOfPeriods != 3 || !isValidIP4Word(word)) {\n+          return false\n+        }\n+      } else {\n+        if (numberOfColons != 7 && !doubleColon) {\n+          return false\n+        }\n+        if (word == \"\" && ipAddress.charAt(length - 1 - offset) != ':' &&\n+            ipAddress.charAt(length - 2 - offset) != ':') {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+\n+    def isValidIP4Word(word: String): Boolean = {\n+      var c: Char = 0\n+      if (word.length < 1 || word.length > 3) {\n+        return false\n+      }\n+      for (i <- 0 until word.length) {\n+        c = word.charAt(i)\n+        if (!(c >= '0' && c <= '9')) {\n+          return false\n+        }\n+      }\n+      if (java.lang.Integer.parseInt(word) > 255) {\n+        return false\n+      }\n+      true\n+    }\n+\n+    def isValidHexChar(c: Char): Boolean =\n+      (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')\n+\n+  }\n+\n+  private def quoteComponent(component: String, legalset: String): String = {\n+    try {\n+      URIEncoderDecoder.quoteIllegal(component, legalset);\n+    } catch {\n+      case e: UnsupportedOperationException =>\n+        throw new RuntimeException(e.toString)\n+    }\n+  }\n+\n+  def compareTo(uri: URI): Int = {\n+    var ret: Int = 0\n+    if (scheme == null && uri.scheme != null) {\n+      -1\n+    } else if (scheme != null && uri.scheme == null) {\n+      1\n+    } else if (scheme != null && uri.scheme != null) {\n+      ret = scheme.compareToIgnoreCase(uri.scheme)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    }\n+    if (!opaque && uri.opaque) {\n+      -1\n+    } else if (opaque && !uri.opaque) {\n+      1\n+    } else if (opaque && uri.opaque) {\n+      ret = schemespecificpart.compareTo(uri.schemespecificpart)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    } else {\n+      if (authority != null && uri.authority == null) {\n+        1\n+      } else if (authority == null && uri.authority != null) {\n+        -1\n+      } else if (authority != null && uri.authority != null) {\n+        if (host != null && uri.host != null) {\n+          if (userinfo != null && uri.userinfo == null) {\n+            1\n+          } else if (userinfo == null && uri.userinfo != null) {\n+            -1\n+          } else if (userinfo != null && uri.userinfo != null) {\n+            ret = userinfo.compareTo(uri.userinfo)\n+            if (ret != 0) {\n+              return ret\n+            }\n+          }\n+          ret = host.compareToIgnoreCase(uri.host)\n+          if (ret != 0) {\n+            return ret\n+          }\n+          if (port != uri.port) {\n+            port - uri.port\n+          }\n+        } else {\n+          ret = authority.compareTo(uri.authority)\n+          if (ret != 0) {\n+            return ret\n+          }\n+        }\n+      }\n+      ret = path.compareTo(uri.path)\n+      if (ret != 0) {\n+        return ret\n+      }\n+      if (query != null && uri.query == null) {\n+        1\n+      } else if (query == null && uri.query != null) {\n+        -1\n+      } else if (query != null && uri.query != null) {\n+        ret = query.compareTo(uri.query)\n+        if (ret != 0) {\n+          return ret\n+        }\n+      }\n+    }\n+    if (fragment != null && uri.fragment == null) {\n+      1\n+    } else if (fragment == null && uri.fragment != null) {\n+      -1\n+    } else if (fragment != null && uri.fragment != null) {\n+      ret = fragment.compareTo(uri.fragment)\n+      if (ret != 0) {\n+        return ret\n+      }\n+    }\n+    0\n+  }\n+\n+  private def duplicate(): URI = {\n+    val clone: URI = new URI()\n+    clone.absolute = absolute\n+    clone.authority = authority\n+    clone.fragment = fragment\n+    clone.host = host\n+    clone.opaque = opaque\n+    clone.path = path\n+    clone.port = port\n+    clone.query = query\n+    clone.scheme = scheme\n+    clone.schemespecificpart = schemespecificpart\n+    clone.userinfo = userinfo\n+    clone.serverAuthority = serverAuthority\n+    clone\n+  }\n+\n+  /*\n+   * Takes a string that may contain hex sequences like %F1 or %2b and\n+   * converts the hex values following the '%' to lowercase\n+   */\n+\n+  private def convertHexToLowerCase(s: String): String = {\n+    val result: StringBuilder = new StringBuilder(\"\")\n+    if (s.indexOf('%') == -1) {\n+      s\n+    }\n+    var previndex: Int = 0\n+    var index: Int     = s.indexOf('%', previndex)\n+    while (index != -1) {\n+      result.append(s.substring(previndex, index + 1))\n+      result.append(s.substring(index + 1, index + 3).toLowerCase())\n+      index += 3\n+      previndex = index\n+      index = s.indexOf('%', previndex)\n+    }\n+    result.toString\n+  }\n+\n+  /*\n+   * Takes two strings that may contain hex sequences like %F1 or %2b and\n+   * compares them, ignoring case for the hex values. Hex values must always\n+   * occur in pairs as above\n+   */\n+\n+  private def equalsHexCaseInsensitive(first: String,\n+                                       second: String): Boolean = {\n+    if (first.indexOf('%') != second.indexOf('%')) {\n+      first == second"
  },
  {
    "id" : "1b41deb3-1d19-4eda-9f95-8df0a29202a9",
    "prId" : 788,
    "comments" : [
      {
        "id" : "396643eb-dfb5-4a10-88e7-92647b5b7b7e",
        "parentId" : null,
        "author" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "body" : "Updated by `./bin/scalafmt` with the new version.",
        "createdAt" : "2017-06-06T11:24:30Z",
        "updatedAt" : "2017-06-06T11:24:30Z",
        "lastEditedBy" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "85a45993efcf223bb5ee86b73265714d616fbe8f",
    "line" : 5,
    "diffHunk" : "@@ -755,7 +755,7 @@ final class URI private () extends Comparable[URI] with Serializable {\n     var index: Int     = first.indexOf('%', previndex)\n     while (index != -1 && second.indexOf('%', previndex) == index) {\n       var `match`: Boolean = first.substring(previndex, index) == second\n-          .substring(previndex, index)\n+        .substring(previndex, index)"
  },
  {
    "id" : "776dd655-ae96-4e12-987c-80d1edb4ce81",
    "prId" : 927,
    "comments" : [
      {
        "id" : "8cefa26c-e39c-4af7-838f-369b1f04b81d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "@olafurpg 82 column line with 80 column limit.",
        "createdAt" : "2017-08-09T11:14:42Z",
        "updatedAt" : "2017-08-09T12:50:56Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6b6a4959468b2913685c807b59caa6a043a7421a",
    "line" : 20,
    "diffHunk" : "@@ -746,8 +745,7 @@ final class URI private () extends Comparable[URI] with Serializable {\n    * occur in pairs as above\n    */\n \n-  private def equalsHexCaseInsensitive(first: String,\n-                                       second: String): Boolean = {\n+  private def equalsHexCaseInsensitive(first: String, second: String): Boolean = {"
  }
]
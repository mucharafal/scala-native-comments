[
  {
    "id" : "1b431c62-68c2-4912-b34e-dae6d893a02b",
    "prId" : 914,
    "comments" : [
      {
        "id" : "eff404af-9f62-438c-94bf-03f6f3ed6e45",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "Is this ported from Harmony?",
        "createdAt" : "2017-07-24T08:43:21Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2eecacd9-4d39-4e2f-97d0-30334d429a19",
        "parentId" : "eff404af-9f62-438c-94bf-03f6f3ed6e45",
        "author" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "body" : "Not really, I may have been inspired by Harmony but the implementation is different in most cases. Should I mention it here?",
        "createdAt" : "2017-08-14T10:53:48Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "daf21259-96fd-440b-b75a-bb1331c1dbdb",
        "parentId" : "eff404af-9f62-438c-94bf-03f6f3ed6e45",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "If it's not a 1-to-1 port, you don't have to.",
        "createdAt" : "2017-08-18T14:59:18Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : 21,
    "diffHunk" : "@@ -0,0 +1,340 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {"
  },
  {
    "id" : "0b64d28c-be19-4f82-819e-920b2ea089cc",
    "prId" : 914,
    "comments" : [
      {
        "id" : "e3762b33-d84d-4281-8226-33039488d6f8",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "The parameter `streaming` is never used. Is it normal?",
        "createdAt" : "2017-08-22T05:22:43Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "edf93971-7395-4e26-a319-e254fa01d58a",
        "parentId" : "e3762b33-d84d-4281-8226-33039488d6f8",
        "author" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "body" : "It's a deprecated mode which makes `Socket` UDP instead of TCP. This can be delegated to `java.net.DatagramSocket` when it gets implemented.\r\n\r\nhttps://github.com/asoltysik/scala-native/blob/1f24ccbefece8cbb4a21fe99ea6af6dbf9ee9ac1/javalib/src/main/scala/java/net/Socket.scala#L21-L25",
        "createdAt" : "2017-08-22T10:38:16Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "asoltysik",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/17353292?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {"
  },
  {
    "id" : "1461b2c3-a542-4c13-a527-ba1285702990",
    "prId" : 914,
    "comments" : [
      {
        "id" : "4ed275fa-b57d-4bf5-9b99-69761262a0b2",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "`override def close()` (there's a side effect)",
        "createdAt" : "2017-08-22T05:53:03Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {"
  },
  {
    "id" : "95f0efeb-e194-4073-9487-b6ab06d3ea58",
    "prId" : 914,
    "comments" : [
      {
        "id" : "013883ef-31aa-49c0-a659-48bbf2f61d54",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "This one has side effects too",
        "createdAt" : "2017-08-22T05:53:22Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {"
  },
  {
    "id" : "9d8cba7a-e675-40a4-b55c-c547d4864f69",
    "prId" : 914,
    "comments" : [
      {
        "id" : "0bdc9ea3-2b12-485a-893b-7e0d4951e0ea",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "This one has side effects too",
        "createdAt" : "2017-08-22T05:53:26Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {"
  },
  {
    "id" : "a90f2b41-ae46-46af-95cd-150dcaa7a9e4",
    "prId" : 914,
    "comments" : [
      {
        "id" : "7e966fdd-2825-4d3c-9647-30e639e7ec2d",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "Why does it return a `Long`? Since `count` is an `Int`, you're sure that `sent` will fit in an `Int`.",
        "createdAt" : "2017-08-22T05:55:16Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {"
  },
  {
    "id" : "cbd40b22-fcd7-46c9-a96c-5575eb306fd7",
    "prId" : 914,
    "comments" : [
      {
        "id" : "2a496689-f18c-4a1d-968b-85fe0312ef5a",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "You can use `buffer.asInstanceOf[ByteArray].at(offset + count)` to get a pointer to the element `offset + count` of the array, instead of copying everything to a new location. For instance:\r\n\r\nhttps://github.com/scala-native/scala-native/blob/feb79591a8bc8b5051fb7f60f6b547f4e70589cb/javalib/src/main/scala/java/util/zip/Inflater.scala#L126-L127",
        "createdAt" : "2017-08-22T05:58:30Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {\n+    if (shutOutput) {\n+      throw new IOException(\"Trying to write to a shut down socket\")\n+    } else if (fd.fd == -1) {\n+      0\n+    } else {\n+      val cArr = stackalloc[Byte](count)"
  },
  {
    "id" : "729d04e9-55f1-46d6-a1da-58e89111b8cd",
    "prId" : 914,
    "comments" : [
      {
        "id" : "e38b15a3-ddd5-4fc2-b5cb-b8a3bd147f72",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "Same here. You can directly do\r\n```scala\r\nval bytesNum = socket.recv(fd.fd, buffer.asInstanceOf[ByteArray].at(offset), count, 0).toInt\r\n```",
        "createdAt" : "2017-08-22T06:00:18Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {\n+    if (shutOutput) {\n+      throw new IOException(\"Trying to write to a shut down socket\")\n+    } else if (fd.fd == -1) {\n+      0\n+    } else {\n+      val cArr = stackalloc[Byte](count)\n+      for (i <- 0 until count) {\n+        !(cArr + i) = buffer(i + offset)\n+      }\n+      var sent: Long = 0\n+      while (sent < count) {\n+        sent += socket.send(fd.fd, cArr + sent, count - sent, 0)\n+      }\n+      sent\n+    }\n+  }\n+\n+  def read(buffer: Array[Byte], offset: Int, count: Int): Int = {\n+    if (shutInput) -1\n+\n+    val cBuff    = stackalloc[Byte](count)\n+    val bytesNum = socket.recv(fd.fd, cBuff, count, 0).toInt"
  },
  {
    "id" : "a83c0b69-3364-495d-b5d2-141bd48a7674",
    "prId" : 914,
    "comments" : [
      {
        "id" : "5af39ee9-9739-46f2-b32c-48a106f81377",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "```scala\r\ncase _ => sys.error(s\"Unknown option: $option)\r\n```",
        "createdAt" : "2017-08-22T06:01:35Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {\n+    if (shutOutput) {\n+      throw new IOException(\"Trying to write to a shut down socket\")\n+    } else if (fd.fd == -1) {\n+      0\n+    } else {\n+      val cArr = stackalloc[Byte](count)\n+      for (i <- 0 until count) {\n+        !(cArr + i) = buffer(i + offset)\n+      }\n+      var sent: Long = 0\n+      while (sent < count) {\n+        sent += socket.send(fd.fd, cArr + sent, count - sent, 0)\n+      }\n+      sent\n+    }\n+  }\n+\n+  def read(buffer: Array[Byte], offset: Int, count: Int): Int = {\n+    if (shutInput) -1\n+\n+    val cBuff    = stackalloc[Byte](count)\n+    val bytesNum = socket.recv(fd.fd, cBuff, count, 0).toInt\n+    if (bytesNum <= 0) {\n+      if (errno.errno == EAGAIN || errno.errno == EWOULDBLOCK) {\n+        throw new SocketTimeoutException(\"Socket timeout while reading data\")\n+      }\n+      -1\n+    } else {\n+      for (i <- 0 until bytesNum) {\n+        buffer(offset + i) = cBuff(i)\n+      }\n+      bytesNum\n+    }\n+  }\n+\n+  override def available: Int = {\n+    if (shutInput) {\n+      0\n+    } else {\n+      val bytesAvailable = stackalloc[CInt]\n+      ioctl(fd.fd, FIONREAD, bytesAvailable.cast[Ptr[Byte]])\n+      !bytesAvailable match {\n+        case -1 =>\n+          throw new IOException(\n+            \"Error while trying to estimate available bytes to read\")\n+        case x => x\n+      }\n+    }\n+  }\n+\n+  // We can't directly map values in SocketOptions to the native ones,\n+  // because some of them have the same value, but require different levels\n+  // for example IP_TOS and TCP_NODELAY have the same value on my machine\n+  private def nativeValueFromOption(option: Int) = option match {\n+    case SocketOptions.IP_TOS       => in.IP_TOS\n+    case SocketOptions.SO_KEEPALIVE => socket.SO_KEEPALIVE\n+    case SocketOptions.SO_LINGER    => socket.SO_LINGER\n+    case SocketOptions.SO_TIMEOUT   => socket.SO_RCVTIMEO\n+    case SocketOptions.SO_OOBINLINE => socket.SO_OOBINLINE\n+    case SocketOptions.SO_RCVBUF    => socket.SO_RCVBUF\n+    case SocketOptions.SO_SNDBUF    => socket.SO_SNDBUF\n+    case SocketOptions.SO_REUSEADDR => socket.SO_REUSEADDR\n+    case SocketOptions.TCP_NODELAY  => tcp.TCP_NODELAY\n+    case _                          => throw new Error(\"This shouldn't happen\")"
  },
  {
    "id" : "22dbf48b-cd42-4d22-9c27-f7c4b3708f0f",
    "prId" : 914,
    "comments" : [
      {
        "id" : "e1f04447-ad4e-4bb4-adbf-e146d06b456d",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "The whole expression is a bit hard to follow. Could you do:\r\n\r\n```scala\r\noptID match {\r\n  case SocketOptions.TCP_NODELAY | SocketOptions.SO_KEEPALIVE | ... =>\r\n     // ...\r\n   case SocketOptions.SO_LINGER =>\r\n     // ...\r\n   case ...\r\n}\r\n```",
        "createdAt" : "2017-08-22T06:04:34Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {\n+    if (shutOutput) {\n+      throw new IOException(\"Trying to write to a shut down socket\")\n+    } else if (fd.fd == -1) {\n+      0\n+    } else {\n+      val cArr = stackalloc[Byte](count)\n+      for (i <- 0 until count) {\n+        !(cArr + i) = buffer(i + offset)\n+      }\n+      var sent: Long = 0\n+      while (sent < count) {\n+        sent += socket.send(fd.fd, cArr + sent, count - sent, 0)\n+      }\n+      sent\n+    }\n+  }\n+\n+  def read(buffer: Array[Byte], offset: Int, count: Int): Int = {\n+    if (shutInput) -1\n+\n+    val cBuff    = stackalloc[Byte](count)\n+    val bytesNum = socket.recv(fd.fd, cBuff, count, 0).toInt\n+    if (bytesNum <= 0) {\n+      if (errno.errno == EAGAIN || errno.errno == EWOULDBLOCK) {\n+        throw new SocketTimeoutException(\"Socket timeout while reading data\")\n+      }\n+      -1\n+    } else {\n+      for (i <- 0 until bytesNum) {\n+        buffer(offset + i) = cBuff(i)\n+      }\n+      bytesNum\n+    }\n+  }\n+\n+  override def available: Int = {\n+    if (shutInput) {\n+      0\n+    } else {\n+      val bytesAvailable = stackalloc[CInt]\n+      ioctl(fd.fd, FIONREAD, bytesAvailable.cast[Ptr[Byte]])\n+      !bytesAvailable match {\n+        case -1 =>\n+          throw new IOException(\n+            \"Error while trying to estimate available bytes to read\")\n+        case x => x\n+      }\n+    }\n+  }\n+\n+  // We can't directly map values in SocketOptions to the native ones,\n+  // because some of them have the same value, but require different levels\n+  // for example IP_TOS and TCP_NODELAY have the same value on my machine\n+  private def nativeValueFromOption(option: Int) = option match {\n+    case SocketOptions.IP_TOS       => in.IP_TOS\n+    case SocketOptions.SO_KEEPALIVE => socket.SO_KEEPALIVE\n+    case SocketOptions.SO_LINGER    => socket.SO_LINGER\n+    case SocketOptions.SO_TIMEOUT   => socket.SO_RCVTIMEO\n+    case SocketOptions.SO_OOBINLINE => socket.SO_OOBINLINE\n+    case SocketOptions.SO_RCVBUF    => socket.SO_RCVBUF\n+    case SocketOptions.SO_SNDBUF    => socket.SO_SNDBUF\n+    case SocketOptions.SO_REUSEADDR => socket.SO_REUSEADDR\n+    case SocketOptions.TCP_NODELAY  => tcp.TCP_NODELAY\n+    case _                          => throw new Error(\"This shouldn't happen\")\n+  }\n+\n+  override def getOption(optID: Int): Object = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+\n+    val level = optID match {\n+      case SocketOptions.TCP_NODELAY => in.IPPROTO_TCP\n+      case SocketOptions.IP_TOS      => in.IPPROTO_IP\n+      case _                         => socket.SOL_SOCKET\n+    }\n+\n+    val optValue = nativeValueFromOption(optID)\n+\n+    val opt = if (optID == SocketOptions.SO_LINGER) {\n+      stackalloc[socket.linger].cast[Ptr[Byte]]\n+    } else {\n+      stackalloc[CInt].cast[Ptr[Byte]]\n+    }\n+\n+    val len = stackalloc[socket.socklen_t]\n+    !len = if (optID == SocketOptions.SO_LINGER) {\n+      sizeof[socket.linger].toUInt\n+    } else {\n+      sizeof[CInt].toUInt\n+    }\n+\n+    if (socket.getsockopt(fd.fd, level, optValue, opt, len) == -1) {\n+      throw new SocketException(\n+        \"Exception while getting socket option with id: \"\n+          + optValue + \", errno: \" + errno.errno)\n+    }\n+    if (optID == SocketOptions.TCP_NODELAY || optID == SocketOptions.SO_KEEPALIVE\n+        || optID == SocketOptions.SO_REUSEADDR\n+        || optID == SocketOptions.SO_OOBINLINE) {\n+      Boolean.box(!(opt.cast[Ptr[CInt]]) != 0)\n+    } else if (optID == SocketOptions.SO_LINGER) {\n+      val linger = opt.cast[Ptr[socket.linger]]\n+      if (linger.l_onoff != 0) {\n+        Integer.valueOf(linger.l_linger)\n+      } else {\n+        Integer.valueOf(-1)\n+      }\n+    } else if (optID == SocketOptions.SO_TIMEOUT) {\n+      Integer.valueOf(this.timeout)\n+    } else {\n+      Integer.valueOf(!(opt.cast[Ptr[CInt]]))\n+    }"
  },
  {
    "id" : "d3e950df-01e4-4050-a4a2-6a30283bd6d6",
    "prId" : 914,
    "comments" : [
      {
        "id" : "ffcfd58a-c97f-414d-a904-82b5f5e814cf",
        "parentId" : null,
        "author" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "body" : "Could you refactor this one with a `match` too?",
        "createdAt" : "2017-08-22T06:05:03Z",
        "updatedAt" : "2017-08-22T11:53:21Z",
        "lastEditedBy" : {
          "login" : "Duhemm",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1765926?u=025ccd7d65512bc68d5a0b24bb857dabd6dd381d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "075182ddbccc165cd4c24fea2756279fa9143f14",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,463 @@\n+package java.net\n+\n+import scala.scalanative.native._\n+import scala.scalanative.runtime.ByteArray\n+import scala.scalanative.posix.errno._\n+import scala.scalanative.posix.sys.socket\n+import scala.scalanative.posix.sys.socketOps._\n+import scala.scalanative.posix.netinet.in\n+import scala.scalanative.posix.netinet.inOps._\n+import scala.scalanative.posix.netinet.tcp\n+import scala.scalanative.posix.arpa.inet\n+import scala.scalanative.posix.netdb._\n+import scala.scalanative.posix.netdbOps._\n+import scala.scalanative.posix.sys.ioctl._\n+import scala.scalanative.posix.fcntl._\n+import scala.scalanative.posix.sys.select._\n+import scala.scalanative.posix.sys.selectOps._\n+import scala.scalanative.posix.unistd.{close => cClose}\n+import java.io.{FileDescriptor, IOException, OutputStream, InputStream}\n+\n+private[net] class PlainSocketImpl extends SocketImpl {\n+\n+  protected[net] var fd                   = new FileDescriptor\n+  protected[net] var localport            = 0\n+  protected[net] var address: InetAddress = null\n+  protected[net] var port                 = 0\n+\n+  private var timeout = 0\n+\n+  override def getInetAddress: InetAddress       = address\n+  override def getFileDescriptor: FileDescriptor = fd\n+\n+  override def create(streaming: Boolean): Unit = {\n+    val sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n+    if (sock < 0) throw new IOException(\"Couldn't create a socket\")\n+    fd = new FileDescriptor(sock)\n+  }\n+\n+  private def fetchLocalPort(family: Int): Option[Int] = {\n+    val len = stackalloc[socket.socklen_t]\n+    val portOpt = if (family == socket.AF_INET) {\n+      val sin = stackalloc[in.sockaddr_in]\n+      !len = sizeof[in.sockaddr_in].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin_port)\n+      }\n+    } else {\n+      val sin = stackalloc[in.sockaddr_in6]\n+      !len = sizeof[in.sockaddr_in6].toUInt\n+\n+      if (socket.getsockname(fd.fd, sin.cast[Ptr[socket.sockaddr]], len) == -1) {\n+        None\n+      } else {\n+        Some(sin.sin6_port)\n+      }\n+    }\n+\n+    portOpt.map(inet.ntohs(_).toInt)\n+  }\n+\n+  override def bind(addr: InetAddress, port: Int): Unit = {\n+    val hints = stackalloc[addrinfo]\n+    val ret   = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(addr.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(port.toString), hints, ret) != 0) {\n+        throw new BindException(\n+          \"Couldn't resolve address: \" + addr.getHostAddress)\n+      }\n+    }\n+\n+    val bindRes = socket.bind(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+\n+    val family = (!ret).ai_family\n+    freeaddrinfo(!ret)\n+\n+    if (bindRes < 0) {\n+      throw new BindException(\n+        \"Couldn't bind to an address: \" + addr.getHostAddress +\n+          \" on port: \" + port.toString)\n+    }\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new BindException(\n+        \"Couldn't bind to address: \" + addr.getHostAddress + \" on port: \" + port)\n+    }\n+  }\n+\n+  override def listen(backlog: Int): Unit = {\n+    if (socket.listen(fd.fd, backlog) == -1) {\n+      throw new SocketException(\"Listen failed\")\n+    }\n+  }\n+\n+  override def accept(s: SocketImpl): Unit = {\n+    if (timeout > 0) {\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+\n+      val selectRes = select(fd.fd + 1, fdset, null, null, time)\n+      selectRes match {\n+        case 0 =>\n+          throw new SocketTimeoutException(\n+            \"Accept timed out, \"\n+              + \"SO_TIMEOUT was set to: \" + timeout)\n+        case -1 => throw new SocketException(\"Accept failed\")\n+        case _  => {}\n+      }\n+    }\n+\n+    val storage = stackalloc[Byte](sizeof[in.sockaddr_in6])\n+    val len     = stackalloc[socket.socklen_t]\n+    !len = sizeof[in.sockaddr_in6].toUInt\n+\n+    val newFd = socket.accept(fd.fd, storage.cast[Ptr[socket.sockaddr]], len)\n+    if (newFd == -1) {\n+      throw new SocketException(\"Accept failed\")\n+    }\n+    val family = storage.cast[Ptr[socket.sockaddr_storage]].ss_family.toInt\n+    val ipstr  = stackalloc[CChar](in.INET6_ADDRSTRLEN)\n+\n+    if (family == socket.AF_INET) {\n+      val sa = storage.cast[Ptr[in.sockaddr_in]]\n+      inet.inet_ntop(socket.AF_INET,\n+                     sa.sin_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin_port).toInt\n+    } else {\n+      val sa = storage.cast[Ptr[in.sockaddr_in6]]\n+      inet.inet_ntop(socket.AF_INET6,\n+                     sa.sin6_addr.cast[Ptr[Byte]],\n+                     ipstr,\n+                     in.INET6_ADDRSTRLEN.toUInt)\n+      s.port = inet.ntohs(sa.sin6_port).toInt\n+    }\n+\n+    Zone { implicit z =>\n+      s.address = InetAddress.getByName(fromCString(ipstr))\n+    }\n+\n+    s.fd = new FileDescriptor(newFd)\n+    s.localport = this.localport\n+  }\n+\n+  override def connect(host: String, port: Int): Unit = {\n+    val addr = InetAddress.getByName(host)\n+    connect(addr, port)\n+  }\n+\n+  override def connect(address: InetAddress, port: Int): Unit = {\n+    connect(new InetSocketAddress(address, port), 0)\n+  }\n+\n+  override def connect(address: SocketAddress, timeout: Int): Unit = {\n+    val inetAddr = address.asInstanceOf[InetSocketAddress]\n+    val hints    = stackalloc[addrinfo]\n+    val ret      = stackalloc[Ptr[addrinfo]]\n+    string.memset(hints.cast[Ptr[Byte]], 0, sizeof[addrinfo])\n+    hints.ai_family = socket.AF_UNSPEC\n+    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV\n+    hints.ai_socktype = socket.SOCK_STREAM\n+\n+    Zone { implicit z =>\n+      val cIP = toCString(inetAddr.getAddress.getHostAddress)\n+      if (getaddrinfo(cIP, toCString(inetAddr.getPort.toString), hints, ret) != 0) {\n+        throw new ConnectException(\n+          \"Couldn't resolve address: \"\n+            + inetAddr.getAddress.getHostAddress)\n+      }\n+    }\n+\n+    val family = (!ret).ai_family\n+\n+    if (timeout == 0) {\n+      val connectRes = socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (connectRes < 0) {\n+        throw new ConnectException(\n+          \"Couldn't connect to address: \"\n+            + inetAddr.getAddress.getHostAddress +\n+            \" on port: \" + inetAddr.getPort)\n+      }\n+    } else {\n+      val opts = fcntl(fd.fd, F_GETFL, 0) | O_NONBLOCK\n+      fcntl(fd.fd, F_SETFL, opts)\n+\n+      val fdset = stackalloc[fd_set]\n+      !fdset._1 = stackalloc[CLongInt](FD_SETSIZE / (8 * sizeof[CLongInt]))\n+      FD_ZERO(fdset)\n+      FD_SET(fd.fd, fdset)\n+\n+      val time = stackalloc[timeval]\n+      time.tv_sec = timeout / 1000\n+      time.tv_usec = (timeout % 1000) * 1000\n+      socket.connect(fd.fd, (!ret).ai_addr, (!ret).ai_addrlen)\n+      freeaddrinfo(!ret)\n+\n+      if (select(fd.fd + 1, null, fdset, null, time) != 1) {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        throw new SocketTimeoutException(\"Connect timed out\")\n+      } else {\n+        fcntl(fd.fd, F_SETFL, opts & ~O_NONBLOCK)\n+        val so_error = stackalloc[CInt].cast[Ptr[Byte]]\n+        val len      = stackalloc[socket.socklen_t]\n+        !len = sizeof[CInt].toUInt\n+        socket.getsockopt(fd.fd,\n+                          socket.SOL_SOCKET,\n+                          socket.SO_ERROR,\n+                          so_error,\n+                          len)\n+        if (!(so_error.cast[Ptr[CInt]]) != 0) {\n+          throw new ConnectException(\n+            \"Couldn't connect to address: \" +\n+              inetAddr.getAddress.getHostAddress\n+              + \" on port: \" + inetAddr.getPort)\n+        }\n+      }\n+    }\n+\n+    this.address = inetAddr.getAddress\n+    this.port = inetAddr.getPort\n+\n+    this.localport = fetchLocalPort(family).getOrElse {\n+      throw new ConnectException(\n+        \"Couldn't resolve a local port when connecting\")\n+    }\n+  }\n+\n+  override def close: Unit = {\n+    if (fd.fd != -1) {\n+      cClose(fd.fd)\n+      fd = new FileDescriptor\n+    }\n+  }\n+\n+  override def getOutputStream: OutputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutOutput) {\n+      throw new SocketException(\"Socket output is shutdown\")\n+    }\n+    new SocketOutputStream(this)\n+  }\n+\n+  override def getInputStream: InputStream = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+    if (shutInput) {\n+      throw new SocketException(\"Socket input is shutdown\")\n+    }\n+    new SocketInputStream(this)\n+  }\n+\n+  override def shutdownOutput: Unit = {\n+    socket.shutdown(fd.fd, 1) match {\n+      case 0 => shutOutput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's output\")\n+    }\n+  }\n+\n+  override def shutdownInput: Unit = {\n+    socket.shutdown(fd.fd, 0) match {\n+      case 0 => shutInput = true\n+      case _ =>\n+        throw new SocketException(\"Error while shutting down socket's input\")\n+    }\n+  }\n+\n+  def write(buffer: Array[Byte], offset: Int, count: Int): Long = {\n+    if (shutOutput) {\n+      throw new IOException(\"Trying to write to a shut down socket\")\n+    } else if (fd.fd == -1) {\n+      0\n+    } else {\n+      val cArr = stackalloc[Byte](count)\n+      for (i <- 0 until count) {\n+        !(cArr + i) = buffer(i + offset)\n+      }\n+      var sent: Long = 0\n+      while (sent < count) {\n+        sent += socket.send(fd.fd, cArr + sent, count - sent, 0)\n+      }\n+      sent\n+    }\n+  }\n+\n+  def read(buffer: Array[Byte], offset: Int, count: Int): Int = {\n+    if (shutInput) -1\n+\n+    val cBuff    = stackalloc[Byte](count)\n+    val bytesNum = socket.recv(fd.fd, cBuff, count, 0).toInt\n+    if (bytesNum <= 0) {\n+      if (errno.errno == EAGAIN || errno.errno == EWOULDBLOCK) {\n+        throw new SocketTimeoutException(\"Socket timeout while reading data\")\n+      }\n+      -1\n+    } else {\n+      for (i <- 0 until bytesNum) {\n+        buffer(offset + i) = cBuff(i)\n+      }\n+      bytesNum\n+    }\n+  }\n+\n+  override def available: Int = {\n+    if (shutInput) {\n+      0\n+    } else {\n+      val bytesAvailable = stackalloc[CInt]\n+      ioctl(fd.fd, FIONREAD, bytesAvailable.cast[Ptr[Byte]])\n+      !bytesAvailable match {\n+        case -1 =>\n+          throw new IOException(\n+            \"Error while trying to estimate available bytes to read\")\n+        case x => x\n+      }\n+    }\n+  }\n+\n+  // We can't directly map values in SocketOptions to the native ones,\n+  // because some of them have the same value, but require different levels\n+  // for example IP_TOS and TCP_NODELAY have the same value on my machine\n+  private def nativeValueFromOption(option: Int) = option match {\n+    case SocketOptions.IP_TOS       => in.IP_TOS\n+    case SocketOptions.SO_KEEPALIVE => socket.SO_KEEPALIVE\n+    case SocketOptions.SO_LINGER    => socket.SO_LINGER\n+    case SocketOptions.SO_TIMEOUT   => socket.SO_RCVTIMEO\n+    case SocketOptions.SO_OOBINLINE => socket.SO_OOBINLINE\n+    case SocketOptions.SO_RCVBUF    => socket.SO_RCVBUF\n+    case SocketOptions.SO_SNDBUF    => socket.SO_SNDBUF\n+    case SocketOptions.SO_REUSEADDR => socket.SO_REUSEADDR\n+    case SocketOptions.TCP_NODELAY  => tcp.TCP_NODELAY\n+    case _                          => throw new Error(\"This shouldn't happen\")\n+  }\n+\n+  override def getOption(optID: Int): Object = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+\n+    val level = optID match {\n+      case SocketOptions.TCP_NODELAY => in.IPPROTO_TCP\n+      case SocketOptions.IP_TOS      => in.IPPROTO_IP\n+      case _                         => socket.SOL_SOCKET\n+    }\n+\n+    val optValue = nativeValueFromOption(optID)\n+\n+    val opt = if (optID == SocketOptions.SO_LINGER) {\n+      stackalloc[socket.linger].cast[Ptr[Byte]]\n+    } else {\n+      stackalloc[CInt].cast[Ptr[Byte]]\n+    }\n+\n+    val len = stackalloc[socket.socklen_t]\n+    !len = if (optID == SocketOptions.SO_LINGER) {\n+      sizeof[socket.linger].toUInt\n+    } else {\n+      sizeof[CInt].toUInt\n+    }\n+\n+    if (socket.getsockopt(fd.fd, level, optValue, opt, len) == -1) {\n+      throw new SocketException(\n+        \"Exception while getting socket option with id: \"\n+          + optValue + \", errno: \" + errno.errno)\n+    }\n+    if (optID == SocketOptions.TCP_NODELAY || optID == SocketOptions.SO_KEEPALIVE\n+        || optID == SocketOptions.SO_REUSEADDR\n+        || optID == SocketOptions.SO_OOBINLINE) {\n+      Boolean.box(!(opt.cast[Ptr[CInt]]) != 0)\n+    } else if (optID == SocketOptions.SO_LINGER) {\n+      val linger = opt.cast[Ptr[socket.linger]]\n+      if (linger.l_onoff != 0) {\n+        Integer.valueOf(linger.l_linger)\n+      } else {\n+        Integer.valueOf(-1)\n+      }\n+    } else if (optID == SocketOptions.SO_TIMEOUT) {\n+      Integer.valueOf(this.timeout)\n+    } else {\n+      Integer.valueOf(!(opt.cast[Ptr[CInt]]))\n+    }\n+  }\n+\n+  override def setOption(optID: Int, value: Object): Unit = {\n+    if (fd.fd == -1) {\n+      throw new SocketException(\"Socket is closed\")\n+    }\n+\n+    val level = optID match {\n+      case SocketOptions.IP_TOS      => in.IPPROTO_IP\n+      case SocketOptions.TCP_NODELAY => in.IPPROTO_TCP\n+      case _                         => socket.SOL_SOCKET\n+    }\n+    val optValue = nativeValueFromOption(optID)\n+\n+    var opt: Ptr[Byte] = stackalloc[Byte]\n+    var len = if (optID == SocketOptions.SO_LINGER) {\n+      sizeof[socket.linger].toUInt\n+    } else if (optID == SocketOptions.SO_TIMEOUT) {\n+      sizeof[timeval].toUInt\n+    } else {\n+      sizeof[CInt].toUInt\n+    }\n+\n+    if (optID == SocketOptions.TCP_NODELAY || optID == SocketOptions.SO_KEEPALIVE\n+        || optID == SocketOptions.SO_REUSEADDR\n+        || optID == SocketOptions.SO_OOBINLINE) {\n+      val ptr = stackalloc[CInt]\n+      !ptr = if (value.asInstanceOf[Boolean]) 1 else 0\n+      opt = ptr.cast[Ptr[Byte]]\n+    } else if (optID == SocketOptions.SO_LINGER) {\n+      val ptr    = stackalloc[socket.linger]\n+      val linger = value.asInstanceOf[Int]\n+\n+      if (linger == -1) ptr.l_onoff = 0\n+      else ptr.l_onoff = 1\n+\n+      ptr.l_linger = linger\n+      opt = ptr.cast[Ptr[Byte]]\n+    } else if (optID == SocketOptions.SO_TIMEOUT) {\n+      val ptr      = stackalloc[timeval]\n+      val mseconds = value.asInstanceOf[Int]\n+\n+      this.timeout = mseconds\n+\n+      ptr.tv_sec = mseconds / 1000\n+      ptr.tv_usec = (mseconds % 1000) * 1000\n+\n+      opt = ptr.cast[Ptr[Byte]]\n+    } else {\n+      val ptr = stackalloc[CInt]\n+      !ptr = value.asInstanceOf[Int]\n+      opt = ptr.cast[Ptr[Byte]]\n+    }"
  },
  {
    "id" : "fccfa145-f295-46c2-883d-bfae3ee7950f",
    "prId" : 1363,
    "comments" : [
      {
        "id" : "40059847-1986-4bc0-837d-7e1e1856239b",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Stackalloc and malloc are not 1-to-1 equivalents. malloc need to be cleaned up manually otherwise this line introduces a memory leak. ",
        "createdAt" : "2018-10-29T09:20:53Z",
        "updatedAt" : "2018-11-07T00:08:31Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e76e2892454bf803dc9910d9590f59cbb5802f1f",
    "line" : null,
    "diffHunk" : "@@ -173,7 +177,7 @@ private[net] class PlainSocketImpl extends SocketImpl {\n   override def connect(address: SocketAddress, timeout: Int): Unit = {\n     val inetAddr = address.asInstanceOf[InetSocketAddress]\n     val hints    = stackalloc[addrinfo]\n-    val ret      = stackalloc[Ptr[addrinfo]]\n+    val ret      = stdlib.malloc(sizeof[Ptr[Byte]]).cast[Ptr[Ptr[addrinfo]]] //stackalloc[Ptr[addrinfo]]"
  }
]
[
  {
    "id" : "73e8151e-079e-4964-9d81-8dc2fac5a8d0",
    "prId" : 529,
    "comments" : [
      {
        "id" : "14b118ba-3f87-430b-a777-aed4d796e7fb",
        "parentId" : null,
        "author" : {
          "login" : "MasseGuillaume",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/921490?u=1ea96b0787a224aed96b7091c354e76d0f55960c&v=4"
        },
        "body" : "Aw shot I did not notice that the [Scala.js](https://github.com/scala-js/scala-js/blob/master/javalib/src/main/scala/java/util/Formatter.scala#L273) implementations use Regex. We don't have Regex yet.\r\n\r\nI think we should implement it without regex for now. It's also better because it will reduce the coupling in java.util.*",
        "createdAt" : "2017-02-26T20:03:27Z",
        "updatedAt" : "2017-02-26T20:12:54Z",
        "lastEditedBy" : {
          "login" : "MasseGuillaume",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/921490?u=1ea96b0787a224aed96b7091c354e76d0f55960c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89a32a010f76abda98c38b4cb65e4b361db0bdbd",
    "line" : 28,
    "diffHunk" : "@@ -28,4 +34,18 @@ class Formatter {\n   override def toString: String                              = ???\n }\n \n-object Formatter\n+object Formatter {\n+\n+  private class RegExpExtractor(val regexp: Regex) {\n+    def unapply(str: String): Option[Regex.Match] = {\n+      regexp.findFirstMatchIn(str)\n+    }\n+  }\n+\n+  private val RegularChunk = new RegExpExtractor(\"\"\"^[^\\x25]+\"\"\".r)"
  },
  {
    "id" : "5eacae52-0e2e-454e-a205-220889ac57d2",
    "prId" : 804,
    "comments" : [
      {
        "id" : "b46900d7-fa01-4fff-9a1e-e9e3032c6a71",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This is going to become just `System.getProperty(\"line.separator\")` without access control wrapper. ",
        "createdAt" : "2017-08-07T11:10:40Z",
        "updatedAt" : "2017-08-07T12:22:56Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f8dba2ebf2d57ef8f753a811fb72cffc6e2ce047",
    "line" : null,
    "diffHunk" : "@@ -1,31 +1,1669 @@\n package java.util\n \n+// Ported from Harmony\n+\n import java.io._\n+import java.lang.StringBuilder\n+import java.math.BigDecimal\n+import java.math.BigInteger\n+import java.math.MathContext\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.security.AccessController\n+import java.security.PrivilegedAction\n+import java.text.DateFormatSymbols\n+import java.text.DecimalFormat\n+import java.text.DecimalFormatSymbols\n+import java.text.NumberFormat\n+\n+import scala.util.control.Breaks\n+\n+class Formatter(\n+    private var _out: Appendable,\n+    private var _locale: Locale\n+) extends Closeable\n+    with Flushable {\n+  if (_out == null)\n+    _out = new StringBuilder()\n+\n+  final class BigDecimalLayoutForm private (name: String, ordinal: Int)\n+      extends Enum[BigDecimalLayoutForm](name, ordinal)\n+\n+  object BigDecimalLayoutForm {\n+    final val SCIENTIFIC    = new BigDecimalLayoutForm(\"SCIENTIFIC\", 0)\n+    final val DECIMAL_FLOAT = new BigDecimalLayoutForm(\"DECIMAL_FLOAT\", 1)\n+\n+    def valueOf(name: String): BigDecimalLayoutForm =\n+      _values.find(_.name == name).getOrElse {\n+        throw new IllegalArgumentException(\n+          \"No enum constant java.util.Formatter.BigDecimalLayoutForm.\" + name)\n+      }\n+\n+    private val _values: Array[BigDecimalLayoutForm] =\n+      Array(SCIENTIFIC, DECIMAL_FLOAT)\n+\n+    def values(): Array[BigDecimalLayoutForm] = _values.clone()\n+  }\n+\n+  private var closed: Boolean = false\n+\n+  private var lastIOException: IOException = _\n+\n+  // Porting note: According to JDK Javadoc, Locale.getDefault() should be\n+  // Locale.getDefault(Locale.Category.FORMAT). However, the former is used because\n+  // Harmony does. The category doesn't exist yet in Scala Native, anyway.\n+  // Porting note #2: The test suite, which is also ported from Harmony,\n+  // assumes Locale.getDefault() as the default locale.\n+  def this() =\n+    this(new StringBuilder(), Locale.getDefault())\n+  def this(a: Appendable) =\n+    this(a, Locale.getDefault())\n+  def this(l: Locale) =\n+    this(new StringBuilder(), l)\n+  def this(os: OutputStream, csn: String, l: Locale) =\n+    this(\n+      new BufferedWriter(new OutputStreamWriter(os, csn)),\n+      l\n+    )\n+  def this(os: OutputStream, csn: String) =\n+    this(os, csn, Locale.getDefault())\n+  def this(os: OutputStream) =\n+    this(\n+      new BufferedWriter(new OutputStreamWriter(os, Charset.defaultCharset())),\n+      Locale.getDefault()\n+    )\n+  def this(file: File, csn: String, l: Locale) =\n+    this(\n+      {\n+        var fout: FileOutputStream = null\n+        try {\n+          fout = new FileOutputStream(file)\n+          val writer = new OutputStreamWriter(fout, csn)\n+          new BufferedWriter(writer)\n+        } catch {\n+          case e @ (_: RuntimeException | _: UnsupportedEncodingException) =>\n+            Formatter.closeOutputStream(fout)\n+            throw e\n+        }\n+      },\n+      l\n+    )\n+  def this(file: File, csn: String) =\n+    this(file, csn, Locale.getDefault())\n+  def this(file: File) =\n+    this(new FileOutputStream(file))\n+  def this(ps: PrintStream) =\n+    this(\n+      {\n+        if (null == ps)\n+          throw new NullPointerException()\n+        ps\n+      },\n+      Locale.getDefault()\n+    )\n+  def this(fileName: String, csn: String, l: Locale) =\n+    this(new File(fileName), csn, l)\n+  def this(fileName: String, csn: String) =\n+    this(new File(fileName), csn)\n+  def this(fileName: String) =\n+    this(new File(fileName))\n+\n+  private def checkClosed(): Unit =\n+    if (closed)\n+      throw new FormatterClosedException()\n+\n+  def locale(): Locale = {\n+    checkClosed()\n+    _locale\n+  }\n+\n+  def out(): Appendable = {\n+    checkClosed()\n+    _out\n+  }\n+\n+  override def toString: String = {\n+    checkClosed()\n+    _out.toString()\n+  }\n+\n+  def flush(): Unit = {\n+    checkClosed()\n+    _out match {\n+      case f: Flushable =>\n+        try {\n+          f.flush()\n+        } catch {\n+          case e: IOException => lastIOException = e\n+        }\n+      case _ =>\n+    }\n+  }\n \n-class Formatter {\n-  def this(appendable: Appendable, locale: Locale) = this()\n-  def this(appendable: Appendable) = this()\n-  def this(file: File, charsetName: String, locale: Locale) = this()\n-  def this(file: File, charsetName: String) = this()\n-  def this(file: File) = this()\n-  def this(locale: Locale) = this()\n-  def this(out: OutputStream, charsetName: String, locale: Locale) = this()\n-  def this(out: OutputStream, charsetName: String) = this()\n-  def this(out: OutputStream) = this()\n-  def this(out: PrintStream) = this()\n-  def this(fileName: String, charsetName: String, locale: Locale) = this()\n-  def this(fileName: String, charsetName: String) = this()\n-  def this(fileName: String) = this()\n-\n-  def close(): Unit = ???\n-  def flush(): Unit = ???\n-  def format(locale: Locale, format: String, args: Array[Object]): Formatter =\n-    ???\n-  def format(format: String, args: Array[Object]): Formatter = ???\n-  def ioException(): IOException                             = ???\n-  def locale(): Locale                                       = ???\n-  def out(): Appendable                                      = ???\n-  override def toString: String                              = ???\n+  def close(): Unit = {\n+    closed = true\n+    try {\n+      _out match {\n+        case c: Closeable =>\n+          c.close()\n+        case _ =>\n+      }\n+    } catch {\n+      case e: IOException => lastIOException = e\n+    }\n+  }\n+\n+  def ioException(): IOException = lastIOException\n+\n+  def format(format: String, args: Array[Object]): Formatter =\n+    this.format(_locale, format, args)\n+\n+  import Formatter._\n+\n+  def format(l: Locale, format: String, args: Array[Object]): Formatter = {\n+    checkClosed()\n+    val formatBuffer = CharBuffer.wrap(format)\n+    val parser       = new ParserStateMachine(formatBuffer)\n+    val transformer  = new Transformer(this, l)\n+\n+    var currentObjectIndex: Int     = 0\n+    var lastArgument: Object        = null\n+    var hasLastArgumentSet: Boolean = false\n+    while (formatBuffer.hasRemaining()) {\n+      parser.reset()\n+      val token          = parser.getNextFormatToken()\n+      var result: String = null\n+      var plainText      = token.getPlainText()\n+      if (token.getConversionType() == FormatToken.UNSET.asInstanceOf[Char]) {\n+        result = plainText\n+      } else {\n+        plainText = plainText.substring(0, plainText.indexOf('%'))\n+        var argument: Object = null\n+        if (token.requireArgument()) {\n+          val index =\n+            if (token.getArgIndex() == FormatToken.UNSET) {\n+              val idx = currentObjectIndex\n+              currentObjectIndex += 1\n+              idx\n+            } else\n+              token.getArgIndex()\n+          argument =\n+            getArgument(args, index, token, lastArgument, hasLastArgumentSet)\n+          lastArgument = argument\n+          hasLastArgumentSet = true\n+        }\n+        result = transformer.transform(token, argument)\n+        result = if (null == result) plainText else plainText + result\n+      }\n+      // if output is made by formattable callback\n+      if (null != result) {\n+        try {\n+          _out.append(result)\n+        } catch {\n+          case e: IOException => lastIOException = e\n+        }\n+      }\n+    }\n+    this\n+  }\n+\n+  private def getArgument(args: Array[Object],\n+                          index: Int,\n+                          token: FormatToken,\n+                          lastArgument: Object,\n+                          hasLastArgumentSet: Boolean): Object = {\n+    if (index == FormatToken.LAST_ARGUMENT_INDEX && !hasLastArgumentSet)\n+      throw new MissingFormatArgumentException(\"<\")\n+    else if (null == args)\n+      null\n+    else if (index >= args.length)\n+      throw new MissingFormatArgumentException(token.getPlainText())\n+    else if (index == FormatToken.LAST_ARGUMENT_INDEX)\n+      lastArgument\n+    else\n+      args(index)\n+  }\n }\n \n-object Formatter\n+object Formatter {\n+  private def closeOutputStream(os: OutputStream): Unit = {\n+    if (null == os)\n+      return\n+    try {\n+      os.close()\n+    } catch {\n+      case _: IOException =>\n+      // silently\n+    }\n+  }\n+\n+  private class FormatToken {\n+    import FormatToken._\n+\n+    private var formatStringStartIndex: Int = _\n+\n+    private var plainText: String = _\n+\n+    private var argIndex: Int = UNSET\n+\n+    private var flags: Int = 0\n+\n+    private var width: Int = UNSET\n+\n+    private var precision: Int = UNSET\n+\n+    private val strFlags = new StringBuilder(FLAGT_TYPE_COUNT)\n+\n+    private var dateSuffix: Char = _ // will be used in new feature.\n+\n+    private var conversionType: Char = UNSET.asInstanceOf[Char]\n+\n+    def isPrecisionSet(): Boolean = precision != UNSET\n+\n+    def isWidthSet(): Boolean = width != UNSET\n+\n+    def isFlagSet(flag: Int): Boolean = 0 != (flags & flag)\n+\n+    def getArgIndex(): Int = argIndex\n+\n+    def setArgIndex(index: Int): Unit = argIndex = index\n+\n+    def getPlainText(): String = plainText\n+\n+    def setPlainText(plainText: String): Unit = this.plainText = plainText\n+\n+    def getWidth(): Int = width\n+\n+    def setWidth(width: Int): Unit = this.width = width\n+\n+    def getPrecision(): Int = precision\n+\n+    def setPrecision(precise: Int): Unit = this.precision = precise\n+\n+    def getStrFlags(): String = strFlags.toString()\n+\n+    def getFlags(): Int = flags\n+\n+    def setFlags(flags: Int): Unit = this.flags = flags\n+\n+    def setFlag(c: Char): Boolean = {\n+      var newFlag: Int = 0\n+      c match {\n+        case '-' => newFlag = FLAG_MINUS\n+        case '#' => newFlag = FLAG_SHARP\n+        case '+' => newFlag = FLAG_ADD\n+        case ' ' => newFlag = FLAG_SPACE\n+        case '0' => newFlag = FLAG_ZERO\n+        case ',' => newFlag = FLAG_COMMA\n+        case '(' => newFlag = FLAG_PARENTHESIS\n+        case _   => return false\n+      }\n+      if (0 != (flags & newFlag))\n+        throw new DuplicateFormatFlagsException(String.valueOf(c))\n+      flags = (flags | newFlag)\n+      strFlags.append(c)\n+      true\n+    }\n+\n+    def getFormatStringStartIndex(): Int = formatStringStartIndex\n+\n+    def setFormatStringStartIndex(index: Int): Unit =\n+      formatStringStartIndex = index\n+\n+    def getConversionType(): Char = conversionType\n+\n+    def setConversionType(c: Char): Unit = conversionType = c\n+\n+    def getDateSuffix(): Char = dateSuffix\n+\n+    def setDateSuffix(c: Char): Unit = dateSuffix = c\n+\n+    def requireArgument(): Boolean =\n+      conversionType != '%' && conversionType != 'n'\n+  }\n+\n+  private object FormatToken {\n+    val LAST_ARGUMENT_INDEX = -2\n+\n+    val UNSET: Int = -1\n+\n+    val FLAGS_UNSET: Int = 0\n+\n+    val DEFAULT_PRECISION: Int = 6\n+\n+    val FLAG_MINUS: Int = 1\n+\n+    val FLAG_SHARP: Int = 1 << 1\n+\n+    val FLAG_ADD: Int = 1 << 2\n+\n+    val FLAG_SPACE: Int = 1 << 3\n+\n+    val FLAG_ZERO: Int = 1 << 4\n+\n+    val FLAG_COMMA: Int = 1 << 5\n+\n+    val FLAG_PARENTHESIS: Int = 1 << 6\n+\n+    private val FLAGT_TYPE_COUNT: Int = 6\n+  }\n+\n+  private class Transformer(formatter: Formatter, locale_ : Locale) {\n+    import Transformer._\n+\n+    private var formatToken: FormatToken = _\n+\n+    private var arg: Object = _\n+\n+    private val locale = if (null == locale_) Locale.US else locale_\n+\n+    private var numberFormat: NumberFormat = _\n+\n+    private var decimalFormatSymbols: DecimalFormatSymbols = _\n+\n+    private var dateTimeUtil: DateTimeUtil = _\n+\n+    private def getNumberFormat(): NumberFormat = {\n+      if (null == numberFormat)\n+        numberFormat = NumberFormat.getInstance(locale)\n+      numberFormat\n+    }\n+\n+    private def getDecimalFormatSymbols(): DecimalFormatSymbols = {\n+      if (null == decimalFormatSymbols)\n+        decimalFormatSymbols = new DecimalFormatSymbols(locale)\n+      decimalFormatSymbols\n+    }\n+\n+    def transform(token: FormatToken, argument: Object): String = {\n+      this.formatToken = token\n+      this.arg = argument\n+\n+      var result =\n+        token.getConversionType() match {\n+          case 'B' | 'b' => transformFromBoolean()\n+          case 'H' | 'h' => transformFromHashCode()\n+          case 'S' | 's' => transformFromString()\n+          case 'C' | 'c' => transformFromCharacter()\n+          case 'd' | 'o' | 'x' | 'X' =>\n+            if (null == arg || arg.isInstanceOf[BigInteger])\n+              transformFromBigInteger()\n+            else\n+              transformFromInteger()\n+          case 'e' | 'E' | 'g' | 'G' | 'f' | 'a' | 'A' =>\n+            transformFromFloat()\n+          case '%' => transformFromPercent()\n+          case 'n' => transformFromLineSeparator()\n+          case 't' => transformFromDateTime()\n+          case unknown =>\n+            throw new UnknownFormatConversionException(String.valueOf(unknown))\n+        }\n+\n+      if (Character.isUpperCase(token.getConversionType())) {\n+        if (null != result) {\n+          // Porting note: Harmony does this but this.locale should be respected\n+          result = result.toUpperCase(Locale.US)\n+        }\n+      }\n+      result\n+    }\n+\n+    private def transformFromBoolean(): String = {\n+      val result     = new StringBuilder()\n+      val startIndex = 0\n+      val flags      = formatToken.getFlags()\n+\n+      if (formatToken.isFlagSet(FormatToken.FLAG_MINUS) && !formatToken\n+            .isWidthSet())\n+        throw new MissingFormatWidthException(\n+          \"-\" + formatToken.getConversionType())\n+\n+      if (FormatToken.FLAGS_UNSET != flags && FormatToken.FLAG_MINUS != flags)\n+        throw new FormatFlagsConversionMismatchException(\n+          formatToken.getStrFlags(),\n+          formatToken.getConversionType())\n+\n+      if (null == arg)\n+        result.append(\"false\")\n+      else if (arg.isInstanceOf[Boolean])\n+        result.append(arg)\n+      else\n+        result.append(\"true\")\n+      padding(result, startIndex)\n+    }\n+\n+    private def transformFromHashCode(): String = {\n+      val result = new StringBuilder()\n+\n+      val startIndex = 0\n+      val flags      = formatToken.getFlags()\n+\n+      if (formatToken.isFlagSet(FormatToken.FLAG_MINUS) && !formatToken\n+            .isWidthSet())\n+        throw new MissingFormatWidthException(\n+          \"-\" + formatToken.getConversionType())\n+\n+      if (FormatToken.FLAGS_UNSET != flags && FormatToken.FLAG_MINUS != flags)\n+        throw new FormatFlagsConversionMismatchException(\n+          formatToken.getStrFlags(),\n+          formatToken.getConversionType())\n+\n+      if (null == arg)\n+        result.append(\"null\")\n+      else\n+        result.append(Integer.toHexString(arg.hashCode()))\n+      padding(result, startIndex)\n+    }\n+\n+    private def transformFromString(): String = {\n+      val result     = new StringBuilder()\n+      val startIndex = 0\n+      val flags      = formatToken.getFlags()\n+\n+      if (formatToken.isFlagSet(FormatToken.FLAG_MINUS) && !formatToken\n+            .isWidthSet())\n+        throw new MissingFormatWidthException(\n+          \"-\" + formatToken.getConversionType())\n+\n+      if (arg.isInstanceOf[Formattable]) {\n+        var flag: Int = 0\n+        if (FormatToken.FLAGS_UNSET != (flags & ~FormatToken.FLAG_MINUS & ~FormatToken.FLAG_SHARP))\n+          throw new IllegalFormatFlagsException(formatToken.getStrFlags())\n+\n+        if (formatToken.isFlagSet(FormatToken.FLAG_MINUS))\n+          flag |= FormattableFlags.LEFT_JUSTIFY\n+        if (formatToken.isFlagSet(FormatToken.FLAG_SHARP))\n+          flag |= FormattableFlags.ALTERNATE\n+        if (Character.isUpperCase(formatToken.getConversionType()))\n+          flag |= FormattableFlags.UPPERCASE\n+        arg\n+          .asInstanceOf[Formattable]\n+          .formatTo(formatter,\n+                    flag,\n+                    formatToken.getWidth(),\n+                    formatToken.getPrecision())\n+        // all actions have been taken out in the\n+        // Formattable.formatTo, thus there is nothing to do, just\n+        // returns null, which tells the Parser to add nothing to the\n+        // output.\n+        return null\n+      }\n+      if (FormatToken.FLAGS_UNSET != flags && FormatToken.FLAG_MINUS != flags)\n+        throw new FormatFlagsConversionMismatchException(\n+          formatToken.getStrFlags(),\n+          formatToken.getConversionType())\n+\n+      result.append(arg)\n+      padding(result, startIndex)\n+    }\n+\n+    private def transformFromCharacter(): String = {\n+      val result = new StringBuilder()\n+\n+      val startIndex = 0\n+      val flags      = formatToken.getFlags()\n+\n+      if (formatToken.isFlagSet(FormatToken.FLAG_MINUS) && !formatToken\n+            .isWidthSet())\n+        throw new MissingFormatWidthException(\n+          \"-\" + formatToken.getConversionType())\n+\n+      if (FormatToken.FLAGS_UNSET != flags && FormatToken.FLAG_MINUS != flags)\n+        throw new FormatFlagsConversionMismatchException(\n+          formatToken.getStrFlags(),\n+          formatToken.getConversionType())\n+\n+      if (formatToken.isPrecisionSet())\n+        throw new IllegalFormatPrecisionException(formatToken.getPrecision())\n+\n+      arg.asInstanceOf[Any] match {\n+        case null         => result.append(\"null\")\n+        case c: Character => result.append(c)\n+        case b: Byte =>\n+          if (!Character.isValidCodePoint(b))\n+            throw new IllegalFormatCodePointException(b)\n+          result.append(b.asInstanceOf[Char])\n+        case s: Short =>\n+          if (!Character.isValidCodePoint(s))\n+            throw new IllegalFormatCodePointException(s)\n+          result.append(s.asInstanceOf[Char])\n+        case codePoint: Int =>\n+          if (!Character.isValidCodePoint(codePoint))\n+            throw new IllegalFormatCodePointException(codePoint)\n+          result.append(String.valueOf(Character.toChars(codePoint)))\n+        case _ =>\n+          throw new IllegalFormatConversionException(\n+            formatToken.getConversionType(),\n+            arg.getClass())\n+      }\n+      padding(result, startIndex)\n+    }\n+\n+    private def transformFromPercent(): String = {\n+      val result = new StringBuilder(\"%\")\n+\n+      val startIndex = 0\n+      val flags      = formatToken.getFlags()\n+\n+      if (formatToken.isFlagSet(FormatToken.FLAG_MINUS) && !formatToken\n+            .isWidthSet())\n+        throw new MissingFormatWidthException(\n+          \"-\" + formatToken.getConversionType())\n+\n+      if (FormatToken.FLAGS_UNSET != flags && FormatToken.FLAG_MINUS != flags)\n+        throw new FormatFlagsConversionMismatchException(\n+          formatToken.getStrFlags(),\n+          formatToken.getConversionType())\n+      if (formatToken.isPrecisionSet())\n+        throw new IllegalFormatPrecisionException(formatToken.getPrecision())\n+      padding(result, startIndex)\n+    }\n+\n+    private def transformFromLineSeparator(): String = {\n+      if (formatToken.isPrecisionSet())\n+        throw new IllegalFormatPrecisionException(formatToken.getPrecision())\n+\n+      if (formatToken.isWidthSet())\n+        throw new IllegalFormatWidthException(formatToken.getWidth())\n+\n+      val flags = formatToken.getFlags()\n+      if (FormatToken.FLAGS_UNSET != flags)\n+        throw new IllegalFormatFlagsException(formatToken.getStrFlags())\n+\n+      if (null == lineSeparator) {\n+        lineSeparator =\n+          AccessController.doPrivileged(new PrivilegedAction[String]() {\n+            def run(): String = System.getProperty(\"line.separator\")\n+          })"
  }
]
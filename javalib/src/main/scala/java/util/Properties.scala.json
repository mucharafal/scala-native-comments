[
  {
    "id" : "706f1188-eb56-4fd5-8075-9e354d034c81",
    "prId" : 1100,
    "comments" : [
      {
        "id" : "15800711-c9b4-4e6e-8f92-6232d3df4bec",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "We don't leave TODOs in the code. They need to be addressed before this PR is merged.",
        "createdAt" : "2018-07-02T14:48:17Z",
        "updatedAt" : "2018-07-03T17:02:23Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "124b2998-d6a6-49c6-9339-a375b28b02cb",
        "parentId" : "15800711-c9b4-4e6e-8f92-6232d3df4bec",
        "author" : {
          "login" : "techaddict",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1378755?u=3d2207e449179a8dff75a44b1cb16fb2f7064b28&v=4"
        },
        "body" : "@densh will update this today",
        "createdAt" : "2018-07-03T16:53:04Z",
        "updatedAt" : "2018-07-03T17:02:23Z",
        "lastEditedBy" : {
          "login" : "techaddict",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1378755?u=3d2207e449179a8dff75a44b1cb16fb2f7064b28&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4791ff7f-1e3d-46d7-b0da-499e60162bea",
        "parentId" : "15800711-c9b4-4e6e-8f92-6232d3df4bec",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "@techaddict Did you mean to close or abandon this PR? When porting the library mentioned below I used `breakable` which is ugly but is a good bridge when rewriting the code may be hard. Example below for `continue`. Put the `breakable` outside the loop for a true `break`.\r\n```\r\nimport scala.util.control.Breaks._\r\nwhile(cond) {\r\n  breakable {\r\n    // some code\r\n    break // continue emulated\r\n    // some more code\r\n  }\r\n}\r\n```\r\n@densh This is actually needed for https://github.com/ekrich/sconfig and a potential `0.3.9` release.\r\n```\r\n[error] cannot link: @java.util.Properties::load_java.io.Reader_unit\r\n```",
        "createdAt" : "2018-12-20T17:26:11Z",
        "updatedAt" : "2018-12-20T17:26:12Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "31d6d8f38ea9283aeba1a5237cbb071d56263af2",
    "line" : 286,
    "diffHunk" : "@@ -51,11 +71,319 @@ class Properties(protected val defaults: Properties)\n     set\n   }\n \n+  def load(reader: Reader): Unit = {\n+    if (reader == null) {\n+      throw new NullPointerException()\n+    }\n+    loadImpl(reader)\n+  }\n+\n+  def store(out: OutputStream, comments: String): Unit = {\n+    val buffer = new StringBuilder(200)\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\") //$NON-NLS-1$\n+    if (comments != null)\n+      writeComments(writer, comments)\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, true)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, true)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (comments != null)\n+      writeComments(writer, comments)\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b = in.read\n+    while (b != 0xffffffff) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { //ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { //EBCDIC newline\n+        return true\n+      }\n+      b = in.read\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()\n+      if (intVal == -1) {\n+        if (mode == UNICODE && count <= 4) {\n+          throw new IllegalArgumentException(\n+            \"Invalid Unicode sequence: expected format\")\n+        }\n+        if (keyLength == -1 && offset > 0)\n+          keyLength = offset\n+        if (keyLength >= 0) {\n+          val key   = new String(buf, 0, keyLength)\n+          val value = new String(buf, keyLength, offset - keyLength)\n+          put(key, if (mode == SLASH) value + '\\u0000' else value)\n+        }\n+      } else {\n+        nextChar = intVal.toChar\n+        if (offset == buf.length) {\n+          val newBuf = new Array[Char](buf.length << 1)\n+          System.arraycopy(buf, 0, newBuf, 0, offset)\n+          buf = newBuf\n+        }\n+        val _bool = if (mode == SLASH) {\n+          mode = NONE\n+          (nextChar: @switch) match {\n+            case '\\r' =>\n+              mode = CONTINUE // Look for a following \\n\n+              isFirstChar\n+            case '\\u0085' | '\\n' =>\n+              mode = IGNORE // Ignore whitespace on the next line\n+              isFirstChar\n+            case c @ ('b' | 'f' | 'n' | 'r' | 't') =>\n+              nextChar = nextCharMap(c)\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+            case 'u' =>\n+              mode = UNICODE\n+              unicode = 0\n+              count = 0\n+              isFirstChar\n+            case _ =>\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+          }\n+        } else {\n+          def fn(_nextChar: Char): Boolean = (_nextChar: @switch) match {\n+            case '#' | '!' if isFirstChar =>\n+              @tailrec def ignoreCharsTillEOL(tempVal: Char): Unit = {\n+                if (tempVal != 0xFFFF) { // -1.toChar\n+                  nextChar = tempVal.toChar\n+\n+                  // not\n+                  // required\n+                  if (nextChar != '\\r' && nextChar != '\\n' && nextChar != '\\u0085') {\n+                    ignoreCharsTillEOL(br.read().toChar)\n+                  }\n+                }\n+              }\n+\n+              ignoreCharsTillEOL(br.read().toChar)\n+              isFirstChar\n+            case c @ ('\\n' | '\\u0085' | '\\r') =>\n+              if (c == '\\n' && mode == CONTINUE) { // Part of a \\r\\n sequence\n+                mode = IGNORE\n+                isFirstChar\n+              } else {\n+                mode = NONE\n+                if (offset > 0 || (offset == 0 && keyLength == 0)) {\n+                  if (keyLength == -1) keyLength = offset\n+                  val key   = new String(buf, 0, keyLength)\n+                  val value = new String(buf, keyLength, offset - keyLength)\n+                  put(key, value)\n+                }\n+                keyLength = -1\n+                offset = 0\n+                true\n+              }\n+            case '\\\\' =>\n+              if (mode == KEY_DONE) keyLength = offset\n+              mode = SLASH\n+              isFirstChar\n+            case ':' | '=' if keyLength == -1 =>\n+              // if parsing the key\n+              mode = NONE\n+              keyLength = offset\n+              isFirstChar\n+            case _ =>\n+              if (nextChar < 256 && Character.isWhitespace(nextChar)) {\n+                if (mode == CONTINUE) mode = IGNORE\n+                // if key length == 0 or value length == 0\n+                if (offset == 0 || offset == keyLength || mode == IGNORE)\n+                  isFirstChar\n+                else if (keyLength == -1) {\n+                  mode = KEY_DONE\n+                  isFirstChar\n+                } else {\n+                  if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                  else if (mode == KEY_DONE) {\n+                    keyLength = offset\n+                    mode = NONE\n+                  }\n+                  buf(offset) = nextChar\n+                  offset += 1\n+                  false\n+                }\n+              } else {\n+                if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                else if (mode == KEY_DONE) {\n+                  keyLength = offset\n+                  mode = NONE\n+                }\n+                buf(offset) = nextChar\n+                offset += 1\n+                false\n+              }\n+          }\n+          if (mode == UNICODE) {\n+            val digit = Character.digit(nextChar, 16)\n+            if (digit >= 0) {\n+              unicode = (unicode << 4) + digit\n+              count += 1\n+            } else if (count <= 4) {\n+              throw new IllegalArgumentException(\n+                \"Invalid Unicode sequence: illegal character\")\n+            }\n+            if (digit >= 0 && count < 4) {\n+              isFirstChar\n+            } else {\n+              mode = NONE\n+              buf(offset) = unicode.toChar\n+              offset += 1\n+              if (nextChar != '\\n' && nextChar != '\\u0085')\n+                isFirstChar\n+              else\n+                fn(nextChar)\n+            }\n+          } else {\n+            fn(nextChar)\n+          }\n+        }\n+        processNext(_bool)\n+      }\n+    }\n+\n+    processNext(true)\n+\n+  }\n+\n+  private def writeComments(writer: Writer, comments: String): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256)\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          val indexPlusOne = index + 1\n+          if (chars(index) == '\\r' && indexPlusOne < chars.length && chars(\n+                indexPlusOne) == '\\n') { // \"\\r\\n\"\n+//          continue //todo: continue is not supported"
  },
  {
    "id" : "87832862-a817-475f-bddd-aa0c91a69c74",
    "prId" : 1478,
    "comments" : [
      {
        "id" : "ea2e50ad-2806-4835-b134-fe9c000e225c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Please add `@stub` annotation.",
        "createdAt" : "2019-03-20T15:46:19Z",
        "updatedAt" : "2019-03-20T15:59:16Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "819037cc-6e6f-42a3-a18c-362ffbda1cd2",
        "parentId" : "ea2e50ad-2806-4835-b134-fe9c000e225c",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "In general, are `@stub` suppose to be everywhere there is an empty implementation?",
        "createdAt" : "2019-03-20T15:56:24Z",
        "updatedAt" : "2019-03-20T15:59:16Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "099b6017-de9c-49b3-8469-59ab59832ff4",
        "parentId" : "ea2e50ad-2806-4835-b134-fe9c000e225c",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Responded on gitter: :point_up: [March 21, 2019 12:20 PM](https://gitter.im/scala-native/scala-native?at=5c9373675547f774483ec225)",
        "createdAt" : "2019-03-21T11:21:57Z",
        "updatedAt" : "2019-03-21T11:21:57Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9a96471f9dc62f9e75ccdd2bc86afaac8150f0a2",
    "line" : 16,
    "diffHunk" : "@@ -14,6 +14,8 @@ class Properties(protected val defaults: Properties)\n \n   def load(inStream: java.io.InputStream): Unit = ???\n \n+  def load(reader: java.io.Reader): Unit = ???"
  },
  {
    "id" : "e0bcc247-6c64-437d-a7ec-108d90de0b4a",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "f5707bcf-cdeb-48a4-a96c-388bb4a50e15",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "With more than 3 or 4 imports, consider just using a wildcard imports.",
        "createdAt" : "2020-05-14T10:00:16Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3fb51e7d-8bcd-45b7-b913-22c7f72a74f6",
        "parentId" : "f5707bcf-cdeb-48a4-a96c-388bb4a50e15",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Thanks for the review, I know this code is a mess as it is pretty much a straight translation from Harmony and picked up from others. I took care of this one.",
        "createdAt" : "2020-05-15T15:26:08Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -1,10 +1,26 @@\n+/**\n+ * Ported from Harmony\n+ */\n package java.util\n \n-import java.io.{PrintStream, PrintWriter}\n+import java.io.{"
  },
  {
    "id" : "b9fb792e-20d3-410b-9c6a-01d8820ad7a3",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "9d487a5d-edc1-4074-85ec-5e8d48309ba9",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This seems unused?",
        "createdAt" : "2020-05-14T10:00:46Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "123e4c1c-33ee-4cee-9b3b-ef2871754502",
        "parentId" : "9d487a5d-edc1-4074-85ec-5e8d48309ba9",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, it was thanks.",
        "createdAt" : "2020-05-15T15:27:29Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -1,10 +1,26 @@\n+/**\n+ * Ported from Harmony\n+ */\n package java.util\n \n-import java.io.{PrintStream, PrintWriter}\n+import java.io.{\n+  BufferedInputStream,\n+  BufferedReader,\n+  InputStream,\n+  InputStreamReader,\n+  OutputStream,\n+  OutputStreamWriter,\n+  PrintStream,\n+  PrintWriter,\n+  Reader,\n+  Writer\n+}\n import java.{util => ju}\n \n+import scala.annotation.{switch, tailrec}\n+import scala.collection.immutable.{Map => SMap}\n import scala.collection.JavaConverters._\n-import scala.scalanative.annotation.stub\n+import scala.util.control.Breaks._"
  },
  {
    "id" : "34e57eee-347c-47ad-8f39-fc7ce13dfcb3",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "db513e53-a249-42de-8895-9f79dae2daa4",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This test seems redundant. An NPE will be thrown later just by trying to access the stream.",
        "createdAt" : "2020-05-14T10:07:37Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "838ce765-dab4-4fca-9a94-dcdb5d1b7110",
        "parentId" : "db513e53-a249-42de-8895-9f79dae2daa4",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "In general, we shouldn't go out of our way to throw NPEs. Most of the time they'll get thrown by the runtime.",
        "createdAt" : "2020-05-14T10:08:28Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "665a50a8-0506-4d4a-a7f2-1ab7bd9bba2e",
        "parentId" : "db513e53-a249-42de-8895-9f79dae2daa4",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Especially with no message exception. Done.",
        "createdAt" : "2020-05-15T15:28:50Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -14,11 +30,29 @@ class Properties(protected val defaults: Properties)\n   def setProperty(key: String, value: String): AnyRef =\n     put(key, value)\n \n-  @stub\n-  def load(inStream: java.io.InputStream): Unit = ???\n+  def load(inStream: InputStream): Unit = {\n+    if (inStream == null) {\n+      throw new NullPointerException()"
  },
  {
    "id" : "acbcea8a-6a82-4c13-9581-3226a894091b",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "97369735-b103-4598-9ced-23694b49773b",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Avoid local vars with a leading underscore. That's not idiomatic Scala. Consider\r\n```suggestion\r\n    val isEbcdic = this.isEbcdic(stream)\r\n```\r\nunless you have a better idea.",
        "createdAt" : "2020-05-14T10:09:51Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "32901709-627c-4f6a-958e-92cec0441ef1",
        "parentId" : "97369735-b103-4598-9ced-23694b49773b",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "No this is fine. I think EBCDIC is here for Java on mainframe since this came from Harmony.",
        "createdAt" : "2020-05-15T15:35:07Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e9d6c5b3-8edf-4cd1-8822-56216f74f6ad",
        "parentId" : "97369735-b103-4598-9ced-23694b49773b",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I just removed it.",
        "createdAt" : "2020-05-15T16:34:59Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -14,11 +30,29 @@ class Properties(protected val defaults: Properties)\n   def setProperty(key: String, value: String): AnyRef =\n     put(key, value)\n \n-  @stub\n-  def load(inStream: java.io.InputStream): Unit = ???\n+  def load(inStream: InputStream): Unit = {\n+    if (inStream == null) {\n+      throw new NullPointerException()\n+    }\n+    val stream = new BufferedInputStream(inStream)\n+    stream.mark(8192) // default buffer size\n \n-  @stub\n-  def load(reader: java.io.Reader): Unit = ???\n+    val _isEbcdic = isEbcdic(stream)"
  },
  {
    "id" : "d2127604-4d16-4c6d-bc74-c2d66b220229",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "135e7a1a-1b03-462f-b171-f3fa431924f8",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Same as above: this is unnecessary.",
        "createdAt" : "2020-05-14T10:10:24Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3aea1bd0-c167-4917-957d-900eb2f12c9b",
        "parentId" : "135e7a1a-1b03-462f-b171-f3fa431924f8",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, these are now removed.",
        "createdAt" : "2020-05-15T15:44:48Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -14,11 +30,29 @@ class Properties(protected val defaults: Properties)\n   def setProperty(key: String, value: String): AnyRef =\n     put(key, value)\n \n-  @stub\n-  def load(inStream: java.io.InputStream): Unit = ???\n+  def load(inStream: InputStream): Unit = {\n+    if (inStream == null) {\n+      throw new NullPointerException()\n+    }\n+    val stream = new BufferedInputStream(inStream)\n+    stream.mark(8192) // default buffer size\n \n-  @stub\n-  def load(reader: java.io.Reader): Unit = ???\n+    val _isEbcdic = isEbcdic(stream)\n+    stream.reset()\n+\n+    if (!_isEbcdic) {\n+      loadImpl(new InputStreamReader(stream, \"ISO8859-1\"))\n+    } else {\n+      loadImpl(new InputStreamReader(stream))\n+    }\n+  }\n+\n+  def load(reader: Reader): Unit = {\n+    if (reader == null) {\n+      throw new NullPointerException()\n+    }"
  },
  {
    "id" : "fdb4c145-03f0-49b2-9954-9259685f35b8",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "f04bfd6c-f716-4474-ae8c-b3ea2bf7ef30",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I don't understand where this comes from. I see no evidence whatsoever that `Properties` is supposed to handle something specific for EBCDIC (it's not mentioned in the [JavaDoc of `Properties`](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Properties.html)). Besides, there's nothing in `new InputStreamReader(stream)` that would handle EBCDIC anyway.\r\n\r\nThe JavaDoc of `Properties.load(InputStream)` says it assumes ISO8859-1. You should just always use that, and not mess with EBCDIC.",
        "createdAt" : "2020-05-14T10:32:44Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cad66f66-3814-4920-b516-dbc68f56e3c1",
        "parentId" : "f04bfd6c-f716-4474-ae8c-b3ea2bf7ef30",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, I think we should just remove it.",
        "createdAt" : "2020-05-15T15:46:10Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -14,11 +30,29 @@ class Properties(protected val defaults: Properties)\n   def setProperty(key: String, value: String): AnyRef =\n     put(key, value)\n \n-  @stub\n-  def load(inStream: java.io.InputStream): Unit = ???\n+  def load(inStream: InputStream): Unit = {\n+    if (inStream == null) {\n+      throw new NullPointerException()\n+    }\n+    val stream = new BufferedInputStream(inStream)\n+    stream.mark(8192) // default buffer size\n \n-  @stub\n-  def load(reader: java.io.Reader): Unit = ???\n+    val _isEbcdic = isEbcdic(stream)\n+    stream.reset()\n+\n+    if (!_isEbcdic) {\n+      loadImpl(new InputStreamReader(stream, \"ISO8859-1\"))\n+    } else {\n+      loadImpl(new InputStreamReader(stream))\n+    }"
  },
  {
    "id" : "39f45194-e615-4e2e-9e06-82f66d3052f2",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "769f2dfb-fd6d-4e14-877a-9f9ae01e52a0",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This looses the charset encoder of the original `out`. That's not an appropriate change to make. You should keep the existing code here.",
        "createdAt" : "2020-05-14T11:20:25Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dc743f0a-24ac-43c3-a58a-eca7f1b53bff",
        "parentId" : "769f2dfb-fd6d-4e14-877a-9f9ae01e52a0",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, I reverted and just factored out the listing string.",
        "createdAt" : "2020-05-15T16:07:29Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))"
  },
  {
    "id" : "4cc66f12-bdc3-4be8-97ee-9a0694f719e8",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "454d5ff3-b1b7-4fac-9495-71b17af5092e",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "You're in `store()` but the comment points to `load()`.",
        "createdAt" : "2020-05-14T11:21:44Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2b002db2-6af5-489c-a4f2-235914bb12d1",
        "parentId" : "454d5ff3-b1b7-4fac-9495-71b17af5092e",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Removed, thanks.",
        "createdAt" : "2020-05-15T16:07:44Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-"
  },
  {
    "id" : "35398e01-13bc-4101-a0b6-53e610157bc5",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "cb6682fd-1549-44a6-a28a-2414af7cfecd",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Why write things to a `buffer` before sending to the `writer`? You could just directly write to `writer`.",
        "createdAt" : "2020-05-14T11:28:01Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d4b070d9-c234-49f0-8caf-e9043409bc9a",
        "parentId" : "cb6682fd-1549-44a6-a28a-2414af7cfecd",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This was done to reuse the buffer but that is ugly and a premature optimization. I moved the `StringBuilder` inside the `dumpString` which is also renamed to `encodeString`. ",
        "createdAt" : "2020-05-15T16:09:43Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)"
  },
  {
    "id" : "466c95ba-df4b-48a0-aa58-965172f42bcf",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "d43a88b4-b1cc-453a-ae21-ec2edfa940ff",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Directly delegating to `store(Writer)` will not correctly use `\\uxxxx` where appropriate, i.e., a described by https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#store-java.io.OutputStream-java.lang.String-\r\n\r\nIf you want to factor things out, you'll need a `storeImpl` with an explicit parameter for whether to apply the `\\u` treatment or not. But I sense that the differing code will outweigh the common code, and so it would probably be better *not* to factor out at all.",
        "createdAt" : "2020-05-14T11:32:18Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1ebe1994-a437-4738-904e-97c4ed6a241b",
        "parentId" : "d43a88b4-b1cc-453a-ae21-ec2edfa940ff",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I think the second commit addresses this so I will push it for review.",
        "createdAt" : "2020-05-15T17:30:30Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)"
  },
  {
    "id" : "42898216-90a5-433f-8b66-9e8613b83eec",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "89855bec-584b-4654-b95c-929a564cf190",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "These three lines could be factored out as `writeDateComment`, if you don't factor out the implementations of `store(OutputStream)` and `store(Writer)`.",
        "createdAt" : "2020-05-14T11:32:59Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f144cf5f-3964-43a4-a5c2-1a3150ba178a",
        "parentId" : "89855bec-584b-4654-b95c-929a564cf190",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I did the factoring.",
        "createdAt" : "2020-06-23T18:18:15Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : 68,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)"
  },
  {
    "id" : "f8bf71a4-3e39-405a-a51b-b370f9096b17",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "80d4089d-0538-47e1-9e53-68ec571bbb8d",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This seems unnecessary. It would fall into the the last two cases (when `ch < ' '`).",
        "createdAt" : "2020-05-14T11:36:57Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "08651117-e4cc-4593-8808-b1317aec4bbe",
        "parentId" : "80d4089d-0538-47e1-9e53-68ec571bbb8d",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "You are correct, thank-you.",
        "createdAt" : "2020-05-15T19:24:54Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()\n+      if (intVal == -1) {\n+        if (mode == UNICODE && count <= 4) {\n+          throw new IllegalArgumentException(\n+            \"Invalid Unicode sequence: expected format\")\n+        }\n+        if (keyLength == -1 && offset > 0)\n+          keyLength = offset\n+        if (keyLength >= 0) {\n+          val key   = new String(buf, 0, keyLength)\n+          val value = new String(buf, keyLength, offset - keyLength)\n+          put(key, if (mode == SLASH) value + '\\u0000' else value)\n+        }\n+      } else {\n+        nextChar = intVal.toChar\n+        if (offset == buf.length) {\n+          val newBuf = new Array[Char](buf.length << 1)\n+          System.arraycopy(buf, 0, newBuf, 0, offset)\n+          buf = newBuf\n+        }\n+        val _bool = if (mode == SLASH) {\n+          mode = NONE\n+          (nextChar: @switch) match {\n+            case '\\r' =>\n+              mode = CONTINUE // Look for a following \\n\n+              isFirstChar\n+            case '\\u0085' | '\\n' =>\n+              mode = IGNORE // Ignore whitespace on the next line\n+              isFirstChar\n+            case c @ ('b' | 'f' | 'n' | 'r' | 't') =>\n+              nextChar = nextCharMap(c)\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+            case 'u' =>\n+              mode = UNICODE\n+              unicode = 0\n+              count = 0\n+              isFirstChar\n+            case _ =>\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+          }\n+        } else {\n+          def fn(_nextChar: Char): Boolean = (_nextChar: @switch) match {\n+            case '#' | '!' if isFirstChar =>\n+              @tailrec def ignoreCharsTillEOL(tempVal: Char): Unit = {\n+                if (tempVal != 0xFFFF) { // -1.toChar\n+                  nextChar = tempVal.toChar\n+                  // not required\n+                  if (nextChar != '\\r' && nextChar != '\\n' && nextChar != '\\u0085') {\n+                    ignoreCharsTillEOL(br.read().toChar)\n+                  }\n+                }\n+              }\n+\n+              ignoreCharsTillEOL(br.read().toChar)\n+              isFirstChar\n+            case c @ ('\\n' | '\\u0085' | '\\r') =>\n+              if (c == '\\n' && mode == CONTINUE) { // Part of a \\r\\n sequence\n+                mode = IGNORE\n+                isFirstChar\n+              } else {\n+                mode = NONE\n+                if (offset > 0 || (offset == 0 && keyLength == 0)) {\n+                  if (keyLength == -1) keyLength = offset\n+                  val key   = new String(buf, 0, keyLength)\n+                  val value = new String(buf, keyLength, offset - keyLength)\n+                  put(key, value)\n+                }\n+                keyLength = -1\n+                offset = 0\n+                true\n+              }\n+            case '\\\\' =>\n+              if (mode == KEY_DONE) keyLength = offset\n+              mode = SLASH\n+              isFirstChar\n+            case ':' | '=' if keyLength == -1 =>\n+              // if parsing the key\n+              mode = NONE\n+              keyLength = offset\n+              isFirstChar\n+            case _ =>\n+              if (nextChar < 256 && Character.isWhitespace(nextChar)) {\n+                if (mode == CONTINUE) mode = IGNORE\n+                // if key length == 0 or value length == 0\n+                if (offset == 0 || offset == keyLength || mode == IGNORE)\n+                  isFirstChar\n+                else if (keyLength == -1) {\n+                  mode = KEY_DONE\n+                  isFirstChar\n+                } else {\n+                  if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                  else if (mode == KEY_DONE) {\n+                    keyLength = offset\n+                    mode = NONE\n+                  }\n+                  buf(offset) = nextChar\n+                  offset += 1\n+                  false\n+                }\n+              } else {\n+                if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                else if (mode == KEY_DONE) {\n+                  keyLength = offset\n+                  mode = NONE\n+                }\n+                buf(offset) = nextChar\n+                offset += 1\n+                false\n+              }\n+          }\n+          if (mode == UNICODE) {\n+            val digit = Character.digit(nextChar, 16)\n+            if (digit >= 0) {\n+              unicode = (unicode << 4) + digit\n+              count += 1\n+            } else if (count <= 4) {\n+              throw new IllegalArgumentException(\n+                \"Invalid Unicode sequence: illegal character\")\n+            }\n+            if (digit >= 0 && count < 4) {\n+              isFirstChar\n+            } else {\n+              mode = NONE\n+              buf(offset) = unicode.toChar\n+              offset += 1\n+              if (nextChar != '\\n' && nextChar != '\\u0085')\n+                isFirstChar\n+              else\n+                fn(nextChar)\n+            }\n+          } else {\n+            fn(nextChar)\n+          }\n+        }\n+        processNext(_bool)\n+      }\n+    }\n+\n+    processNext(true)\n+\n+  }\n+\n+  private def writeComments(writer: Writer, comments: String): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') { // \"\\r\\n\"\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) { // return char with either '#' or '!' afterward\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        writer.write(unicodeToHexaDecimal(chars(index)))\n+      }\n+      index += 1\n+    }\n+    writer.write(System.lineSeparator)\n+  }\n+\n+  private def dumpString(buffer: StringBuilder,\n+                         string: String,\n+                         isKey: Boolean,\n+                         toHexaDecimal: Boolean): Unit = {\n+    var index  = 0\n+    val length = string.length\n+    if (!isKey && index < length && string.charAt(index) == ' ') {\n+      buffer.append(\"\\\\ \")\n+      index += 1\n+    }\n+\n+    while (index < length) {\n+      val ch = string.charAt(index)\n+      (ch: @switch) match {\n+        case '\\t' =>\n+          buffer.append(\"\\\\t\")\n+        case '\\n' =>\n+          buffer.append(\"\\\\n\")\n+        case '\\f' =>\n+          buffer.append(\"\\\\f\")\n+        case '\\r' =>\n+          buffer.append(\"\\\\r\")\n+        case '\\b' =>\n+          // On JVM \\b get printed like \\u0008 - See the following:\n+          // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-\n+          buffer.appendAll(unicodeToHexaDecimal(ch))"
  },
  {
    "id" : "55ba6842-bce1-46f3-b87d-fd7faa966376",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "f6492c7e-b419-4276-bb48-d0bf260abd20",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider dealing with those characters in the switch, for example with:\r\n```scala\r\ncase '\\\\' | '#' | '!' | '=' | ':' =>\r\n  buffer.append('\\\\')\r\n  buffer.append(ch)\r\ncase ' ' if isKey =>\r\n  buffer.append(\"\\\\ \")\r\n```",
        "createdAt" : "2020-05-14T11:40:11Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb11e77d-6072-47f8-935e-4e5a43744a40",
        "parentId" : "f6492c7e-b419-4276-bb48-d0bf260abd20",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This seems good. I am not sure what we are matching with `\\\\`. If that a backslash, is that the correct output?",
        "createdAt" : "2020-05-15T19:03:25Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1ee2d939-7b70-42ad-b4fe-64b37f092bc0",
        "parentId" : "f6492c7e-b419-4276-bb48-d0bf260abd20",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Yes, `'\\\\'` is 1 backslash, and it is output first as `'\\\\'` which is 1 backslash, followed by `ch` which is a second backslash.",
        "createdAt" : "2020-05-15T19:08:08Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "78d4d76e-a3e2-47f3-9944-748e339b1791",
        "parentId" : "f6492c7e-b419-4276-bb48-d0bf260abd20",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "The tests tell me you are correct - the code told me that the old way but I didn't trust it - to hard to read. Now it is much better.",
        "createdAt" : "2020-05-15T19:24:24Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()\n+      if (intVal == -1) {\n+        if (mode == UNICODE && count <= 4) {\n+          throw new IllegalArgumentException(\n+            \"Invalid Unicode sequence: expected format\")\n+        }\n+        if (keyLength == -1 && offset > 0)\n+          keyLength = offset\n+        if (keyLength >= 0) {\n+          val key   = new String(buf, 0, keyLength)\n+          val value = new String(buf, keyLength, offset - keyLength)\n+          put(key, if (mode == SLASH) value + '\\u0000' else value)\n+        }\n+      } else {\n+        nextChar = intVal.toChar\n+        if (offset == buf.length) {\n+          val newBuf = new Array[Char](buf.length << 1)\n+          System.arraycopy(buf, 0, newBuf, 0, offset)\n+          buf = newBuf\n+        }\n+        val _bool = if (mode == SLASH) {\n+          mode = NONE\n+          (nextChar: @switch) match {\n+            case '\\r' =>\n+              mode = CONTINUE // Look for a following \\n\n+              isFirstChar\n+            case '\\u0085' | '\\n' =>\n+              mode = IGNORE // Ignore whitespace on the next line\n+              isFirstChar\n+            case c @ ('b' | 'f' | 'n' | 'r' | 't') =>\n+              nextChar = nextCharMap(c)\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+            case 'u' =>\n+              mode = UNICODE\n+              unicode = 0\n+              count = 0\n+              isFirstChar\n+            case _ =>\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+          }\n+        } else {\n+          def fn(_nextChar: Char): Boolean = (_nextChar: @switch) match {\n+            case '#' | '!' if isFirstChar =>\n+              @tailrec def ignoreCharsTillEOL(tempVal: Char): Unit = {\n+                if (tempVal != 0xFFFF) { // -1.toChar\n+                  nextChar = tempVal.toChar\n+                  // not required\n+                  if (nextChar != '\\r' && nextChar != '\\n' && nextChar != '\\u0085') {\n+                    ignoreCharsTillEOL(br.read().toChar)\n+                  }\n+                }\n+              }\n+\n+              ignoreCharsTillEOL(br.read().toChar)\n+              isFirstChar\n+            case c @ ('\\n' | '\\u0085' | '\\r') =>\n+              if (c == '\\n' && mode == CONTINUE) { // Part of a \\r\\n sequence\n+                mode = IGNORE\n+                isFirstChar\n+              } else {\n+                mode = NONE\n+                if (offset > 0 || (offset == 0 && keyLength == 0)) {\n+                  if (keyLength == -1) keyLength = offset\n+                  val key   = new String(buf, 0, keyLength)\n+                  val value = new String(buf, keyLength, offset - keyLength)\n+                  put(key, value)\n+                }\n+                keyLength = -1\n+                offset = 0\n+                true\n+              }\n+            case '\\\\' =>\n+              if (mode == KEY_DONE) keyLength = offset\n+              mode = SLASH\n+              isFirstChar\n+            case ':' | '=' if keyLength == -1 =>\n+              // if parsing the key\n+              mode = NONE\n+              keyLength = offset\n+              isFirstChar\n+            case _ =>\n+              if (nextChar < 256 && Character.isWhitespace(nextChar)) {\n+                if (mode == CONTINUE) mode = IGNORE\n+                // if key length == 0 or value length == 0\n+                if (offset == 0 || offset == keyLength || mode == IGNORE)\n+                  isFirstChar\n+                else if (keyLength == -1) {\n+                  mode = KEY_DONE\n+                  isFirstChar\n+                } else {\n+                  if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                  else if (mode == KEY_DONE) {\n+                    keyLength = offset\n+                    mode = NONE\n+                  }\n+                  buf(offset) = nextChar\n+                  offset += 1\n+                  false\n+                }\n+              } else {\n+                if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                else if (mode == KEY_DONE) {\n+                  keyLength = offset\n+                  mode = NONE\n+                }\n+                buf(offset) = nextChar\n+                offset += 1\n+                false\n+              }\n+          }\n+          if (mode == UNICODE) {\n+            val digit = Character.digit(nextChar, 16)\n+            if (digit >= 0) {\n+              unicode = (unicode << 4) + digit\n+              count += 1\n+            } else if (count <= 4) {\n+              throw new IllegalArgumentException(\n+                \"Invalid Unicode sequence: illegal character\")\n+            }\n+            if (digit >= 0 && count < 4) {\n+              isFirstChar\n+            } else {\n+              mode = NONE\n+              buf(offset) = unicode.toChar\n+              offset += 1\n+              if (nextChar != '\\n' && nextChar != '\\u0085')\n+                isFirstChar\n+              else\n+                fn(nextChar)\n+            }\n+          } else {\n+            fn(nextChar)\n+          }\n+        }\n+        processNext(_bool)\n+      }\n+    }\n+\n+    processNext(true)\n+\n+  }\n+\n+  private def writeComments(writer: Writer, comments: String): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') { // \"\\r\\n\"\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) { // return char with either '#' or '!' afterward\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        writer.write(unicodeToHexaDecimal(chars(index)))\n+      }\n+      index += 1\n+    }\n+    writer.write(System.lineSeparator)\n+  }\n+\n+  private def dumpString(buffer: StringBuilder,\n+                         string: String,\n+                         isKey: Boolean,\n+                         toHexaDecimal: Boolean): Unit = {\n+    var index  = 0\n+    val length = string.length\n+    if (!isKey && index < length && string.charAt(index) == ' ') {\n+      buffer.append(\"\\\\ \")\n+      index += 1\n+    }\n+\n+    while (index < length) {\n+      val ch = string.charAt(index)\n+      (ch: @switch) match {\n+        case '\\t' =>\n+          buffer.append(\"\\\\t\")\n+        case '\\n' =>\n+          buffer.append(\"\\\\n\")\n+        case '\\f' =>\n+          buffer.append(\"\\\\f\")\n+        case '\\r' =>\n+          buffer.append(\"\\\\r\")\n+        case '\\b' =>\n+          // On JVM \\b get printed like \\u0008 - See the following:\n+          // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-\n+          buffer.appendAll(unicodeToHexaDecimal(ch))\n+        case _ =>\n+          if (\"\\\\#!=:\".indexOf(ch) >= 0 || (isKey && ch == ' '))"
  },
  {
    "id" : "56bc72c1-dbf7-4833-9826-455c6befa35e",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "89ed6c25-b7f7-4c97-897b-51a2f3e75e35",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider contracting this as\r\n```suggestion\r\n          if (toHexaDecimal && (ch < ' ' || ch > '~')) {\r\n```",
        "createdAt" : "2020-05-14T11:43:39Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f7012dcd-e673-4e48-92df-4cdd9d233969",
        "parentId" : "89ed6c25-b7f7-4c97-897b-51a2f3e75e35",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, that is a good suggestion.",
        "createdAt" : "2020-05-15T16:58:44Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()\n+      if (intVal == -1) {\n+        if (mode == UNICODE && count <= 4) {\n+          throw new IllegalArgumentException(\n+            \"Invalid Unicode sequence: expected format\")\n+        }\n+        if (keyLength == -1 && offset > 0)\n+          keyLength = offset\n+        if (keyLength >= 0) {\n+          val key   = new String(buf, 0, keyLength)\n+          val value = new String(buf, keyLength, offset - keyLength)\n+          put(key, if (mode == SLASH) value + '\\u0000' else value)\n+        }\n+      } else {\n+        nextChar = intVal.toChar\n+        if (offset == buf.length) {\n+          val newBuf = new Array[Char](buf.length << 1)\n+          System.arraycopy(buf, 0, newBuf, 0, offset)\n+          buf = newBuf\n+        }\n+        val _bool = if (mode == SLASH) {\n+          mode = NONE\n+          (nextChar: @switch) match {\n+            case '\\r' =>\n+              mode = CONTINUE // Look for a following \\n\n+              isFirstChar\n+            case '\\u0085' | '\\n' =>\n+              mode = IGNORE // Ignore whitespace on the next line\n+              isFirstChar\n+            case c @ ('b' | 'f' | 'n' | 'r' | 't') =>\n+              nextChar = nextCharMap(c)\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+            case 'u' =>\n+              mode = UNICODE\n+              unicode = 0\n+              count = 0\n+              isFirstChar\n+            case _ =>\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+          }\n+        } else {\n+          def fn(_nextChar: Char): Boolean = (_nextChar: @switch) match {\n+            case '#' | '!' if isFirstChar =>\n+              @tailrec def ignoreCharsTillEOL(tempVal: Char): Unit = {\n+                if (tempVal != 0xFFFF) { // -1.toChar\n+                  nextChar = tempVal.toChar\n+                  // not required\n+                  if (nextChar != '\\r' && nextChar != '\\n' && nextChar != '\\u0085') {\n+                    ignoreCharsTillEOL(br.read().toChar)\n+                  }\n+                }\n+              }\n+\n+              ignoreCharsTillEOL(br.read().toChar)\n+              isFirstChar\n+            case c @ ('\\n' | '\\u0085' | '\\r') =>\n+              if (c == '\\n' && mode == CONTINUE) { // Part of a \\r\\n sequence\n+                mode = IGNORE\n+                isFirstChar\n+              } else {\n+                mode = NONE\n+                if (offset > 0 || (offset == 0 && keyLength == 0)) {\n+                  if (keyLength == -1) keyLength = offset\n+                  val key   = new String(buf, 0, keyLength)\n+                  val value = new String(buf, keyLength, offset - keyLength)\n+                  put(key, value)\n+                }\n+                keyLength = -1\n+                offset = 0\n+                true\n+              }\n+            case '\\\\' =>\n+              if (mode == KEY_DONE) keyLength = offset\n+              mode = SLASH\n+              isFirstChar\n+            case ':' | '=' if keyLength == -1 =>\n+              // if parsing the key\n+              mode = NONE\n+              keyLength = offset\n+              isFirstChar\n+            case _ =>\n+              if (nextChar < 256 && Character.isWhitespace(nextChar)) {\n+                if (mode == CONTINUE) mode = IGNORE\n+                // if key length == 0 or value length == 0\n+                if (offset == 0 || offset == keyLength || mode == IGNORE)\n+                  isFirstChar\n+                else if (keyLength == -1) {\n+                  mode = KEY_DONE\n+                  isFirstChar\n+                } else {\n+                  if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                  else if (mode == KEY_DONE) {\n+                    keyLength = offset\n+                    mode = NONE\n+                  }\n+                  buf(offset) = nextChar\n+                  offset += 1\n+                  false\n+                }\n+              } else {\n+                if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                else if (mode == KEY_DONE) {\n+                  keyLength = offset\n+                  mode = NONE\n+                }\n+                buf(offset) = nextChar\n+                offset += 1\n+                false\n+              }\n+          }\n+          if (mode == UNICODE) {\n+            val digit = Character.digit(nextChar, 16)\n+            if (digit >= 0) {\n+              unicode = (unicode << 4) + digit\n+              count += 1\n+            } else if (count <= 4) {\n+              throw new IllegalArgumentException(\n+                \"Invalid Unicode sequence: illegal character\")\n+            }\n+            if (digit >= 0 && count < 4) {\n+              isFirstChar\n+            } else {\n+              mode = NONE\n+              buf(offset) = unicode.toChar\n+              offset += 1\n+              if (nextChar != '\\n' && nextChar != '\\u0085')\n+                isFirstChar\n+              else\n+                fn(nextChar)\n+            }\n+          } else {\n+            fn(nextChar)\n+          }\n+        }\n+        processNext(_bool)\n+      }\n+    }\n+\n+    processNext(true)\n+\n+  }\n+\n+  private def writeComments(writer: Writer, comments: String): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') { // \"\\r\\n\"\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) { // return char with either '#' or '!' afterward\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        writer.write(unicodeToHexaDecimal(chars(index)))\n+      }\n+      index += 1\n+    }\n+    writer.write(System.lineSeparator)\n+  }\n+\n+  private def dumpString(buffer: StringBuilder,\n+                         string: String,\n+                         isKey: Boolean,\n+                         toHexaDecimal: Boolean): Unit = {\n+    var index  = 0\n+    val length = string.length\n+    if (!isKey && index < length && string.charAt(index) == ' ') {\n+      buffer.append(\"\\\\ \")\n+      index += 1\n+    }\n+\n+    while (index < length) {\n+      val ch = string.charAt(index)\n+      (ch: @switch) match {\n+        case '\\t' =>\n+          buffer.append(\"\\\\t\")\n+        case '\\n' =>\n+          buffer.append(\"\\\\n\")\n+        case '\\f' =>\n+          buffer.append(\"\\\\f\")\n+        case '\\r' =>\n+          buffer.append(\"\\\\r\")\n+        case '\\b' =>\n+          // On JVM \\b get printed like \\u0008 - See the following:\n+          // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-\n+          buffer.appendAll(unicodeToHexaDecimal(ch))\n+        case _ =>\n+          if (\"\\\\#!=:\".indexOf(ch) >= 0 || (isKey && ch == ' '))\n+            buffer.append('\\\\')\n+          if (ch >= ' ' && ch <= '~') {\n+            buffer.append(ch)\n+          } else if (toHexaDecimal) {"
  },
  {
    "id" : "01ce59b1-4882-4302-ac5b-a255164cd122",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "629bb361-cdef-4ebd-a93a-8a2d81270c13",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider writing this without any loop. Something like\r\n```scala\r\n  private def unicodeToHexaDecimal(ch: Int): Array[Char] = {\r\n    def hexChar(x: Int): Char =\r\n      if (x > 9) (x - 10 + 'A').toChar\r\n      else (x + '0').toChar\r\n\r\n    Array('\\\\', 'u', hexChar((x >>> 12) & 15), hexChar((x >>> 8) & 15), hexChar((x >>> 4) & 15), hexChar(x & 15))\r\n  }\r\n```\r\nMuch shorter, certainly faster.",
        "createdAt" : "2020-05-14T11:49:05Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f294b50f-11b4-4417-b56d-086323da74c2",
        "parentId" : "629bb361-cdef-4ebd-a93a-8a2d81270c13",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "That is very pretty thank-you. I would have been hard pressed to come up with that but I can see the translation.",
        "createdAt" : "2020-05-15T16:33:08Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()\n+      if (intVal == -1) {\n+        if (mode == UNICODE && count <= 4) {\n+          throw new IllegalArgumentException(\n+            \"Invalid Unicode sequence: expected format\")\n+        }\n+        if (keyLength == -1 && offset > 0)\n+          keyLength = offset\n+        if (keyLength >= 0) {\n+          val key   = new String(buf, 0, keyLength)\n+          val value = new String(buf, keyLength, offset - keyLength)\n+          put(key, if (mode == SLASH) value + '\\u0000' else value)\n+        }\n+      } else {\n+        nextChar = intVal.toChar\n+        if (offset == buf.length) {\n+          val newBuf = new Array[Char](buf.length << 1)\n+          System.arraycopy(buf, 0, newBuf, 0, offset)\n+          buf = newBuf\n+        }\n+        val _bool = if (mode == SLASH) {\n+          mode = NONE\n+          (nextChar: @switch) match {\n+            case '\\r' =>\n+              mode = CONTINUE // Look for a following \\n\n+              isFirstChar\n+            case '\\u0085' | '\\n' =>\n+              mode = IGNORE // Ignore whitespace on the next line\n+              isFirstChar\n+            case c @ ('b' | 'f' | 'n' | 'r' | 't') =>\n+              nextChar = nextCharMap(c)\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+            case 'u' =>\n+              mode = UNICODE\n+              unicode = 0\n+              count = 0\n+              isFirstChar\n+            case _ =>\n+              buf(offset) = nextChar\n+              offset += 1\n+              false\n+          }\n+        } else {\n+          def fn(_nextChar: Char): Boolean = (_nextChar: @switch) match {\n+            case '#' | '!' if isFirstChar =>\n+              @tailrec def ignoreCharsTillEOL(tempVal: Char): Unit = {\n+                if (tempVal != 0xFFFF) { // -1.toChar\n+                  nextChar = tempVal.toChar\n+                  // not required\n+                  if (nextChar != '\\r' && nextChar != '\\n' && nextChar != '\\u0085') {\n+                    ignoreCharsTillEOL(br.read().toChar)\n+                  }\n+                }\n+              }\n+\n+              ignoreCharsTillEOL(br.read().toChar)\n+              isFirstChar\n+            case c @ ('\\n' | '\\u0085' | '\\r') =>\n+              if (c == '\\n' && mode == CONTINUE) { // Part of a \\r\\n sequence\n+                mode = IGNORE\n+                isFirstChar\n+              } else {\n+                mode = NONE\n+                if (offset > 0 || (offset == 0 && keyLength == 0)) {\n+                  if (keyLength == -1) keyLength = offset\n+                  val key   = new String(buf, 0, keyLength)\n+                  val value = new String(buf, keyLength, offset - keyLength)\n+                  put(key, value)\n+                }\n+                keyLength = -1\n+                offset = 0\n+                true\n+              }\n+            case '\\\\' =>\n+              if (mode == KEY_DONE) keyLength = offset\n+              mode = SLASH\n+              isFirstChar\n+            case ':' | '=' if keyLength == -1 =>\n+              // if parsing the key\n+              mode = NONE\n+              keyLength = offset\n+              isFirstChar\n+            case _ =>\n+              if (nextChar < 256 && Character.isWhitespace(nextChar)) {\n+                if (mode == CONTINUE) mode = IGNORE\n+                // if key length == 0 or value length == 0\n+                if (offset == 0 || offset == keyLength || mode == IGNORE)\n+                  isFirstChar\n+                else if (keyLength == -1) {\n+                  mode = KEY_DONE\n+                  isFirstChar\n+                } else {\n+                  if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                  else if (mode == KEY_DONE) {\n+                    keyLength = offset\n+                    mode = NONE\n+                  }\n+                  buf(offset) = nextChar\n+                  offset += 1\n+                  false\n+                }\n+              } else {\n+                if (mode == IGNORE || mode == CONTINUE) mode = NONE\n+                else if (mode == KEY_DONE) {\n+                  keyLength = offset\n+                  mode = NONE\n+                }\n+                buf(offset) = nextChar\n+                offset += 1\n+                false\n+              }\n+          }\n+          if (mode == UNICODE) {\n+            val digit = Character.digit(nextChar, 16)\n+            if (digit >= 0) {\n+              unicode = (unicode << 4) + digit\n+              count += 1\n+            } else if (count <= 4) {\n+              throw new IllegalArgumentException(\n+                \"Invalid Unicode sequence: illegal character\")\n+            }\n+            if (digit >= 0 && count < 4) {\n+              isFirstChar\n+            } else {\n+              mode = NONE\n+              buf(offset) = unicode.toChar\n+              offset += 1\n+              if (nextChar != '\\n' && nextChar != '\\u0085')\n+                isFirstChar\n+              else\n+                fn(nextChar)\n+            }\n+          } else {\n+            fn(nextChar)\n+          }\n+        }\n+        processNext(_bool)\n+      }\n+    }\n+\n+    processNext(true)\n+\n+  }\n+\n+  private def writeComments(writer: Writer, comments: String): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') { // \"\\r\\n\"\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) { // return char with either '#' or '!' afterward\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        writer.write(unicodeToHexaDecimal(chars(index)))\n+      }\n+      index += 1\n+    }\n+    writer.write(System.lineSeparator)\n+  }\n+\n+  private def dumpString(buffer: StringBuilder,\n+                         string: String,\n+                         isKey: Boolean,\n+                         toHexaDecimal: Boolean): Unit = {\n+    var index  = 0\n+    val length = string.length\n+    if (!isKey && index < length && string.charAt(index) == ' ') {\n+      buffer.append(\"\\\\ \")\n+      index += 1\n+    }\n+\n+    while (index < length) {\n+      val ch = string.charAt(index)\n+      (ch: @switch) match {\n+        case '\\t' =>\n+          buffer.append(\"\\\\t\")\n+        case '\\n' =>\n+          buffer.append(\"\\\\n\")\n+        case '\\f' =>\n+          buffer.append(\"\\\\f\")\n+        case '\\r' =>\n+          buffer.append(\"\\\\r\")\n+        case '\\b' =>\n+          // On JVM \\b get printed like \\u0008 - See the following:\n+          // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-\n+          buffer.appendAll(unicodeToHexaDecimal(ch))\n+        case _ =>\n+          if (\"\\\\#!=:\".indexOf(ch) >= 0 || (isKey && ch == ' '))\n+            buffer.append('\\\\')\n+          if (ch >= ' ' && ch <= '~') {\n+            buffer.append(ch)\n+          } else if (toHexaDecimal) {\n+            buffer.appendAll(unicodeToHexaDecimal(ch))\n+          } else {\n+            buffer.append(ch)\n+          }\n+      }\n+      index += 1\n+    }\n+  }\n+\n+  private def unicodeToHexaDecimal(ch: Int): Array[Char] = {\n+    val hexChars = Array('\\\\', 'u', '0', '0', '0', '0')\n+    var hexChar  = 0\n+    var index    = hexChars.length\n+    var copyOfCh = ch\n+    do {\n+      hexChar = copyOfCh & 15\n+      if (hexChar > 9) hexChar = hexChar - 10 + 'A'\n+      else hexChar += '0'\n+      index -= 1\n+      hexChars(index) = hexChar.toChar\n+    } while ({ copyOfCh >>>= 4; copyOfCh != 0 })\n+    hexChars\n+  }"
  },
  {
    "id" : "ccf9808c-bffd-4337-8674-9cc6bbca5ad6",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "9c1bee74-fcb2-486f-8142-4c99d221e69e",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider using `br.readLine()`, then work on that string. `br.readLine()` already takes care of handling `\\r`, `\\n` and `\\r\\n`, so you don't have to mess with `isFirstChar` and `CONTINUE`. You would only have to parse line by line.",
        "createdAt" : "2020-05-14T13:38:39Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1a9c7d1e-a9d0-411d-a631-0590f81d68af",
        "parentId" : "9c1bee74-fcb2-486f-8142-4c99d221e69e",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I went with a line oriented approach - multi-line for continued values.",
        "createdAt" : "2020-06-23T18:13:18Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {\n+      val intVal = br.read()"
  },
  {
    "id" : "92845eba-c9d4-4668-ad41-358040279be8",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "b0e4317c-839d-40a5-8951-76bbe9f3e7b5",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Please avoid pseudo-tailrec functions that actually modify surrounding state. That's twice as hard to understand, because one has to reason about the state *plus* the accumulators like `isFirstChar`. Prefer using a good old `while` loop instead.",
        "createdAt" : "2020-05-14T13:46:12Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0da7e500-6717-4a79-9988-7d32ff6c0738",
        "parentId" : "b0e4317c-839d-40a5-8951-76bbe9f3e7b5",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Overall, I find this algorithm that revolves around reading one character per loop iteration, and fiddle with a `mode` to save the state, *very* hard to reason about.\r\n\r\nHave you considered using a much more straightforward approach that parses logical bits instead? Something with the following structure:\r\n```scala\r\nwhile (...) {\r\n  val line = br.readLine()\r\n  var i: Int = 0\r\n\r\n  def parseUnicodeEscape(): Char = ...\r\n\r\n  def parseKey(): String = {\r\n    while (line.charAt(i) != '=') { ... }\r\n  }\r\n\r\n  def parseValue(): String = {\r\n    while (i < line.length) { ... }\r\n  }\r\n\r\n  val key = parseKey()\r\n  i += 1 // the '='\r\n  val value = parseValue()\r\n\r\n  putProperty(key, value)\r\n}\r\n```\r\nWouldn't that be so much easier to reason about?",
        "createdAt" : "2020-05-14T13:51:23Z",
        "updatedAt" : "2020-08-08T20:43:51Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "07852100-0eab-4564-b4c9-8235fb64cb8f",
        "parentId" : "b0e4317c-839d-40a5-8951-76bbe9f3e7b5",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I didn't write any of the current code but I knew it was super ugly. I couldn't reason about any of it honestly.\r\n\r\nThanks for the basic layout - I have made some progress. If I can get it to the point the tests pass then that would be great.",
        "createdAt" : "2020-05-18T16:38:43Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b7c3c5cc-8a27-4a1f-8dc0-b6045fc098fe",
        "parentId" : "b0e4317c-839d-40a5-8951-76bbe9f3e7b5",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I think the result is much more readable and maintainable. It has a very imperative style using `var`s and such.",
        "createdAt" : "2020-06-23T18:15:42Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -67,19 +101,325 @@ class Properties(protected val defaults: Properties)\n   }\n \n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n-    entrySet().asScala.foreach { entry => out.println(format(entry)) }\n+    list(new PrintWriter(new OutputStreamWriter(out), true))\n   }\n \n   def list(out: PrintWriter): Unit = {\n     out.println(\"-- listing properties --\")\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    if (out == null) {\n+      throw new NullPointerException()\n+    }\n+    // https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-\n+    val writer = new OutputStreamWriter(out, \"ISO8859_1\")\n+    store(writer, comments)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit = {\n+    if (writer == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (comments != null) {\n+      writeComments(writer, comments)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    val buffer = new StringBuilder(200)\n+    entrySet().asScala.foreach { entry =>\n+      val key = entry.getKey.asInstanceOf[String]\n+      dumpString(buffer, key, true, false)\n+      buffer.append('=')\n+      dumpString(buffer, entry.getValue.asInstanceOf[String], false, false)\n+      buffer.append(System.lineSeparator)\n+      writer.write(buffer.toString)\n+      buffer.setLength(0)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\") def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private val NONE     = 0\n+  private val SLASH    = 1\n+  private val UNICODE  = 2\n+  private val CONTINUE = 3 // when \\r is encountered looks for next \\n\n+  private val KEY_DONE = 4\n+  private val IGNORE   = 5\n+  private lazy val nextCharMap =\n+    SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+\n+  private def isEbcdic(in: BufferedInputStream): Boolean = {\n+    var b: Byte = 0\n+    while ({ b = in.read.toByte; b != -1 }) {\n+      if (b == 0x23 || b == 0x0a || b == 0x3d) { // ascii: newline/#/=\n+        return false\n+      }\n+      if (b == 0x15) { // EBCDIC newline\n+        return true\n+      }\n+    }\n+    //we found no ascii newline, '#', neither '=', relative safe to consider it\n+    //as non-ascii, the only exception will be a single line with only key(no value and '=')\n+    //in this case, it should be no harm to read it in default charset\n+    false\n+  }\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    var mode           = NONE\n+    var unicode        = 0\n+    var count          = 0\n+    var nextChar: Char = 0\n+    var buf            = new Array[Char](80)\n+    var offset         = 0\n+    var keyLength      = -1\n+    val br             = new BufferedReader(reader)\n+\n+    @tailrec def processNext(isFirstChar: Boolean): Unit = {"
  },
  {
    "id" : "ccc1d7da-24e9-47b5-8d4e-fb4230559470",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "8b16de45-425c-4f8c-ae03-1aadb401cdfc",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Is this still relevant in the latest version of the code?",
        "createdAt" : "2020-08-07T10:02:22Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1a63e820-1120-48c5-baec-d94de6689e96",
        "parentId" : "8b16de45-425c-4f8c-ae03-1aadb401cdfc",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Not really so I removed it.",
        "createdAt" : "2020-08-07T22:33:03Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -1,10 +1,16 @@\n+/**\n+ * Ported from Harmony"
  },
  {
    "id" : "48123319-ba2a-4661-b0a2-66fde0d973d6",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "ee91df47-c352-4842-82bc-3490e917ba65",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider\r\n```suggestion\r\n  private final val listStr = \"-- listing properties --\"\r\n```\r\nto allow constant folding.",
        "createdAt" : "2020-08-07T10:08:22Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "37e7bffa-47e0-4b25-bb40-529e206b06be",
        "parentId" : "ee91df47-c352-4842-82bc-3490e917ba65",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-07T22:32:42Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\""
  },
  {
    "id" : "e84916db-142b-4a37-a1af-a67521e98407",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "a5f41449-5dbd-4a29-af0a-3abf9e79dd64",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n    storeImpl(writer, comments, toHex = true)\r\n```",
        "createdAt" : "2020-08-07T10:10:13Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4b21af96-8a2d-45c5-b532-fef6c9bd5af2",
        "parentId" : "a5f41449-5dbd-4a29-af0a-3abf9e79dd64",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Specifying the parameter is much more readable. Ditto below.",
        "createdAt" : "2020-08-07T22:35:05Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)"
  },
  {
    "id" : "3d3ede3e-03c3-4388-b9ef-da2ccf73bb9a",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "8059a342-6b27-432a-ae8c-fdba84b7cd2a",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n    storeImpl(writer, comments, toHex = false)\r\n```",
        "createdAt" : "2020-08-07T10:10:21Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "56f23bd6-d64d-48ca-a3c1-c85026b31a75",
        "parentId" : "8059a342-6b27-432a-ae8c-fdba84b7cd2a",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Ditto.",
        "createdAt" : "2020-08-07T22:35:16Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)"
  },
  {
    "id" : "28b8713f-7b5b-4991-b563-6e273caad246",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "e344d4b5-fdf2-4a8c-a6c8-6e6a33b4b03b",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This branch should also be taken for characters < 0x20 and those > 0xfe. So the original condition should probably be\r\n```suggestion\r\n      if (chars(index) >= 0x20 && chars(index) <= 0xfe) {\r\n```\r\nand the cases for `\\r` and `\\n` moved to the else branch.",
        "createdAt" : "2020-08-07T10:20:21Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2f2797f4-cbab-4c3e-ae29-066355c8e42f",
        "parentId" : "e344d4b5-fdf2-4a8c-a6c8-6e6a33b4b03b",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I think this is correct as this is just writing the comments. For the keys and values that is the correct logic. I made a change to use the hex values so it matches the Javadoc. For comments it says \"Latin 1\" so I now use `ch <= 0xff`. I could reverse the logic to `> 0xff` for the encoding branch but it seems the normal case is without encoding but your call.",
        "createdAt" : "2020-08-07T22:31:35Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          // \"\\r\\n\"\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') {\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          // return char with either '#' or '!' afterward\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) {\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        if (toHex) {\n+          writer.write(unicodeToHexaDecimal(chars(index)))"
  },
  {
    "id" : "f5c92cdb-56fa-43ac-bac7-cc123119c4b8",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "003b4215-9973-4aeb-8919-2cac2edb3db9",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "AFAICT, this branch is redundant. If you don't write the character nor increment `index`, then the character will naturally be written by the next iteration of the loop. It would be less code, and better fit the way things are described in the JavaDoc:\r\n\r\n> [...] and if the next character in comments is not character # or character ! then an ASCII # is written out after that line separator.",
        "createdAt" : "2020-08-07T10:22:14Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b74cbf1b-b501-4cb5-a308-79eff11a10cb",
        "parentId" : "003b4215-9973-4aeb-8919-2cac2edb3db9",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I reworked it to do this exactly.",
        "createdAt" : "2020-08-07T20:52:43Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          // \"\\r\\n\"\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') {\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          // return char with either '#' or '!' afterward\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) {\n+            writer.write(chars(indexPlusOne))\n+            index += 1"
  },
  {
    "id" : "8fa5155f-e90d-498d-b043-ad3280baec09",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "0a64ea52-5eab-435c-8fd1-4f53ffae6145",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Spurious blank line.",
        "createdAt" : "2020-08-07T10:22:34Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "73b5646f-eb40-4d15-89c8-8688085f3ed1",
        "parentId" : "0a64ea52-5eab-435c-8fd1-4f53ffae6145",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Removed thanks.",
        "createdAt" : "2020-08-07T22:36:04Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          // \"\\r\\n\"\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') {\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          // return char with either '#' or '!' afterward\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) {\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+"
  },
  {
    "id" : "d66638f1-2d50-4d12-aa51-aae07effa101",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "1bab260f-3edf-4356-9f32-4f8eb0423b3d",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I would much rather have `index + 1` every time at call site, rather than this def.\r\n\r\nIt's especially important here because `index` is a `var`, which means that capturing inside a def makes it an `IntRef` on the heap, and can have dramatic consequences for performance.",
        "createdAt" : "2020-08-07T10:23:34Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1"
  },
  {
    "id" : "c31f053f-759a-4121-bd3c-6d120d810ce9",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "9855ec36-fb1c-4307-82e2-9e4661cca5d8",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider adding\r\n```scala\r\nval c = chars(index)\r\n```\r\nand then use `c` every time instead of `chars(index)`, to avoid fetching it from memory over and over again.",
        "createdAt" : "2020-08-07T10:24:37Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2522acd-84e6-453e-a5c1-dc3cdb25bf6f",
        "parentId" : "9855ec36-fb1c-4307-82e2-9e4661cca5d8",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I couldn't get rid of all lookups but this is much better.",
        "createdAt" : "2020-08-07T22:34:07Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {"
  },
  {
    "id" : "288bf1c5-361f-4f92-8f97-67ce7b3e87f4",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "4f80e0aa-ac9c-4dcb-a33d-dffad148ec10",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n      writer.write(encodeString(entry.getKey.asInstanceOf[String], isKey = true, toHex))\r\n```",
        "createdAt" : "2020-08-07T10:28:08Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e30366d8-13ab-47a9-ace7-710139c50a4c",
        "parentId" : "4f80e0aa-ac9c-4dcb-a33d-dffad148ec10",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Ditto.",
        "createdAt" : "2020-08-07T22:35:46Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))"
  },
  {
    "id" : "f6bf90f9-0cd3-42fd-aab3-85762565d1a5",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "697db4d1-61cd-496f-be9a-7eac0abcd6e7",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n        encodeString(entry.getValue.asInstanceOf[String], isKey = false, toHex))\r\n```",
        "createdAt" : "2020-08-07T10:28:15Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "87720b21-208c-48cc-bb04-e5e98805fdb6",
        "parentId" : "697db4d1-61cd-496f-be9a-7eac0abcd6e7",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Ditto.",
        "createdAt" : "2020-08-07T22:35:42Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))"
  },
  {
    "id" : "6f631e2d-f8fd-44bb-868b-dee309a02dcc",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "f6bd4a2f-7c73-416d-97c2-4e38ffa789e2",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "`isKey` is not going to change between iterations. Consider:\r\n```suggestion\r\n    if (!isKey) {\r\n      while (index < length && string.charAt(index) == ' ') {\r\n        buffer.append(\"\\\\ \")\r\n        index += 1\r\n      }\r\n    }\r\n```",
        "createdAt" : "2020-08-07T10:30:05Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d5aeb9e7-191d-4609-b21c-1614cf30ee2b",
        "parentId" : "f6bd4a2f-7c73-416d-97c2-4e38ffa789e2",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Good idea. Thanks.",
        "createdAt" : "2020-08-07T19:32:04Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()\n+          key = parseKey()\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+          if (!prevValueContinue) {\n+            setProperty(key, value)\n+            isKeyParsed = false\n+          }\n+        } else if (prevValueContinue && valueContinues()) {\n+          val value = parseValue()\n+          prevValueContinue = valueContinues()\n+        } else {\n+          val value = parseValue()\n+          setProperty(key, value)\n+          isKeyParsed = false\n+          prevValueContinue = false\n+        }\n+      }\n+    }\n+  }\n+\n+  private def writeComments(writer: Writer,\n+                            comments: String,\n+                            toHex: Boolean): Unit = {\n+    writer.write('#')\n+    val chars = comments.toCharArray\n+    var index = 0\n+    while (index < chars.length) {\n+      if (chars(index) < 256) {\n+        if (chars(index) == '\\r' || chars(index) == '\\n') {\n+          def indexPlusOne = index + 1\n+          // \"\\r\\n\"\n+          if (chars(index) == '\\r'\n+              && indexPlusOne < chars.length\n+              && chars(indexPlusOne) == '\\n') {\n+            index += 1\n+          }\n+          writer.write(System.lineSeparator)\n+          // return char with either '#' or '!' afterward\n+          if (indexPlusOne < chars.length\n+              && (chars(indexPlusOne) == '#'\n+              || chars(indexPlusOne) == '!')) {\n+            writer.write(chars(indexPlusOne))\n+            index += 1\n+          } else {\n+            writer.write('#')\n+          }\n+\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      } else {\n+        if (toHex) {\n+          writer.write(unicodeToHexaDecimal(chars(index)))\n+        } else {\n+          writer.write(chars(index))\n+        }\n+      }\n+      index += 1\n+    }\n+    writer.write(System.lineSeparator)\n+  }\n+\n+  private def encodeString(string: String,\n+                           isKey: Boolean,\n+                           toHex: Boolean): String = {\n+    val buffer = new jl.StringBuilder(200)\n+    var index  = 0\n+    val length = string.length\n+    // leading element (value) spaces are escaped\n+    while (!isKey && index < length && string.charAt(index) == ' ') {\n+      buffer.append(\"\\\\ \")\n+      index += 1\n+    }"
  },
  {
    "id" : "a423e3f8-b789-481b-bd75-411d026a74fe",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "470eeaa9-0fa9-45b7-a665-26a36e632417",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider\r\n```scala\r\nvalBuf.setLength(0)\r\n```\r\nso that you don't have to reallocate a new `StringBuilder` (and its internal array) every time. Then you can also make `valBuf` a `val`.",
        "createdAt" : "2020-08-07T10:35:25Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "06be4535-a6de-4672-8758-d5450735857d",
        "parentId" : "470eeaa9-0fa9-45b7-a665-26a36e632417",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This is much better, thanks. I suppose the key buffer could be reused as well.",
        "createdAt" : "2020-08-07T22:41:58Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {\n+            val mch = chMap(ch)\n+            buf.append(mch)\n+          } else {\n+            buf.append(ch)\n+          }\n+        } else {\n+          buf.append(ch)\n+        }\n+\n+      def parseKey(): String = {\n+        val buf = new jl.StringBuilder()\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // key sep or empty value\n+        while (!isKeySeparator(ch) && i < line.length()) {\n+          processChar(buf)\n+          ch = getNextChar\n+        }\n+        // ignore trailing whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+        // ignore non-space key separator\n+        if (i < line.length && isTokenKeySeparator(ch)) {\n+          ch = getNextChar\n+        }\n+        isKeyParsed = true\n+        buf.toString()\n+      }\n+\n+      def parseValue(): String = {\n+        // ignore leading whitespace\n+        while (i < line.length && isWhitespace(ch)) {\n+          ch = getNextChar\n+        }\n+\n+        // nothing but line continuation\n+        if (valueContinues() && i == line.length() - 1) {\n+          // ignore the final backslash\n+          ch = getNextChar\n+        }\n+\n+        while (i < line.length) {\n+          if (valueContinues() && i == line.length() - 1) {\n+            // ignore the final backslash\n+            ch = getNextChar\n+          } else {\n+            processChar(valBuf)\n+            ch = getNextChar\n+          }\n+        }\n+        valBuf.toString()\n+      }\n+\n+      // run the parsing\n+      if (!(isComment() || isEmpty())) {\n+        ch = getNextChar\n+        if (!isKeyParsed) {\n+          valBuf = new jl.StringBuilder()"
  },
  {
    "id" : "aa832e73-3aac-444e-994d-69df96ac0666",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "fce59c90-738d-4955-8172-741eecd69fdc",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Please declare side-effecting methods with `()`, and call them with `()` as well.",
        "createdAt" : "2020-08-07T10:35:57Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9490b63a-50ee-4594-8d1c-42cd63539a58",
        "parentId" : "fce59c90-738d-4955-8172-741eecd69fdc",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Fixed.",
        "createdAt" : "2020-08-07T22:42:11Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {"
  },
  {
    "id" : "27692636-db2e-419e-b79a-8520898b52b8",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "5913c12e-3bab-44b1-9ba9-4758b44c2af1",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Where is the call to `trim`?",
        "createdAt" : "2020-08-07T10:37:59Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "13f44817-8438-4f7d-9074-e0e6901f8fde",
        "parentId" : "5913c12e-3bab-44b1-9ba9-4758b44c2af1",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This is an obsolete comment. Trim could not be used as trailing white space after line continuation is allowed.",
        "createdAt" : "2020-08-07T17:19:48Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace"
  },
  {
    "id" : "72367d95-edba-4bcf-9da3-a1996ff4a167",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "ccca5728-2583-419c-982b-0661d8d39748",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The JavaDoc is very explicit about the fact that `\\b` is *not* recognized as an escape sequence. So `b` should not be in this list.",
        "createdAt" : "2020-08-07T10:49:36Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "48d82a1e-e5c9-4ccc-bb70-eb1db5c18896",
        "parentId" : "ccca5728-2583-419c-982b-0661d8d39748",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This is fixed and removed via the `match` suggestion you made.",
        "createdAt" : "2020-08-07T22:43:02Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')"
  },
  {
    "id" : "1cf6d17f-8deb-4b40-be30-858119754e0c",
    "prId" : 1653,
    "comments" : [
      {
        "id" : "7816ceea-b905-4369-ad3e-b95ce8b8a8aa",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider switching on `ch` instead of this `if`, as well as the `ch == 'u'`. Then you can also use a different case for each of `t f r n` (no `b`, see above), and that way you don't even need the `chMap` at all, which would be much more efficient.",
        "createdAt" : "2020-08-07T10:51:33Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9d9e7ab7-350e-4d64-8650-6a10a3f80f37",
        "parentId" : "7816ceea-b905-4369-ad3e-b95ce8b8a8aa",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This looks much, much better and removes the map too. Thanks.",
        "createdAt" : "2020-08-07T17:40:41Z",
        "updatedAt" : "2020-08-08T20:43:52Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6da8c9aec7858ca01f17188a1333b62d54089d7a",
    "line" : null,
    "diffHunk" : "@@ -66,20 +74,304 @@ class Properties(protected val defaults: Properties)\n       s\"$key=$value\"\n   }\n \n+  private val listStr = \"-- listing properties --\"\n+\n   def list(out: PrintStream): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n   def list(out: PrintWriter): Unit = {\n-    out.println(\"-- listing properties --\")\n+    out.println(listStr)\n     entrySet().asScala.foreach { entry => out.println(format(entry)) }\n   }\n \n+  def store(out: OutputStream, comments: String): Unit = {\n+    val writer = new OutputStreamWriter(out, StandardCharsets.ISO_8859_1)\n+    storeImpl(writer, comments, true)\n+  }\n+\n+  def store(writer: Writer, comments: String): Unit =\n+    storeImpl(writer, comments, false)\n+\n+  private def storeImpl(writer: Writer,\n+                        comments: String,\n+                        toHex: Boolean): Unit = {\n+    if (comments != null) {\n+      writeComments(writer, comments, toHex)\n+    }\n+\n+    writer.write('#')\n+    writer.write(new Date().toString)\n+    writer.write(System.lineSeparator)\n+\n+    entrySet().asScala.foreach { entry =>\n+      writer.write(encodeString(entry.getKey.asInstanceOf[String], true, toHex))\n+      writer.write('=')\n+      writer.write(\n+        encodeString(entry.getValue.asInstanceOf[String], false, toHex))\n+      writer.write(System.lineSeparator)\n+    }\n+    writer.flush()\n+  }\n+\n+  @deprecated(\"\", \"\")\n+  def save(out: OutputStream, comments: String): Unit =\n+    store(out, comments)\n+\n+  private def loadImpl(reader: Reader): Unit = {\n+    import java.util.regex._\n+    val trailingBackspace = Pattern.compile(\"\"\"(\\\\)+$\"\"\")\n+    lazy val chMap =\n+      SMap('b' -> '\\b', 'f' -> '\\f', 'n' -> '\\n', 'r' -> '\\r', 't' -> '\\t')\n+    val br                = new BufferedReader(reader)\n+    var valBuf            = new jl.StringBuilder()\n+    var prevValueContinue = false\n+    var isKeyParsed       = false\n+    var key: String       = null\n+    var line: String      = null\n+\n+    while ({ line = br.readLine(); line != null }) {\n+      var i: Int   = -1\n+      var ch: Char = Char.MinValue\n+\n+      def getNextChar: Char = {\n+        i += 1\n+        // avoid out of bounds if value is empty\n+        if (i < line.length())\n+          line.charAt(i)\n+        else\n+          ch\n+      }\n+\n+      def parseUnicodeEscape(): Char = {\n+        val sb = new jl.StringBuilder()\n+        var j  = 0\n+        while (j < 4) {\n+          sb.append(line.charAt(i))\n+          if (j < 3) {\n+            // don't advance past the last char used\n+            i += 1\n+          }\n+          j += 1\n+        }\n+        val ch = Integer.parseInt(sb.toString(), 16).toChar\n+        ch\n+      }\n+\n+      def isWhitespace(char: Char): Boolean =\n+        char == ' ' || char == '\\t' || char == '\\f'\n+\n+      def isTokenKeySeparator(char: Char): Boolean =\n+        char == '=' || char == ':'\n+\n+      def isKeySeparator(char: Char): Boolean =\n+        isTokenKeySeparator(char) || isWhitespace(char)\n+\n+      def isEmpty(): Boolean =\n+        line.isEmpty() // trim removes all whitespace\n+\n+      def isComment(): Boolean =\n+        line.startsWith(\"#\") || line.startsWith(\"!\")\n+\n+      def oddBackslash(): Boolean = {\n+        val m = trailingBackspace.matcher(line)\n+        if (m.find()) {\n+          val num   = m.end(1) - m.start\n+          val isOdd = num % 2 != 0\n+          isOdd\n+        } else {\n+          false\n+        }\n+      }\n+\n+      def valueContinues(): Boolean = oddBackslash()\n+\n+      def processChar(buf: jl.StringBuilder): Unit =\n+        if (ch == '\\\\') {\n+          ch = getNextChar\n+          if (ch == 'u') {\n+            getNextChar // advance\n+            val uch = parseUnicodeEscape()\n+            buf.append(uch)\n+          } else if (ch == 't' || ch == 'f' || ch == 'r' || ch == 'n' || ch == 'b') {"
  }
]
[
  {
    "id" : "b4a9e268-5505-49f3-9b6d-86ef59f8398e",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "parentId" : null,
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This part in Scala.js does esentially the code for `fillInStackTrace` if you compare the code. Here if it is empty you just return empty rather than trying to fill it.",
        "createdAt" : "2019-08-21T21:36:25Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c53a3cd7-5e96-4e80-8dbc-255d218feae5",
        "parentId" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "This didn't work how I wanted it to. It was suppose to point to the `getStackTrace` method.",
        "createdAt" : "2019-08-21T21:44:09Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9dfaa27a-dcef-48d6-8c76-5d4f8c7134bd",
        "parentId" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "After off-line discussion, I believe that Eric and I agreed to leave the code as it is.  \r\nThe revised code specifies the type of the empty array and follows the JVM\r\nspec more closely by cloning stackTrace rather than returning the writable original.\r\n\r\n@ekrich If you agree, could you take a moment and resolve this conversation.  If \r\nI have mis-characterized or misundertood our discussion, please advise.",
        "createdAt" : "2019-08-21T22:42:19Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0103a561-c86c-46a3-b2f4-a5c898070917",
        "parentId" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I think that sounds good if that is how you interpret the documents as well. If people have performance or other concerns the original is fine with me with a simple comment.",
        "createdAt" : "2019-08-22T00:33:44Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "857c9590-12d4-4423-802f-446b43ac7599",
        "parentId" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Ah, a \"simple comment\" turned into a long tour through some tricky code!  \r\n\r\n@ekrich If/when you have time, could you check the comment you recommended\r\nand see if I described the situation so that another devo could follow it?  Thank you.\r\n\r\nI can re-work it if it comes off as word salad....  ",
        "createdAt" : "2019-08-31T11:56:39Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c1fc9da-0a79-4b0c-bc69-2ec5c4a34272",
        "parentId" : "7478c5d7-fa5d-43fd-aa07-012b9ad5126d",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The strategy here is correct. Scala.js stores raw data in `fillInStackTrace()`, and only expands them into an `Array[StackTraceElement]` on first request. Scala Native eagerly creates the `StackTraceElement`s in `fillInStackTrace()`, so `getStackTrace()` doesn't have to do anything special.",
        "createdAt" : "2020-05-07T18:19:57Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,111 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n     if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+      Array.empty[StackTraceElement]\n+    } else\n+      this.synchronized {\n+        stackTrace.clone\n+      }"
  },
  {
    "id" : "5d0f4aa3-1d0a-4798-8964-1ec2616d656b",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "1310257a-0e95-4516-bfb3-d5b980f4d3a8",
        "parentId" : null,
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "I was thinking of checking the exception throwing paths and the messages.",
        "createdAt" : "2019-08-21T21:39:59Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ed7851db-95bb-4852-a195-215f728fb33b",
        "parentId" : "1310257a-0e95-4516-bfb3-d5b980f4d3a8",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Two tests in ThrowablesSuite.scala, below, test the paths which throw exceptions and that\r\nthe cause Throwable has object equality with the cause Throwable given as an argument\r\nto initCause().  If there is no object equality, the messages within the result & expected cause\r\nthrowables are given by the assert().\r\n```\r\ntest(\"initCause(cause) - cases which throw an Exception\")\r\ntest(\"initCause(cause)\")\r\n```   \r\n\r\nDoes this resolve your concern?\r\n\r\nThe test suite code tests that the type of exception thrown is as expected. It does not check that the\r\ntext of the message is as expected.  There is code in other suites which does an exact message match,\r\nbut it is tedious to implement.",
        "createdAt" : "2019-08-21T23:03:09Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2c18416e-fa64-453a-8d4f-7761ec0c8a4d",
        "parentId" : "1310257a-0e95-4516-bfb3-d5b980f4d3a8",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "That seems totally fine and would port back to Scala.js as well.",
        "createdAt" : "2019-08-22T00:31:28Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 155,
    "diffHunk" : "@@ -49,49 +49,111 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n     if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+      Array.empty[StackTraceElement]\n+    } else\n+      this.synchronized {\n+        stackTrace.clone\n+      }\n   }\n \n-  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n-    var i = 0\n-    while (i < stackTrace.length) {\n-      if (stackTrace(i) eq null)\n-        throw new NullPointerException()\n-      i += 1\n+  final def getSuppressed(): Array[Throwable] = {\n+    if (suppressed == null) {\n+      Array.empty[Throwable]\n+    } else\n+      this.synchronized {\n+        suppressed.clone()\n+      }\n+  }\n+\n+  def initCause(cause: Throwable): Throwable = {\n+    // Java 8 spec says initCause has \"at-most-once\" semantics,\n+    // where implied use in a constructor counts.\n+\n+    if (cause == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-causation not permitted\")\n     }\n \n-    this.stackTrace = stackTrace.clone()\n+    this.synchronized {\n+      if (e != null) {\n+        // Yes, JVM uses contraction \"Can't\"\n+        val msg = if (cause == null) \"a null\" else cause.toString\n+        throw new java.lang.IllegalStateException(\n+          s\"Can't overwrite cause with ${msg}\")\n+      } else {"
  },
  {
    "id" : "abafdd71-0e5a-4423-b739-21a2d6272ffc",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "129aa0fb-d11f-40a6-b905-87b26585f5ba",
        "parentId" : null,
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "check `this.stackTrace ne null`?",
        "createdAt" : "2020-05-07T02:39:17Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "90050652-77bf-4756-9555-129144001568",
        "parentId" : "129aa0fb-d11f-40a6-b905-87b26585f5ba",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "@hepin1989 Thank you for the review & suggestion. Always good to have another\r\npair of eyes go over the code. \r\n\r\nI concur that `null.synchronized` and `null.stackTrace` would not be a good thing to happen.\r\n\r\nI believe that if the code in lines 106 & 107 are executing then `this` is an\r\ninstantiated object and can not be null.  Am I missing something?\r\n\r\n",
        "createdAt" : "2020-05-07T15:08:35Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "53ceb244-8b01-4037-8b5f-360d57fc7083",
        "parentId" : "129aa0fb-d11f-40a6-b905-87b26585f5ba",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The code is correct as is.",
        "createdAt" : "2020-05-07T18:16:50Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "192b5067-26cd-4e1c-a9f3-c680f488dee9",
        "parentId" : "129aa0fb-d11f-40a6-b905-87b26585f5ba",
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "@LeeTibbert \r\n```scala\r\nif(this.stackTrace ne null) this \r\n```\r\nis not needed?",
        "createdAt" : "2020-05-07T22:07:08Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dbf5eb25-8ca0-48b8-98d0-e1bc14bd6c92",
        "parentId" : "129aa0fb-d11f-40a6-b905-87b26585f5ba",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "No, it isn't, and would even go against what the JVM does. If you first call `setStackTrace()` then `fillInStackTrace()`, the latter will overwrite the former.",
        "createdAt" : "2020-05-08T06:12:54Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 88,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()"
  },
  {
    "id" : "d8bf3a46-eb71-4a64-b83e-2256fd15ba71",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "4625d10f-58ba-4304-a942-6e98fa2429ed",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This comment does not really bring any value, IMO.\r\n\r\nThe JDK spec does not specify the precise error message of this (or most) exception. And in fact different JDK implementations use different error message. For that reason, it usually does not make sense to reproduce the exact error message of the JDK. So if you want another message, or none at all (like in Scala.js), you can.",
        "createdAt" : "2020-05-07T17:59:54Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7d0457a5-2bfe-45a1-a294-d021ff2bb9b5",
        "parentId" : "4625d10f-58ba-4304-a942-6e98fa2429ed",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Reference comment and one similar removed.",
        "createdAt" : "2020-05-08T20:00:39Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c50bf210-3871-4427-b3fc-a14f96abc843",
        "parentId" : "4625d10f-58ba-4304-a942-6e98fa2429ed",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Given review comment below, line 79 `if (exception == null) ` changed to use eq.",
        "createdAt" : "2020-05-08T20:02:21Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!"
  },
  {
    "id" : "1e9b5e98-f1c7-4266-9d2d-785d3f29d779",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "cdd8dde6-8b9d-422d-8d57-468d7c29a611",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This test should use `eq`. Otherwise you're going to call `equals` for every `addSuppressed`, and that does not match the behavior of the JVM.",
        "createdAt" : "2020-05-07T18:07:30Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c48e759-a3d4-41f4-bd53-8a0ca68ec4dc",
        "parentId" : "cdd8dde6-8b9d-422d-8d57-468d7c29a611",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "line #85 changed as recommended.\r\n\r\nBased on this review comment, I swept through the code. In the places where the\r\njs original (from a couple of days ago) used eq, I now use eq.   In places where I added code, I now use eq.\r\n\r\nThe java original had 12 instances of `== null` and 7 instances of `eq null`.\r\nThe former seemed like they all could/should have been `eq`.  From lack of\r\nsufficient understanding, left those 12 as `==`  in this edit.\r\n\r\nPlease advise.  Thank you.",
        "createdAt" : "2020-05-08T20:07:12Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c5591c90-ff54-4d25-b6a7-74b2bc502c57",
        "parentId" : "cdd8dde6-8b9d-422d-8d57-468d7c29a611",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "If one of the sides is a *literal* `null`, `==` and `eq` are equivalent. So this is fine.",
        "createdAt" : "2020-05-09T16:48:00Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {"
  },
  {
    "id" : "5cdf6699-7420-41d2-aa95-ca7be37d0cce",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "54a9ae3d-5009-4638-9f9f-b7a007246b8b",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Prefer\r\n```suggestion\r\n      new Array[StackTraceElement](0) // as specified by Java 8.\r\n```\r\nwhich does not depend on Scala's `ClassTag`s. We should avoid to depend on anything Scala-specific in `Throwable`, which is a core class.",
        "createdAt" : "2020-05-07T18:18:03Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6da3878a-50d8-4198-8e2d-a77589fb1cba",
        "parentId" : "54a9ae3d-5009-4638-9f9f-b7a007246b8b",
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "Can `new Array[StackTraceElement](0) ` be shared?",
        "createdAt" : "2020-05-08T04:04:23Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0298ad72-2c2e-4e1c-bb69-e9a755c603e1",
        "parentId" : "54a9ae3d-5009-4638-9f9f-b7a007246b8b",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I'm afraid not. On the JVM `getStackTrace()` always returns a new array, which is not `eq` to other 0-arg arrays (even coming from the same instance).",
        "createdAt" : "2020-05-08T14:49:03Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "841d9085-d6a8-4254-b346-e2f53ba463fc",
        "parentId" : "54a9ae3d-5009-4638-9f9f-b7a007246b8b",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Changed as recommended.  I will use that practice in javalib code from now on, including responding to review.",
        "createdAt" : "2020-05-08T20:08:27Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n-    if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+    // Be robust! Test this.stackTrace against null rather than relying upon\n+    // the value of writableStackTrace.\n+    //\n+    // subclass scala.util.control.NoStackTrace overrides fillInStackTrace()\n+    // so that it never touches this.stackTrace. This creates the situation\n+    // where writeableStackTrace is true and this.stackTrace is null.\n+    //\n+    // If scala code creates this situation, then by the Gell-Mann principle\n+    // user code in the wild is bound to do so.\n+    //\n+    // If stackTrace is null, no profit to calling fillInStackTrace().\n+    // If writableStackTrace is true, then fillInStackTrace has already\n+    // been called in the constructor. If the stack is not writable, then\n+    // it can not be filled in.\n+\n+    if (stackTrace == null) {\n+      Array.empty[StackTraceElement] // as specified by Java 8."
  },
  {
    "id" : "dd5771aa-53ac-48ee-97fe-8edaf2356b19",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "9625af78-6793-4efd-8cfa-cf788c686192",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "AFAICT, this `synchronized` is unnecessary.",
        "createdAt" : "2020-05-07T18:20:25Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c3c6b5f8-4bb7-4645-b346-cae0033b6c6e",
        "parentId" : "9625af78-6793-4efd-8cfa-cf788c686192",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "I think an umpire's call is needed here.  I will follow your recommendation/requirement.\r\n\r\nI believe that Array clone is not-thread-safe.  At the least, I can add a comment \r\nto the `suppressed` variable that it is not thread-safe and any given Throwable should\r\nonly be used by in a single thread.  If I were taking a Concurrency exam, that would\r\nat least show that I had recognized the issue (and then punted it to future devos).\r\n\r\nScala Native currently follows the Scala.js  single threading model. \r\nI believe the synchronized is currently a call into a monitor method implemented as\r\na noop.  So, there is some execution cost and some review cognitive cost.\r\n\r\nFrom my Operating System network kernel days, I tend to write thread-safe code\r\nfrom the beginning because it is almost impossible to go back later and find the\r\nnon-thread-safe parts.   \r\n\r\nIt may be years in the future, but someday there will be customer pull for SN to\r\nbe multi-threaded.  I concur that currently SN has higher priority issues than\r\ninvesting huge amount of time in thread safety.\r\n\r\nI also believe that it would be a perverse & probably stupid multi-threaded\r\nprogram which tried to write the same (eq) Throwable from two or more threads.\r\n\r\n\r\nLarge parts of the java.concurrent package are only EventLoop safe, and are \r\ndocumented in the code as such.  I do not remember if the ReadTheDocs documents\r\ndescribe them as such.  I could check.\r\n\r\n",
        "createdAt" : "2020-05-08T19:03:00Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a6adb7a8-c0d1-4130-803f-042093c52c1c",
        "parentId" : "9625af78-6793-4efd-8cfa-cf788c686192",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I don't mean to say it's not necessary because synchronization is not necessary in general (otherwise I'd have recommended to remove *all* `synchronized`). But in this case I'm pretty sure it's not necessary.\r\n\r\n`clone()` is not thread-safe while mutating the original array. However, any array that is stored in the field `stackTrace` is never modified after it is stored there. Therefore, when you read an array from `stackTrace`, it is effectively immutable, and you can `clone()` it without synchronization.",
        "createdAt" : "2020-05-09T16:43:15Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "20dd6396-b45c-4f0b-8564-e9ea9667082e",
        "parentId" : "9625af78-6793-4efd-8cfa-cf788c686192",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Thank you for the patient explanation.  Changed as recommended. ",
        "createdAt" : "2020-05-10T01:48:04Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n-    if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+    // Be robust! Test this.stackTrace against null rather than relying upon\n+    // the value of writableStackTrace.\n+    //\n+    // subclass scala.util.control.NoStackTrace overrides fillInStackTrace()\n+    // so that it never touches this.stackTrace. This creates the situation\n+    // where writeableStackTrace is true and this.stackTrace is null.\n+    //\n+    // If scala code creates this situation, then by the Gell-Mann principle\n+    // user code in the wild is bound to do so.\n+    //\n+    // If stackTrace is null, no profit to calling fillInStackTrace().\n+    // If writableStackTrace is true, then fillInStackTrace has already\n+    // been called in the constructor. If the stack is not writable, then\n+    // it can not be filled in.\n+\n+    if (stackTrace == null) {\n+      Array.empty[StackTraceElement] // as specified by Java 8.\n+    } else\n+      this.synchronized {"
  },
  {
    "id" : "60531b28-3610-4100-ae58-00164fe8cef4",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "94b1de44-cf41-4359-96c9-bf3586b478c6",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "As above:\r\n```suggestion\r\n      new Array[Throwable](0)\r\n```",
        "createdAt" : "2020-05-07T18:20:53Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "048719ca-8fbe-40e8-a94b-1b6b197c85ea",
        "parentId" : "94b1de44-cf41-4359-96c9-bf3586b478c6",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Changed, thank you.",
        "createdAt" : "2020-05-08T20:08:44Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n-    if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+    // Be robust! Test this.stackTrace against null rather than relying upon\n+    // the value of writableStackTrace.\n+    //\n+    // subclass scala.util.control.NoStackTrace overrides fillInStackTrace()\n+    // so that it never touches this.stackTrace. This creates the situation\n+    // where writeableStackTrace is true and this.stackTrace is null.\n+    //\n+    // If scala code creates this situation, then by the Gell-Mann principle\n+    // user code in the wild is bound to do so.\n+    //\n+    // If stackTrace is null, no profit to calling fillInStackTrace().\n+    // If writableStackTrace is true, then fillInStackTrace has already\n+    // been called in the constructor. If the stack is not writable, then\n+    // it can not be filled in.\n+\n+    if (stackTrace == null) {\n+      Array.empty[StackTraceElement] // as specified by Java 8.\n+    } else\n+      this.synchronized {\n+        stackTrace.clone\n+      }\n   }\n \n-  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n-    var i = 0\n-    while (i < stackTrace.length) {\n-      if (stackTrace(i) eq null)\n-        throw new NullPointerException()\n-      i += 1\n+  final def getSuppressed(): Array[Throwable] = {\n+    if (suppressed == null) {\n+      Array.empty[Throwable]"
  },
  {
    "id" : "64500735-da93-4c15-8860-192010ee3b33",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "9eb48814-4aba-4fa7-b803-e49390aa1ec4",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The `synchronized` should also surround `if (suppressed == null)`, otherwise there can be an inconsistency.",
        "createdAt" : "2020-05-07T18:21:38Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d887c543-b684-42b4-83bc-8bbc59ea5bca",
        "parentId" : "9eb48814-4aba-4fa7-b803-e49390aa1ec4",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Changed as recommended. Thank you.",
        "createdAt" : "2020-05-08T20:09:03Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -49,49 +49,126 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _\n \n-  fillInStackTrace()\n+  if (writableStackTrace)\n+    fillInStackTrace()\n \n-  def initCause(cause: Throwable): Throwable = {\n-    e = cause\n-    this\n-  }\n+  // We use an Array rather than, say, a List, so that Throwable does not\n+  // depend on the Scala collections.\n+  private[this] var suppressed: Array[Throwable] = _\n \n-  def getMessage(): String = s\n+  final def addSuppressed(exception: Throwable): Unit = {\n \n-  def getCause(): Throwable = e\n+    if (exception == null) {\n+      // Yes, JVM message uses 'cannot' (sic) & has terminal period/full_stop!\n+      throw new java.lang.NullPointerException(\n+        \"Cannot suppress a null exception.\")\n+    }\n \n-  def getLocalizedMessage(): String = getMessage()\n+    if (exception == this) {\n+      throw new java.lang.IllegalArgumentException(\n+        \"Self-suppression not permitted\")\n+    }\n+\n+    if (enableSuppression) this.synchronized {\n+      if (suppressed eq null) {\n+        suppressed = Array(exception)\n+      } else {\n+        val length        = suppressed.length\n+        val newSuppressed = new Array[Throwable](length + 1)\n+        System.arraycopy(suppressed, 0, newSuppressed, 0, length)\n+        newSuppressed(length) = exception\n+        suppressed = newSuppressed\n+      }\n+    }\n+  }\n \n   def fillInStackTrace(): Throwable = {\n-    this.stackTrace = StackTrace.currentStackTrace()\n+    // currentStackTrace should be handling exclusion in its own\n+    // critical section, but does not. So do\n+    if (writableStackTrace) this.synchronized {\n+      this.stackTrace = StackTrace.currentStackTrace()\n+    }\n     this\n   }\n \n+  def getCause(): Throwable = e\n+\n+  def getLocalizedMessage(): String = getMessage()\n+\n+  def getMessage(): String = s\n+\n   def getStackTrace(): Array[StackTraceElement] = {\n-    if (stackTrace eq null) {\n-      stackTrace = Array.empty\n-    }\n-    stackTrace\n+    // Be robust! Test this.stackTrace against null rather than relying upon\n+    // the value of writableStackTrace.\n+    //\n+    // subclass scala.util.control.NoStackTrace overrides fillInStackTrace()\n+    // so that it never touches this.stackTrace. This creates the situation\n+    // where writeableStackTrace is true and this.stackTrace is null.\n+    //\n+    // If scala code creates this situation, then by the Gell-Mann principle\n+    // user code in the wild is bound to do so.\n+    //\n+    // If stackTrace is null, no profit to calling fillInStackTrace().\n+    // If writableStackTrace is true, then fillInStackTrace has already\n+    // been called in the constructor. If the stack is not writable, then\n+    // it can not be filled in.\n+\n+    if (stackTrace == null) {\n+      Array.empty[StackTraceElement] // as specified by Java 8.\n+    } else\n+      this.synchronized {\n+        stackTrace.clone\n+      }\n   }\n \n-  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n-    var i = 0\n-    while (i < stackTrace.length) {\n-      if (stackTrace(i) eq null)\n-        throw new NullPointerException()\n-      i += 1\n+  final def getSuppressed(): Array[Throwable] = {\n+    if (suppressed == null) {\n+      Array.empty[Throwable]\n+    } else\n+      this.synchronized {"
  },
  {
    "id" : "253222ef-5281-44b6-9232-2bb309204791",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "c06e82ef-7353-493b-9502-fbeb1d9143bc",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Please keep the original loop with `while` and `var` here, once again so that `Throwable` does not rely on the Scala library.",
        "createdAt" : "2020-05-07T18:27:26Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b398b76b-1116-44e6-b5a7-908ae3940b03",
        "parentId" : "c06e82ef-7353-493b-9502-fbeb1d9143bc",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "`while` loop restored.    I understand now why that is needed.   \r\n\r\nGuess that the Scala Coursera courses were pretty effective in discouraging use \r\nof `var` '-)  I understand this is a different context.\r\n\r\nI probably have `for` loops and other Scala Libaryisms scattered over all the\r\njavalib PRs I have open. I will keep my eye out for them (and try my best to not\r\nwrite them in new code).",
        "createdAt" : "2020-05-08T20:16:38Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -163,6 +240,25 @@ class Throwable(s: String, private var e: Throwable)\n     duplicates\n   }\n \n+  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n+\n+    if (stackTrace eq null) {\n+      throw new java.lang.NullPointerException()\n+    }\n+\n+    for (i <- 0 until stackTrace.length) {"
  },
  {
    "id" : "5abc3553-bf90-48a5-914e-e3d80dd5fd31",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "1a017e1b-0a3a-4256-b059-95ec72270d80",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The blank line here and at the end of the method are a tad too much, even for me who uses plenty of blank lines ;)",
        "createdAt" : "2020-05-07T18:29:21Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "045801ee-78ce-4181-80a1-8d77b5192178",
        "parentId" : "1a017e1b-0a3a-4256-b059-95ec72270d80",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "I swept through both files and removed blank lines after open-curly and before\r\nclose-curly.  There was one place in the Scala.js original which had a blank\r\nline after the open-curly, so I did not change that.\r\n\r\nI will use this style in code I am writing or changing from now on, including\r\nreviewed files.",
        "createdAt" : "2020-05-08T20:12:27Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -163,6 +240,25 @@ class Throwable(s: String, private var e: Throwable)\n     duplicates\n   }\n \n+  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n+"
  },
  {
    "id" : "b648f81d-4f94-4093-a5f7-bde03eebbb0f",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "79ba8070-8e02-4dc7-9534-e6822769c80e",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This is redundant. Accessing `stackTrace.length` will itself throw an NPE if `stackTrace` is `null`.",
        "createdAt" : "2020-05-07T18:30:04Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1434753f-aa4e-4c7a-b1f4-2efce06387fc",
        "parentId" : "79ba8070-8e02-4dc7-9534-e6822769c80e",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Removed, thank you.",
        "createdAt" : "2020-05-08T20:12:44Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : null,
    "diffHunk" : "@@ -163,6 +240,25 @@ class Throwable(s: String, private var e: Throwable)\n     duplicates\n   }\n \n+  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n+\n+    if (stackTrace eq null) {\n+      throw new java.lang.NullPointerException()\n+    }"
  },
  {
    "id" : "1d16fd58-a401-41c4-a199-6f0adcc456d6",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "6dd6d58c-04a7-466c-acd3-eb1c9caf4d6a",
        "parentId" : null,
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "extract to a consntant?",
        "createdAt" : "2020-05-09T16:35:10Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5301b2de-3a5f-4d10-9f6e-1c68d4d88b5e",
        "parentId" : "6dd6d58c-04a7-466c-acd3-eb1c9caf4d6a",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "It is used two places in the same method, none more generally. Original code had two literals. By training, I wanted to make sure both places used the same value.",
        "createdAt" : "2020-05-09T18:56:01Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 6,
    "diffHunk" : "@@ -10,15 +10,16 @@ private[lang] object StackTrace {\n \n   private def makeStackTraceElement(\n       cursor: Ptr[scala.Byte]): StackTraceElement = {\n-    val name   = stackalloc[CChar](1024)\n-    val offset = stackalloc[scala.Byte](8)\n+    val nameMax = 1024"
  },
  {
    "id" : "c0678d24-1918-4ab5-b041-267f8f865f26",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "bb731bb9-3e7b-49ec-8181-dd64944289e3",
        "parentId" : null,
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "private[this] will be dropped in dotty 3.1",
        "createdAt" : "2020-05-09T16:35:41Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ea1f0944-f9b7-466e-838a-f5774450403f",
        "parentId" : "bb731bb9-3e7b-49ec-8181-dd64944289e3",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "That's OK. We're a long way away from 3.1. In the meantime, `private[this]` produces less junk in the NIR than just `private`.",
        "createdAt" : "2020-05-09T16:40:46Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 42,
    "diffHunk" : "@@ -49,49 +50,123 @@ private[lang] object StackTrace {\n   }\n }\n \n-class Throwable(s: String, private var e: Throwable)\n+class Throwable protected (s: String,\n+                           private[this] var e: Throwable,\n+                           enableSuppression: scala.Boolean,\n+                           writableStackTrace: scala.Boolean)\n     extends Object\n     with java.io.Serializable {\n+\n+  def this(message: String, cause: Throwable) =\n+    this(message, cause, true, true)\n+\n   def this() = this(null, null)\n+\n   def this(s: String) = this(s, null)\n+\n   def this(e: Throwable) = this(if (e == null) null else e.toString, e)\n \n-  private var stackTrace: Array[StackTraceElement] = _\n+  private[this] var stackTrace: Array[StackTraceElement] = _"
  },
  {
    "id" : "d3105a2c-2d08-4497-bdee-93509aaebd64",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "cf25aa52-d146-43e5-93e0-7083f6e8013d",
        "parentId" : null,
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "when do `setStackTrace` should we take `writableStackTrace` into account? I think it's not.",
        "createdAt" : "2020-05-09T16:43:18Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 205,
    "diffHunk" : "@@ -163,6 +237,18 @@ class Throwable(s: String, private var e: Throwable)\n     duplicates\n   }\n \n+  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n+    if (writableStackTrace) this.synchronized {"
  },
  {
    "id" : "c1df7214-e5f4-444b-854a-bd0515147cfa",
    "prId" : 1688,
    "comments" : [
      {
        "id" : "baadd2cd-57d9-4009-8022-55eb2156b651",
        "parentId" : null,
        "author" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "body" : "any error message?",
        "createdAt" : "2020-05-09T16:44:12Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "hepin1989",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/501740?u=b0b4ebfd5fdd2e824196d92f212984038a65b942&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c158ba46-cd7c-428b-b60d-a8d1795faebd",
        "parentId" : "baadd2cd-57d9-4009-8022-55eb2156b651",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Sharp eyes,  I believe that NullPointerException supplies its own message. \r\n\r\nWhen I did the port, I tried to minimize changes the Scala.js original.  I am always\r\nwary of breaking things.   To the best of my memory, that code is preserved from the original. \r\n\r\nAdding custom message text is always a tradeoff: information added vs. the conceptual cost to devos & end users of being non-standard. I usually like to do the best that I\r\ncan to describe where an error happened. Mostly because I am likely to hit that error\r\nmyself and call down bad thoughts on the devo/\r\n\r\n The standard NPE is pretty clear & explicit. The accompanying stack trace gives the location where it happened.  I do not see what a custom message might add, but my\r\nvision may be limited.  ",
        "createdAt" : "2020-05-09T17:03:19Z",
        "updatedAt" : "2020-05-10T01:57:47Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20d5b073e304a4a23d9d690ae8ecea584dea987d",
    "line" : 209,
    "diffHunk" : "@@ -163,6 +237,18 @@ class Throwable(s: String, private var e: Throwable)\n     duplicates\n   }\n \n+  def setStackTrace(stackTrace: Array[StackTraceElement]): Unit = {\n+    if (writableStackTrace) this.synchronized {\n+      var i = 0\n+      while (i < stackTrace.length) {\n+        if (stackTrace(i) eq null)\n+          throw new NullPointerException()"
  }
]
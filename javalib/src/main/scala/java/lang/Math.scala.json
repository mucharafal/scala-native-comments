[
  {
    "id" : "fce73837-aa5f-42b0-87de-511b94a7ee72",
    "prId" : 203,
    "comments" : [
      {
        "id" : "9259916b-ee65-4a09-8241-f9f739ea0c21",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one I'm not sure if I understood the spec correctly. The javadoc speaks about \"magnitudes\", are those absolute values? \n",
        "createdAt" : "2016-06-26T18:29:15Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a7f099c8-57db-4173-bc60-b0d43f883e82",
        "parentId" : "9259916b-ee65-4a09-8241-f9f739ea0c21",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "You should be able to use the same implementation as Scala.js: https://github.com/scala-js/scala-js/blob/v0.6.10/javalanglib/src/main/scala/java/lang/Math.scala#L134 although it is a bit [under-tested](https://github.com/scala-js/scala-js/blob/v0.6.10/test-suite/shared/src/test/scala/org/scalajs/testsuite/javalib/lang/MathTest.scala#L130).\n",
        "createdAt" : "2016-06-26T18:51:13Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "52e67609-ad81-4343-8d08-ea24d7bc5aec",
        "parentId" : "9259916b-ee65-4a09-8241-f9f739ea0c21",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "\"magnitude\" is indeed the absolute value.\n",
        "createdAt" : "2016-06-26T18:52:52Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : 372,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {"
  },
  {
    "id" : "bce53562-91d9-46be-84ec-9754c5d7a221",
    "prId" : 203,
    "comments" : [
      {
        "id" : "be696b62-6531-4fd7-87f4-a6da48797965",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "There seems to exist an implementation of `log1p` in LLVM: https://github.com/chapuni/llvm-project/blob/master/libclc/generic/lib/math/log1p.cl\nMaybe not a built-in, but worth looking into whether you can call that.\n\n`log(a + 1)` can suffer from imprecisions wrt. its documented guarantees. (and yes, I know the Scala.js implementation also uses `log(a + 1)`, and it's not quite right).\n",
        "createdAt" : "2016-06-26T18:47:31Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6da6ecd2-3e02-4ad1-95a9-198c8533eeb7",
        "parentId" : "be696b62-6531-4fd7-87f4-a6da48797965",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "There is actually a log1p in C's `math.h`, I just missed it. \n",
        "createdAt" : "2016-06-27T11:25:27Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)"
  },
  {
    "id" : "cd4dede4-934a-47dc-b77f-baa46dd95922",
    "prId" : 203,
    "comments" : [
      {
        "id" : "ce1e4679-da16-4939-a62e-fe99004d937f",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This is equivalent to `a == 0f && b == 0d`, because `-0.0 == 0.0`\n",
        "createdAt" : "2016-06-26T18:55:38Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {"
  },
  {
    "id" : "a3973616-f7b8-49bd-8888-834d4f08d170",
    "prId" : 203,
    "comments" : [
      {
        "id" : "8139f789-6149-439d-9016-6e541d67d983",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "You should probably compute `val aabs = abs(a.toDouble)` and `val babs = abs(b)` once at the beginning of the function. Or even\n\n``` scala\nval aDouble = a.toDouble\nval aabs = abs(aDouble)\nval babs = abs(b)\n```\n",
        "createdAt" : "2016-06-26T18:57:51Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }"
  },
  {
    "id" : "213b3a3e-d503-4165-bcf4-de015bf5bf9b",
    "prId" : 203,
    "comments" : [
      {
        "id" : "f392313d-547b-45f7-91b7-b7d6cb47e30f",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I am not sure this is correct. In fact, I'm pretty sure it isn't.\n\nSince doubles have a much higher precision, `nextafter(a.toDouble, b)` will be 1 up _in terms of doubles_. Converting that back into float will probably just round it down to the original float.\n",
        "createdAt" : "2016-06-26T18:59:51Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "642c3b4c-b065-4811-8265-30691e8ee4ce",
        "parentId" : "f392313d-547b-45f7-91b7-b7d6cb47e30f",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I see that in `nextDown` you use `nextafterf` for floats. I guess you should use that one here, too.\n",
        "createdAt" : "2016-06-26T19:03:53Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "49b048b9-1635-4192-b9d3-e4b1e75be8dc",
        "parentId" : "f392313d-547b-45f7-91b7-b7d6cb47e30f",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "C has its own funny way of dealing with corner cases here:\n\n``` scala\nError handling\n\nErrors are reported as specified in math_errhandling.\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\nif from is finite, but the expected result is an infinity, raises FE_INEXACT and FE_OVERFLOW\nif from does not equal to and the result is subnormal or zero, raises FE_INEXACT and FE_UNDERFLOW\nin any case, the returned value is independent of the current rounding mode\nif either from or to is NaN, NaN is returned\n```\n\nI don't think that we should rely on that.\n",
        "createdAt" : "2016-06-27T09:58:35Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat"
  },
  {
    "id" : "4e1591c5-8767-47ee-abe6-9b3343716e66",
    "prId" : 203,
    "comments" : [
      {
        "id" : "6f40e05c-01af-4589-9706-dcf2074c7e52",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Doesn't LLVM's `nextafter` do the right thing for the \"specials\" (NaN, Infinities and zeros)?\n",
        "createdAt" : "2016-06-26T19:02:41Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)"
  },
  {
    "id" : "06f4ad14-135f-4006-83b4-f10d9667b1b8",
    "prId" : 203,
    "comments" : [
      {
        "id" : "be0ab369-f510-42be-96b4-0ba8a3a7ba54",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This whole method can simply be `nextAfter(a, Float.NEGATIVE_INFINITY`. There's no need for the special cases for the specials.\n",
        "createdAt" : "2016-06-26T19:05:55Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }"
  },
  {
    "id" : "1b27260a-04f0-40b6-ab99-b5951aed26d4",
    "prId" : 203,
    "comments" : [
      {
        "id" : "7e16a33a-afb3-4758-8732-18d8d12bec64",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This whole method can simply be `nextAfter(a, Double.NEGATIVE_INFINITY`. There's no need for the special cases for the specials.\n",
        "createdAt" : "2016-06-26T19:06:06Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextDown(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.NEGATIVE_INFINITY) {\n+      Double.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.NEGATIVE_INFINITY)\n+    }"
  },
  {
    "id" : "6563dfa9-4d94-4635-ba2d-8219e509ddb3",
    "prId" : 203,
    "comments" : [
      {
        "id" : "2569b3c2-5775-448a-a627-fa17a53200e1",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Same, can be `nextAfter(a, Float.POSITIVE_INFINITY)`\n",
        "createdAt" : "2016-06-26T19:06:24Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextDown(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.NEGATIVE_INFINITY) {\n+      Double.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Integer.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.POSITIVE_INFINITY) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.POSITIVE_INFINITY)\n     }"
  },
  {
    "id" : "adeb2e12-0af1-4225-bcf2-73363a89231f",
    "prId" : 203,
    "comments" : [
      {
        "id" : "1bacbd44-03a1-470d-9eab-19221eafa34b",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Same, can be Same, can be `nextAfter(a, Double.POSITIVE_INFINITY)`\n",
        "createdAt" : "2016-06-26T19:06:34Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextDown(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.NEGATIVE_INFINITY) {\n+      Double.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Integer.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.POSITIVE_INFINITY) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.POSITIVE_INFINITY)\n     }\n-    if (!overflow) a * b\n-    else throw new ArithmeticException(\"Integer overflow\")\n   }\n \n-  def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Long.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.POSITIVE_INFINITY) {\n+      Double.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.POSITIVE_INFINITY)\n     }"
  },
  {
    "id" : "bf317c5a-bd77-4001-abed-b242ce5d2333",
    "prId" : 203,
    "comments" : [
      {
        "id" : "ee60661b-05c9-4c9a-bdcb-dff725d1a93e",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I suggest you precompute that in a Scala REPL and hard-code the constant.\n",
        "createdAt" : "2016-06-26T19:09:00Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextDown(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.NEGATIVE_INFINITY) {\n+      Double.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Integer.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.POSITIVE_INFINITY) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.POSITIVE_INFINITY)\n     }\n-    if (!overflow) a * b\n-    else throw new ArithmeticException(\"Integer overflow\")\n   }\n \n-  def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Long.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.POSITIVE_INFINITY) {\n+      Double.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.POSITIVE_INFINITY)\n     }\n-    if (!overflow) a * b\n-    else throw new ArithmeticException(\"Long overflow\")\n   }\n \n-  def incrementExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MAX_VALUE) a + 1\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.pow.f64`(a, b)\n \n-  def incrementExact(a: scala.Long): scala.Long =\n-    if (a != Long.MAX_VALUE) a + 1\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def random(): scala.Double =\n+    rand.nextDouble()\n \n-  def decrementExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MIN_VALUE) a - 1\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def rint(a: scala.Double): scala.Double =\n+    `llvm.rint.f64`(a)\n \n-  def decrementExact(a: scala.Long): scala.Long =\n-    if (a != Long.MIN_VALUE) a - 1\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def round(a: scala.Float): scala.Int =\n+    `llvm.round.f32`(a).toInt\n \n-  def negateExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MIN_VALUE) -a\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def round(a: scala.Double): scala.Long =\n+    `llvm.round.f64`(a).toLong\n \n-  def negateExact(a: scala.Long): scala.Long =\n-    if (a != Long.MIN_VALUE) -a\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def scalb(a: scala.Float, scaleFactor: scala.Int): scala.Float =\n+    cmath.scalbnf(a, scaleFactor)\n \n-  def toIntExact(a: scala.Long): scala.Int =\n-    if (a >= Integer.MIN_VALUE && a <= Integer.MAX_VALUE) a.toInt\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def scalb(a: scala.Double, scaleFactor: scala.Int): scala.Double =\n+    cmath.scalbn(a, scaleFactor)\n \n-  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n-    val quot = a / b\n-    if ((a < 0) == (b < 0) || quot * b == a) quot\n-    else quot - 1\n+  @inline def signum(a: scala.Float): scala.Float = {\n+    if (a > 0) 1.0f\n+    else if (a < 0) -1.0f\n+    else a\n   }\n \n-  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n-    val quot = a / b\n-    if ((a < 0) == (b < 0) || quot * b == a) quot\n-    else quot - 1\n+  @inline def signum(a: scala.Double): scala.Double = {\n+    if (a > 0) 1.0\n+    else if (a < 0) -1.0\n+    else a\n   }\n \n-  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n-    val rem = a % b\n-    if ((a < 0) == (b < 0) || rem == 0) rem\n-    else rem + b\n+  @inline def sin(a: scala.Double): scala.Double =\n+    `llvm.sin.f64`(a)\n+\n+  @inline def sinh(a: scala.Double): scala.Double =\n+    cmath.sinh(a)\n+\n+  @inline def sqrt(a: scala.Double): scala.Double =\n+    `llvm.sqrt.f64`(a)\n+\n+  @inline def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.ssub.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n-    val rem = a % b\n-    if ((a < 0) == (b < 0) || rem == 0) rem\n-    else rem + b\n+  @inline def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.ssub.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n-    `llvm.copysign.f32`(magnitude, sign)\n+  @inline def tan(a: scala.Double): scala.Double =\n+    cmath.tan(a)\n \n-  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n-    `llvm.copysign.f64`(magnitude, sign)\n+  @inline def tanh(a: scala.Double): scala.Double =\n+    cmath.tanh(a)\n+\n+  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n+\n+  def toIntExact(a: scala.Long): scala.Int =\n+    if (a >= Integer.MIN_VALUE && a <= Integer.MAX_VALUE) a.toInt\n+    else throw new ArithmeticException(\"Integer overflow\")\n \n-  // TODO\n-  // def IEEEremainder(f1: scala.Double, f2: scala.Double): Double\n-  // def ulp(a: scala.Float): scala.Float\n-  // def getExponent(a: scala.Float): scala.Int\n-  // def getExponent(a: scala.Double): scala.Int\n-  // def nextAfter(a: scala.Float, b: scala.Double): scala.Float\n-  // def nextUp(a: scala.Float): scala.Float\n-  // def nextDown(a: scala.Double): scala.Double\n-  // def nextDown(a: scala.Float): scala.Float\n-  // def scalb(a: scala.Double, scalaFactor: scala.Int): scala.Double\n-  // def scalb(a: scala.Float, scalaFactor: scala.Int): scala.Float\n+  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+\n+  def ulp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (Float.isInfinite(a)) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == Float.MAX_VALUE) {\n+      pow(2, 104).toFloat"
  },
  {
    "id" : "878e7c32-e41c-4528-a943-b669a3f00691",
    "prId" : 203,
    "comments" : [
      {
        "id" : "57080b8e-4532-4e59-b03e-4f12b9304331",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Same here. Hard-code the constant.\n",
        "createdAt" : "2016-06-26T19:09:23Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,347 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n+\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n+\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n+\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    log(a + 1)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b.toFloat\n+    } else if (abs(a) == Float.MIN_VALUE && abs(b) < abs(a.toDouble)) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && abs(b) < abs(a.toDouble)) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (abs(a) == Float.MAX_VALUE && abs(b) > abs(a.toDouble)) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a.toDouble, b).toFloat\n+    }\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (Double.isNaN(a) || Double.isNaN(b)) {\n+      Double.NaN\n+    } else if (abs(a) == 0f && abs(b) == 0d) {\n+      b\n+    } else if (abs(a) == Double.MIN_VALUE && abs(b) < abs(a)) {\n+      copySign(0, a)\n+    } else if (Double.isInfinite(a) && abs(b) < abs(a)) {\n+      copySign(Double.MAX_VALUE, a)\n+    } else if (abs(a) == Double.MAX_VALUE && abs(b) > abs(a)) {\n+      copySign(Double.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafter(a, b)\n+    }\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def nextDown(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.NEGATIVE_INFINITY) {\n+      Float.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def nextDown(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.NEGATIVE_INFINITY) {\n+      Double.NEGATIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      -Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.NEGATIVE_INFINITY)\n+    }\n   }\n \n-  def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Integer.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (a == Float.POSITIVE_INFINITY) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Float.MIN_VALUE\n+    } else {\n+      cmath.nextafterf(a, Float.POSITIVE_INFINITY)\n     }\n-    if (!overflow) a * b\n-    else throw new ArithmeticException(\"Integer overflow\")\n   }\n \n-  def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Long.MIN_VALUE\n-      else\n-        false\n+  def nextUp(a: scala.Double): scala.Double = {\n+    if (Double.isNaN(a)) {\n+      Double.NaN\n+    } else if (a == Double.POSITIVE_INFINITY) {\n+      Double.POSITIVE_INFINITY\n+    } else if (abs(a) == 0f) {\n+      Double.MIN_VALUE\n+    } else {\n+      cmath.nextafter(a, Double.POSITIVE_INFINITY)\n     }\n-    if (!overflow) a * b\n-    else throw new ArithmeticException(\"Long overflow\")\n   }\n \n-  def incrementExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MAX_VALUE) a + 1\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.pow.f64`(a, b)\n \n-  def incrementExact(a: scala.Long): scala.Long =\n-    if (a != Long.MAX_VALUE) a + 1\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def random(): scala.Double =\n+    rand.nextDouble()\n \n-  def decrementExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MIN_VALUE) a - 1\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def rint(a: scala.Double): scala.Double =\n+    `llvm.rint.f64`(a)\n \n-  def decrementExact(a: scala.Long): scala.Long =\n-    if (a != Long.MIN_VALUE) a - 1\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def round(a: scala.Float): scala.Int =\n+    `llvm.round.f32`(a).toInt\n \n-  def negateExact(a: scala.Int): scala.Int =\n-    if (a != Integer.MIN_VALUE) -a\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def round(a: scala.Double): scala.Long =\n+    `llvm.round.f64`(a).toLong\n \n-  def negateExact(a: scala.Long): scala.Long =\n-    if (a != Long.MIN_VALUE) -a\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def scalb(a: scala.Float, scaleFactor: scala.Int): scala.Float =\n+    cmath.scalbnf(a, scaleFactor)\n \n-  def toIntExact(a: scala.Long): scala.Int =\n-    if (a >= Integer.MIN_VALUE && a <= Integer.MAX_VALUE) a.toInt\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def scalb(a: scala.Double, scaleFactor: scala.Int): scala.Double =\n+    cmath.scalbn(a, scaleFactor)\n \n-  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n-    val quot = a / b\n-    if ((a < 0) == (b < 0) || quot * b == a) quot\n-    else quot - 1\n+  @inline def signum(a: scala.Float): scala.Float = {\n+    if (a > 0) 1.0f\n+    else if (a < 0) -1.0f\n+    else a\n   }\n \n-  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n-    val quot = a / b\n-    if ((a < 0) == (b < 0) || quot * b == a) quot\n-    else quot - 1\n+  @inline def signum(a: scala.Double): scala.Double = {\n+    if (a > 0) 1.0\n+    else if (a < 0) -1.0\n+    else a\n   }\n \n-  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n-    val rem = a % b\n-    if ((a < 0) == (b < 0) || rem == 0) rem\n-    else rem + b\n+  @inline def sin(a: scala.Double): scala.Double =\n+    `llvm.sin.f64`(a)\n+\n+  @inline def sinh(a: scala.Double): scala.Double =\n+    cmath.sinh(a)\n+\n+  @inline def sqrt(a: scala.Double): scala.Double =\n+    `llvm.sqrt.f64`(a)\n+\n+  @inline def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.ssub.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n-    val rem = a % b\n-    if ((a < 0) == (b < 0) || rem == 0) rem\n-    else rem + b\n+  @inline def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.ssub.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n-    `llvm.copysign.f32`(magnitude, sign)\n+  @inline def tan(a: scala.Double): scala.Double =\n+    cmath.tan(a)\n \n-  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n-    `llvm.copysign.f64`(magnitude, sign)\n+  @inline def tanh(a: scala.Double): scala.Double =\n+    cmath.tanh(a)\n+\n+  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n+\n+  def toIntExact(a: scala.Long): scala.Int =\n+    if (a >= Integer.MIN_VALUE && a <= Integer.MAX_VALUE) a.toInt\n+    else throw new ArithmeticException(\"Integer overflow\")\n \n-  // TODO\n-  // def IEEEremainder(f1: scala.Double, f2: scala.Double): Double\n-  // def ulp(a: scala.Float): scala.Float\n-  // def getExponent(a: scala.Float): scala.Int\n-  // def getExponent(a: scala.Double): scala.Int\n-  // def nextAfter(a: scala.Float, b: scala.Double): scala.Float\n-  // def nextUp(a: scala.Float): scala.Float\n-  // def nextDown(a: scala.Double): scala.Double\n-  // def nextDown(a: scala.Float): scala.Float\n-  // def scalb(a: scala.Double, scalaFactor: scala.Int): scala.Double\n-  // def scalb(a: scala.Float, scalaFactor: scala.Int): scala.Float\n+  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+\n+  def ulp(a: scala.Float): scala.Float = {\n+    if (Float.isNaN(a)) {\n+      Float.NaN\n+    } else if (Float.isInfinite(a)) {\n+      Float.POSITIVE_INFINITY\n+    } else if (abs(a) == Float.MAX_VALUE) {\n+      pow(2, 104).toFloat\n+    } else {\n+      val f = abs(a)\n+      cmath.nextafterf(f, Float.MAX_VALUE) - f\n+    }\n+  }\n+\n+  def ulp(a: scala.Double): scala.Double = {\n+    if (Double.isInfinite(a)) {\n+      scala.Double.PositiveInfinity\n+    } else if (a == scala.Double.MaxValue || a == -Double.MAX_VALUE) {\n+      pow(2, 971)"
  },
  {
    "id" : "3c34c32a-d4a0-4a80-81c6-346eebf0e871",
    "prId" : 203,
    "comments" : [
      {
        "id" : "91c62e48-08c8-4956-980d-d456addd12af",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Hum. Now that I see it written like that, I think there's also a similar problem, but reversed. Let's say I compute `nextAfter(1.5f, nextUp(1.5))`. In that case, `b > a`, so the result should be `nextUp(1.5f)`. However, `b.toFloat` rounds back down to `1.5f`, and therefore `cmath.nextafterf(a, b.toFloat)` will return `1.5f` instead.\n\nExperiment on the JVM:\n\n``` scala\nscala> Math.nextAfter(1.5f, Math.nextUp(1.5))\nres0: Float = 1.5000001\n\nscala> Math.nextAfter(1.5f, Math.nextUp(1.5).toFloat)\nres1: Float = 1.5\n```\n\nSo I guess you should explicitly perform\n\n``` scala\nif (b > a) cmath.nextafterf(a, Float.POSITIVE_INFINITY)\nelse cmath.nextafterf(a, Float.NEGATIVE_INFINITY)\n```\n\nor something like that :-s\n",
        "createdAt" : "2016-06-27T11:36:40Z",
        "updatedAt" : "2016-06-27T11:41:14Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04a642a7-69d0-4f80-a7a8-eb3b1021b596",
        "parentId" : "91c62e48-08c8-4956-980d-d456addd12af",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Done.\n",
        "createdAt" : "2016-06-27T11:41:26Z",
        "updatedAt" : "2016-06-27T11:41:26Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cc5ac537282a550ff3e73d467af15f492923f0dc",
    "line" : null,
    "diffHunk" : "@@ -1,324 +1,317 @@\n package java.lang\n \n import scalanative.runtime.Intrinsics._\n+import scalanative.native.{math => cmath}\n \n object Math {\n+  private lazy val rand = new java.util.Random\n+\n   final val E  = 2.718281828459045\n   final val PI = 3.141592653589793\n \n-  @inline def abs(a: scala.Int): scala.Int       = if (a < 0) -a else a\n-  @inline def abs(a: scala.Long): scala.Long     = if (a < 0) -a else a\n-  @inline def abs(a: scala.Float): scala.Float   = `llvm.fabs.f32`(a)\n-  @inline def abs(a: scala.Double): scala.Double = `llvm.fabs.f64`(a)\n+  @inline def abs(a: scala.Double): scala.Double =\n+    `llvm.fabs.f64`(a)\n \n-  @inline def max(a: scala.Int, b: scala.Int): scala.Int = if (a > b) a else b\n-  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a > b) a else b\n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Float): scala.Float =\n+    `llvm.fabs.f32`(a)\n \n-  @inline def min(a: scala.Int, b: scala.Int): scala.Int = if (a < b) a else b\n-  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n-    if (a < b) a else b\n-  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.minnum.f32`(a, b)\n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def abs(a: scala.Int): scala.Int =\n+    if (a < 0) -a else a\n \n-  @inline def ceil(a: scala.Double): scala.Double  = `llvm.ceil.f64`(a)\n-  @inline def floor(a: scala.Double): scala.Double = `llvm.floor.f64`(a)\n-  @inline def rint(a: scala.Double): scala.Double  = `llvm.rint.f64`(a)\n+  @inline def abs(a: scala.Long): scala.Long =\n+    if (a < 0) -a else a\n \n-  @inline def round(a: scala.Float): scala.Int   = `llvm.round.f32`(a).toInt\n-  @inline def round(a: scala.Double): scala.Long = `llvm.round.f64`(a).toLong\n+  @inline def acos(a: scala.Double): scala.Double =\n+    cmath.acos(a)\n \n-  @inline def sqrt(a: scala.Double): scala.Double = `llvm.sqrt.f64`(a)\n-  @inline def pow(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.pow.f64`(a, b)\n+  @inline def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.sadd.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def exp(a: scala.Double): scala.Double   = `llvm.exp.f64`(a)\n-  @inline def log(a: scala.Double): scala.Double   = `llvm.log.f64`(a)\n-  @inline def log10(a: scala.Double): scala.Double = `llvm.log10.f64`(a)\n-  @inline def log1p(a: scala.Double): scala.Double = log(a + 1)\n+  @inline def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.sadd.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n+  }\n \n-  @inline def sin(a: scala.Double): scala.Double                    = `llvm.sin.f64`(a)\n-  @inline def cos(a: scala.Double): scala.Double                    = `llvm.cos.f64`(a)\n-  @inline def tan(a: scala.Double): scala.Double                    = ???\n-  @inline def asin(a: scala.Double): scala.Double                   = ???\n-  @inline def acos(a: scala.Double): scala.Double                   = ???\n-  @inline def atan(a: scala.Double): scala.Double                   = ???\n-  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double = ???\n+  @inline def asin(a: scala.Double): scala.Double =\n+    cmath.asin(a)\n \n-  @inline def random(): scala.Double = ???\n+  @inline def atan(a: scala.Double): scala.Double =\n+    cmath.atan(a)\n \n-  @inline def toDegrees(a: scala.Double): scala.Double = a * 180.0 / PI\n-  @inline def toRadians(a: scala.Double): scala.Double = a / 180.0 * PI\n+  @inline def atan2(y: scala.Double, x: scala.Double): scala.Double =\n+    cmath.atan2(y, x)\n \n-  @inline def signum(a: scala.Double): scala.Double = {\n-    if (a > 0) 1.0\n-    else if (a < 0) -1.0\n-    else a\n-  }\n+  @inline def cbrt(a: scala.Double): scala.Double =\n+    cmath.cbrt(a)\n \n-  @inline def signum(a: scala.Float): scala.Float = {\n-    if (a > 0) 1.0f\n-    else if (a < 0) -1.0f\n-    else a\n-  }\n+  @inline def ceil(a: scala.Double): scala.Double =\n+    `llvm.ceil.f64`(a)\n \n-  def cbrt(a: scala.Double): scala.Double = ???\n-\n-  def nextUp(a: scala.Double): scala.Double = {\n-    // js implementation of nextUp https://gist.github.com/Yaffle/4654250\n-    import scala.Double._\n-    if (a != a || a == PositiveInfinity)\n-      a\n-    else if (a == NegativeInfinity)\n-      MinValue\n-    else if (a == MaxValue)\n-      PositiveInfinity\n-    else if (a == 0)\n-      MinPositiveValue\n-    else {\n-      def iter(\n-          x: scala.Double, xi: scala.Double, n: scala.Double): scala.Double = {\n-        if (Math.abs(xi - x) >= 1E-16) {\n-          val c0 = (xi + x) / 2\n-          val c =\n-            if (c0 == NegativeInfinity || c0 == PositiveInfinity)\n-              x + (xi - x) / 2\n-            else\n-              c0\n-          if (n == c) xi\n-          else if (a < c) iter(x = x, xi = c, n = c)\n-          else iter(x = c, xi = xi, n = c)\n-        } else xi\n-      }\n-      val d  = Math.max(Math.abs(a) * 2E-16, MinPositiveValue)\n-      val ad = a + d\n-      val xi0 =\n-        if (ad == PositiveInfinity) MaxValue\n-        else ad\n-      iter(x = a, xi = xi0, n = a)\n-    }\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Double, sign: scala.Double): scala.Double =\n+    `llvm.copysign.f64`(magnitude, sign)\n \n-  def nextAfter(a: scala.Double, b: scala.Double): scala.Double = {\n-    if (b < a)\n-      -nextUp(-a)\n-    else if (a < b)\n-      nextUp(a)\n-    else if (a != a || b != b)\n-      scala.Double.NaN\n-    else\n-      b\n-  }\n+  @inline\n+  def copySign(magnitude: scala.Float, sign: scala.Float): scala.Float =\n+    `llvm.copysign.f32`(magnitude, sign)\n \n-  def ulp(a: scala.Double): scala.Double = {\n-    if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (abs(a) == scala.Double.MaxValue)\n-      pow(2, 971)\n-    else\n-      nextAfter(abs(a), scala.Double.MaxValue) - a\n-  }\n+  @inline def cos(a: scala.Double): scala.Double =\n+    `llvm.cos.f64`(a)\n \n-  def hypot(a: scala.Double, b: scala.Double): scala.Double = {\n-    // http://en.wikipedia.org/wiki/Hypot#Implementation\n-    if (abs(a) == scala.Double.PositiveInfinity ||\n-        abs(b) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else if (a.isNaN || b.isNaN)\n-      scala.Double.NaN\n-    else if (a == 0 && b == 0)\n-      0.0\n-    else {\n-      //To Avoid Overflow and UnderFlow\n-      // calculate |x| * sqrt(1 - (y/x)^2) instead of sqrt(x^2 + y^2)\n-      val x = abs(a)\n-      val y = abs(b)\n-      val m = max(x, y)\n-      val t = min(x, y) / m\n-      m * sqrt(1 + t * t)\n-    }\n-  }\n+  @inline def cosh(a: scala.Double): scala.Double =\n+    cmath.cosh(a)\n \n-  def expm1(a: scala.Double): scala.Double = {\n-    // https://github.com/ghewgill/picomath/blob/master/javascript/expm1.js\n-    if (a == 0 || a.isNaN)\n-      a\n-    // Power Series http://en.wikipedia.org/wiki/Power_series\n-    // for small values of a, exp(a) = 1 + a + (a*a)/2\n-    else if (abs(a) < 1E-5)\n-      a + 0.5 * a * a\n-    else\n-      exp(a) - 1.0\n-  }\n+  @inline def decrementExact(a: scala.Int): scala.Int =\n+    subtractExact(a, 1)\n \n-  def sinh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0 || abs(a) == scala.Double.PositiveInfinity)\n-      a\n-    else\n-      (exp(a) - exp(-a)) / 2.0\n-  }\n+  @inline def decrementExact(a: scala.Long): scala.Long =\n+    subtractExact(a, 1L)\n \n-  def cosh(a: scala.Double): scala.Double = {\n-    if (a.isNaN)\n-      a\n-    else if (a == 0.0)\n-      1.0\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      scala.Double.PositiveInfinity\n-    else\n-      (exp(a) + exp(-a)) / 2.0\n+  @inline def exp(a: scala.Double): scala.Double =\n+    `llvm.exp.f64`(a)\n+\n+  @inline def expm1(a: scala.Double): scala.Double =\n+    cmath.expm1(a)\n+\n+  @inline def floor(a: scala.Double): scala.Double =\n+    `llvm.floor.f64`(a)\n+\n+  def floorDiv(a: scala.Int, b: scala.Int): scala.Int = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def tanh(a: scala.Double): scala.Double = {\n-    if (a.isNaN || a == 0.0)\n-      a\n-    else if (abs(a) == scala.Double.PositiveInfinity)\n-      signum(a)\n-    else {\n-      // sinh(a) / cosh(a) =\n-      // 1 - 2 * (exp(-a)/ (exp(-a) + exp (a)))\n-      val expma = exp(-a)\n-      if (expma == scala.Double.PositiveInfinity) //Infinity / Infinity\n-        -1.0\n-      else {\n-        val expa = exp(a)\n-        val ret  = expma / (expa + expma)\n-        1.0 - (2.0 * ret)\n-      }\n-    }\n+  def floorDiv(a: scala.Long, b: scala.Long): scala.Long = {\n+    val quot = a / b\n+    if ((a < 0) == (b < 0) || quot * b == a) quot\n+    else quot - 1\n   }\n \n-  def addExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  def floorMod(a: scala.Int, b: scala.Int): scala.Int = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def addExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a + b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b < 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  def floorMod(a: scala.Long, b: scala.Long): scala.Long = {\n+    val rem = a % b\n+    if ((a < 0) == (b < 0) || rem == 0) rem\n+    else rem + b\n   }\n \n-  def subtractExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Integer overflow\")\n+  @inline def getExponent(a: scala.Float): scala.Int =\n+    cmath.ilogbf(a)\n+\n+  @inline def getExponent(a: scala.Double): scala.Long =\n+    cmath.ilogb(a)\n+\n+  @inline def hypot(a: scala.Double, b: scala.Double): scala.Double =\n+    cmath.hypot(a, b)\n+\n+  @inline def IEEEremainder(f1: scala.Double, f2: scala.Double): Double =\n+    cmath.remainder(f1, f2)\n+\n+  @inline def incrementExact(a: scala.Int): scala.Int =\n+    addExact(a, 1)\n+\n+  @inline def incrementExact(a: scala.Long): scala.Long =\n+    addExact(a, 1L)\n+\n+  @inline def log(a: scala.Double): scala.Double =\n+    `llvm.log.f64`(a)\n+\n+  @inline def log10(a: scala.Double): scala.Double =\n+    `llvm.log10.f64`(a)\n+\n+  @inline def log1p(a: scala.Double): scala.Double =\n+    cmath.log1p(a)\n+\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.maxnum.f32`(a, b)\n+\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a > b) a else b\n+\n+  @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a > b) a else b\n+\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n+    `llvm.maxnum.f64`(a, b)\n+\n+  @inline def min(a: scala.Float, b: scala.Float): scala.Float =\n+    `llvm.minnum.f32`(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    if (a < b) a else b\n+\n+  @inline def min(a: scala.Long, b: scala.Long): scala.Long =\n+    if (a < b) a else b\n+\n+  @inline def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n+    val overflow = `llvm.smul.with.overflow.i32`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Integer overflow\")\n+    else overflow.value\n   }\n \n-  def subtractExact(a: scala.Long, b: scala.Long): scala.Long = {\n-    val res       = a - b\n-    val resSgnBit = res < 0\n-    if (resSgnBit == (a < 0) || resSgnBit == (b > 0)) res\n-    else throw new ArithmeticException(\"Long overflow\")\n+  @inline def multiplyExact(a: scala.Long, b: scala.Long): scala.Long = {\n+    val overflow = `llvm.smul.with.overflow.i64`(a, b)\n+    if (overflow.flag) throw new ArithmeticException(\"Long overflow\")\n+    else overflow.value\n   }\n \n-  def multiplyExact(a: scala.Int, b: scala.Int): scala.Int = {\n-    val overflow = {\n-      if (b > 0)\n-        a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b\n-      else if (b < -1)\n-        a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b\n-      else if (b == -1)\n-        a == Integer.MIN_VALUE\n-      else\n-        false\n+  @inline def negateExact(a: scala.Int): scala.Int =\n+    subtractExact(0, a)\n+\n+  @inline def negateExact(a: scala.Long): scala.Long =\n+    subtractExact(0, a)\n+\n+  def nextAfter(a: scala.Float, b: scala.Double): scala.Float = {\n+    val aabs = abs(a.toDouble)\n+    val babs = abs(b)\n+\n+    if (Float.isNaN(a) || Double.isNaN(b)) {\n+      Float.NaN\n+    } else if (aabs == 0f && babs == 0d) {\n+      b.toFloat\n+    } else if (aabs == Float.MIN_VALUE && babs < aabs) {\n+      copySign(0, a)\n+    } else if (Float.isInfinite(a) && babs < aabs) {\n+      copySign(Float.MAX_VALUE, a)\n+    } else if (aabs == Float.MAX_VALUE && babs > aabs) {\n+      copySign(Float.POSITIVE_INFINITY, a)\n+    } else {\n+      cmath.nextafterf(a, b.toFloat)"
  },
  {
    "id" : "0e3978e6-b2d0-494b-a7ec-de4ebab0e886",
    "prId" : 1307,
    "comments" : [
      {
        "id" : "9843bbb2-c3b8-4bef-9f63-6759269536db",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "We typically don't use curlies if body is single-line. ",
        "createdAt" : "2018-10-17T11:34:53Z",
        "updatedAt" : "2019-03-09T16:57:25Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a6bc48d1-e69a-44a1-80b9-ba47b15f21bf",
        "parentId" : "9843bbb2-c3b8-4bef-9f63-6759269536db",
        "author" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "body" : "Changes made as requested",
        "createdAt" : "2018-12-02T19:40:04Z",
        "updatedAt" : "2019-03-09T16:57:25Z",
        "lastEditedBy" : {
          "login" : "LeeTibbert",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/12221035?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "68ed063cdb104a919d4b37302f4b1e66c7579e34",
    "line" : null,
    "diffHunk" : "@@ -131,23 +131,27 @@ object Math {\n   @inline def log1p(a: scala.Double): scala.Double =\n     cmath.log1p(a)\n \n-  @inline def max(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.maxnum.f64`(a, b)\n+  @inline def max(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (a.isNaN || b.isNaN) Double.NaN else `llvm.maxnum.f64`(a, b)\n+  }\n \n-  @inline def max(a: scala.Float, b: scala.Float): scala.Float =\n-    `llvm.maxnum.f32`(a, b)\n+  @inline def max(a: scala.Float, b: scala.Float): scala.Float = {\n+    if (a.isNaN || b.isNaN) Float.NaN else `llvm.maxnum.f32`(a, b)\n+  }\n \n   @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n     if (a > b) a else b\n \n   @inline def max(a: scala.Long, b: scala.Long): scala.Long =\n     if (a > b) a else b\n \n-  @inline def min(a: scala.Double, b: scala.Double): scala.Double =\n-    `llvm.minnum.f64`(a, b)\n+  @inline def min(a: scala.Double, b: scala.Double): scala.Double = {\n+    if (a.isNaN || b.isNaN) Double.NaN else `llvm.minnum.f64`(a, b)\n+  }"
  }
]
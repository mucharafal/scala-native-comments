[
  {
    "id" : "76cfdc8c-2a72-4c61-85f3-48a96b578c30",
    "prId" : 140,
    "comments" : [
      {
        "id" : "4e5478e8-59e2-413b-8444-d76e43d04882",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Please avoid Scala-style for loops for now and use while loops instead. We're currently not quite there optimisation-wise to remove the overhead they have. \n",
        "createdAt" : "2016-06-02T12:34:15Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {"
  },
  {
    "id" : "85f6e141-b81e-4753-9a2e-3b2e9281ef6a",
    "prId" : 140,
    "comments" : [
      {
        "id" : "2fd36a83-a7f4-4a47-a74b-88604d40fcf4",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one should be `override def toString(): String = this.asInstanaceOf[_String]`. Given that both `String` and `_String` are the same types at NIR-level, this will be a no-op.\n",
        "createdAt" : "2016-06-02T12:58:10Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this"
  },
  {
    "id" : "00e6bcb4-b39f-4425-b4dc-ad5c2fb719ea",
    "prId" : 140,
    "comments" : [
      {
        "id" : "013160cd-f30f-4265-adae-7bc2b36ea34c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Please avoid higher-level Scala constructs like `Try` for now as they are not guaranteed to be optimised away at the moment. \n",
        "createdAt" : "2016-06-02T12:59:15Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))"
  },
  {
    "id" : "f3d09a59-84d7-4f68-96eb-61bbcc7c2c24",
    "prId" : 140,
    "comments" : [
      {
        "id" : "20571e1e-a56a-4432-8c47-c743d4b4ad32",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`ConsolePrintStream` should be an inner class, not in the companion. Otherwise it will have binary-incompatible name in the compiled code. \n",
        "createdAt" : "2016-06-02T13:01:19Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this\n+\n+  def toUpperCase(): _String = toUpperCase(Locale.getDefault)\n+\n+  def toUpperCase(locale: Locale): _String = {\n+    val result = UCharacter.toUpperCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  def trim(): _String = {\n+    var start = offset\n+    var last = offset + count - 1\n+    var end = last\n+    while ((start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+    while ((end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+    if (start == offset && end == last) {\n+      return this\n+    }\n+    new _String(start, end - start + 1, value)\n+  }\n+\n+  def contentEquals(strbuf: StringBuffer): scala.Boolean = {\n+    synchronized (strbuf) {\n+      val size = strbuf.length\n+      if (count != size) {\n+        return false\n+      }\n+      regionMatches(0, new _String(0, size, strbuf.getValue), 0, size)\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+    if (len != count) {\n+      return false\n+    }\n+    if (len == 0 && count == 0) {\n+      return true\n+    }\n+    regionMatches(0, cs.toString, 0, len)\n+  }\n+\n+  def matches(expr: _String): scala.Boolean = Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+  }\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+  }\n+\n+  def split(expr: _String): Array[_String] = Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[_String] = Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence = sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int = {\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointAt(value, s, offset + count)\n+  }\n+\n+  def codePointBefore(index: Int): Int = {\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointBefore(value, s)\n+  }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int = {\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = beginIndex + offset\n+    java.lang.Character.codePointCount(value, s, endIndex - beginIndex)\n+  }\n+\n+  def contains(cs: CharSequence): scala.Boolean = indexOf(cs.to_String) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r = java.lang.Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  object ConsolePrintStream {\n+    private var charset: _String =\n+      AccessController.doPrivileged(new PriviAction[_String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)"
  },
  {
    "id" : "63dbe09a-711d-4720-aff3-4da9ffd127bc",
    "prId" : 140,
    "comments" : [
      {
        "id" : "9203f69e-bb74-4ef3-8965-ee40ec4fd46f",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same feedback as for `ConsolePrintStream` applies here.\n",
        "createdAt" : "2016-06-02T13:02:53Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this\n+\n+  def toUpperCase(): _String = toUpperCase(Locale.getDefault)\n+\n+  def toUpperCase(locale: Locale): _String = {\n+    val result = UCharacter.toUpperCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  def trim(): _String = {\n+    var start = offset\n+    var last = offset + count - 1\n+    var end = last\n+    while ((start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+    while ((end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+    if (start == offset && end == last) {\n+      return this\n+    }\n+    new _String(start, end - start + 1, value)\n+  }\n+\n+  def contentEquals(strbuf: StringBuffer): scala.Boolean = {\n+    synchronized (strbuf) {\n+      val size = strbuf.length\n+      if (count != size) {\n+        return false\n+      }\n+      regionMatches(0, new _String(0, size, strbuf.getValue), 0, size)\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+    if (len != count) {\n+      return false\n+    }\n+    if (len == 0 && count == 0) {\n+      return true\n+    }\n+    regionMatches(0, cs.toString, 0, len)\n+  }\n+\n+  def matches(expr: _String): scala.Boolean = Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+  }\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+  }\n+\n+  def split(expr: _String): Array[_String] = Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[_String] = Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence = sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int = {\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointAt(value, s, offset + count)\n+  }\n+\n+  def codePointBefore(index: Int): Int = {\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointBefore(value, s)\n+  }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int = {\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = beginIndex + offset\n+    java.lang.Character.codePointCount(value, s, endIndex - beginIndex)\n+  }\n+\n+  def contains(cs: CharSequence): scala.Boolean = indexOf(cs.to_String) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r = java.lang.Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  object ConsolePrintStream {\n+    private var charset: _String =\n+      AccessController.doPrivileged(new PriviAction[_String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+    extends java.io.PrintStream(out, true) {\n+    override def print(str: _String) {\n+      if (str == null) {\n+        str = \"null\"\n+      }\n+\n+      try {\n+        write(str.getBytes(ConsolePrintStream.charset))\n+      } catch {\n+        case e: java.io.IOException => setError()\n+      }\n+    }\n+  }\n+\n+  private class CaseInsensitiveComparator extends Comparator[_String] with Serializable {"
  },
  {
    "id" : "d580cd4f-5dea-4d32-bb78-a9082c09de98",
    "prId" : 140,
    "comments" : [
      {
        "id" : "b575ddc3-c564-479e-9ba5-68a209a9a7ae",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:03:57Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this\n+\n+  def toUpperCase(): _String = toUpperCase(Locale.getDefault)\n+\n+  def toUpperCase(locale: Locale): _String = {\n+    val result = UCharacter.toUpperCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  def trim(): _String = {\n+    var start = offset\n+    var last = offset + count - 1\n+    var end = last\n+    while ((start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+    while ((end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+    if (start == offset && end == last) {\n+      return this\n+    }\n+    new _String(start, end - start + 1, value)\n+  }\n+\n+  def contentEquals(strbuf: StringBuffer): scala.Boolean = {\n+    synchronized (strbuf) {\n+      val size = strbuf.length\n+      if (count != size) {\n+        return false\n+      }\n+      regionMatches(0, new _String(0, size, strbuf.getValue), 0, size)\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+    if (len != count) {\n+      return false\n+    }\n+    if (len == 0 && count == 0) {\n+      return true\n+    }\n+    regionMatches(0, cs.toString, 0, len)\n+  }\n+\n+  def matches(expr: _String): scala.Boolean = Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+  }\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+  }\n+\n+  def split(expr: _String): Array[_String] = Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[_String] = Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence = sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int = {\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointAt(value, s, offset + count)\n+  }\n+\n+  def codePointBefore(index: Int): Int = {\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointBefore(value, s)\n+  }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int = {\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = beginIndex + offset\n+    java.lang.Character.codePointCount(value, s, endIndex - beginIndex)\n+  }\n+\n+  def contains(cs: CharSequence): scala.Boolean = indexOf(cs.to_String) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r = java.lang.Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  object ConsolePrintStream {\n+    private var charset: _String =\n+      AccessController.doPrivileged(new PriviAction[_String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+    extends java.io.PrintStream(out, true) {\n+    override def print(str: _String) {\n+      if (str == null) {\n+        str = \"null\"\n+      }\n+\n+      try {\n+        write(str.getBytes(ConsolePrintStream.charset))\n+      } catch {\n+        case e: java.io.IOException => setError()\n+      }\n+    }\n+  }\n+\n+  private class CaseInsensitiveComparator extends Comparator[_String] with Serializable {\n+    def compare(o1: _String, o2: _String): Int = o1.compareToIgnoreCase(o2)\n+  }\n+\n+  val CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator()\n+  private val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset = _\n+\n+  for (i <- ascii.indices) {"
  },
  {
    "id" : "d22843e0-e17d-4bf8-b419-a9756d460d3c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "8dbb22a3-0e3b-4abe-8daf-28251a6659df",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:13Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {"
  },
  {
    "id" : "2f082c5c-0c25-4564-b883-3723865a78ea",
    "prId" : 140,
    "comments" : [
      {
        "id" : "50a01fac-edf6-4da2-afd8-62b67f22037b",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:20Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {"
  },
  {
    "id" : "e3d1ae56-3ab5-4320-9584-12af0860cb29",
    "prId" : 140,
    "comments" : [
      {
        "id" : "88ddba0a-a755-458d-81f7-7527c40f12a5",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:28Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {"
  },
  {
    "id" : "a87fbcfc-f3df-41ff-950b-5fd81419afe3",
    "prId" : 140,
    "comments" : [
      {
        "id" : "efaa43c1-3a7e-4894-bd5b-4952efd788c5",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:35Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {"
  },
  {
    "id" : "5558f1ac-6761-419f-b1ca-fc808d6b7d03",
    "prId" : 140,
    "comments" : [
      {
        "id" : "3110cd2c-d1b3-4d0a-a41b-0f43c4355dd3",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This constructor can be written very simply as `this(data, start, length, Charset.forName(encoding))`\n",
        "createdAt" : "2016-06-02T13:04:44Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,908 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+import scala.util.Try\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var hashcode: Int = _\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset    = defaultCharset()\n+      val charBuffer = charset.decode(ByteBuffer.wrap(data, start, length))\n+      if (charBuffer.length > 0) {\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        count = 0\n+        value = new Array[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+      for (i <- 0 until length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) = {\n+    this()"
  },
  {
    "id" : "13e434d8-5951-40c7-9805-f45c203583e7",
    "prId" : 140,
    "comments" : [
      {
        "id" : "e3671c76-ae58-40f0-b8d7-a1639be1c88b",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:45Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {"
  },
  {
    "id" : "61d898f1-202d-4320-be26-6fcbc7772c36",
    "prId" : 140,
    "comments" : [
      {
        "id" : "eb219ce2-3bf7-4d5b-9807-72e7990d25e4",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:49Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {"
  },
  {
    "id" : "dd32df26-aefa-41bf-b1a5-862aa711a514",
    "prId" : 140,
    "comments" : [
      {
        "id" : "d2ae763a-4aaa-4716-9b57-86282254b814",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:04:59Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {"
  },
  {
    "id" : "3081d835-ed63-46a4-b029-1d8a5b9e48d8",
    "prId" : 140,
    "comments" : [
      {
        "id" : "f59126ed-eb5c-4641-b6dd-611d31f4eb08",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:05:07Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {"
  },
  {
    "id" : "4131f21d-f9d8-4812-80b3-16a42f5176e9",
    "prId" : 140,
    "comments" : [
      {
        "id" : "fa29fd14-0eb2-49d2-9c59-c7459769fbd0",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:05:16Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this\n+\n+  def toUpperCase(): _String = toUpperCase(Locale.getDefault)\n+\n+  def toUpperCase(locale: Locale): _String = {\n+    val result = UCharacter.toUpperCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {"
  },
  {
    "id" : "d1bcdb87-b552-41f7-b212-22dabfa2b2b5",
    "prId" : 140,
    "comments" : [
      {
        "id" : "e4eccfa0-ba03-4391-a2bb-d2a1b74cd3ac",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:05:22Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {"
  },
  {
    "id" : "b73f7f42-a149-4c31-ad68-e69c6eb0c043",
    "prId" : 140,
    "comments" : [
      {
        "id" : "704e1cab-2a81-4370-afeb-92e269a99d86",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "While loop.\n",
        "createdAt" : "2016-06-02T13:05:30Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(): _String = toLowerCase(Locale.getDefault)\n+\n+  def toLowerCase(locale: Locale): _String = {\n+    val result = UCharacter.toLowerCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  override def to_String(): _String = this\n+\n+  def toUpperCase(): _String = toUpperCase(Locale.getDefault)\n+\n+  def toUpperCase(locale: Locale): _String = {\n+    val result = UCharacter.toUpperCase(locale, this)\n+    if (count != result.count) {\n+      return result\n+    }\n+    for (i <- 0 until count if value(offset + i) != result.value(result.offset + i)) {\n+      return result\n+    }\n+    this\n+  }\n+\n+  def trim(): _String = {\n+    var start = offset\n+    var last = offset + count - 1\n+    var end = last\n+    while ((start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+    while ((end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+    if (start == offset && end == last) {\n+      return this\n+    }\n+    new _String(start, end - start + 1, value)\n+  }\n+\n+  def contentEquals(strbuf: StringBuffer): scala.Boolean = {\n+    synchronized (strbuf) {\n+      val size = strbuf.length\n+      if (count != size) {\n+        return false\n+      }\n+      regionMatches(0, new _String(0, size, strbuf.getValue), 0, size)\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+    if (len != count) {\n+      return false\n+    }\n+    if (len == 0 && count == 0) {\n+      return true\n+    }\n+    regionMatches(0, cs.toString, 0, len)\n+  }\n+\n+  def matches(expr: _String): scala.Boolean = Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+  }\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String = {\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+  }\n+\n+  def split(expr: _String): Array[_String] = Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[_String] = Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence = sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int = {\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointAt(value, s, offset + count)\n+  }\n+\n+  def codePointBefore(index: Int): Int = {\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = index + offset\n+    java.lang.Character.codePointBefore(value, s)\n+  }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int = {\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    val s = beginIndex + offset\n+    java.lang.Character.codePointCount(value, s, endIndex - beginIndex)\n+  }\n+\n+  def contains(cs: CharSequence): scala.Boolean = indexOf(cs.to_String) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r = java.lang.Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  object ConsolePrintStream {\n+    private var charset: _String =\n+      AccessController.doPrivileged(new PriviAction[_String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+    extends java.io.PrintStream(out, true) {\n+    override def print(str: _String) {\n+      if (str == null) {\n+        str = \"null\"\n+      }\n+\n+      try {\n+        write(str.getBytes(ConsolePrintStream.charset))\n+      } catch {\n+        case e: java.io.IOException => setError()\n+      }\n+    }\n+  }\n+\n+  private class CaseInsensitiveComparator extends Comparator[_String] with Serializable {\n+    def compare(o1: _String, o2: _String): Int = o1.compareToIgnoreCase(o2)\n+  }\n+\n+  val CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator()\n+  private val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset = _\n+\n+  for (i <- ascii.indices) {\n+    ascii(i) = i.toChar\n+  }\n+\n+  def copyValueOf(data: Array[Char]): _String =\n+    new _String(data, 0, data.length)\n+  def copyValueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+  def valueOf(data: Array[Char]): _String =\n+    new _String(data, 0, data.length)\n+  def valueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+  def valueOf(value: Char): _String = {\n+    val s = if (value < 128) new _String(value, 1, ascii) else new _String(0, 1, Array(value))\n+    s.hashCode = value\n+    s\n+  }\n+  def valueOf(value: Double): _String = Double.toString(value)\n+  def valueOf(value: Float): _String = Float.toString(value)\n+  def valueOf(value: Int): _String = Int.toString(value)\n+  def valueOf(value: Long): _String = Long.toString(value)\n+  def valueOf(value: AnyRef): _String = if (value != null) value.toString else \"null\"\n+  def valueOf(value: scala.Boolean): _String = if (value) \"true\" else \"false\"\n+  def format(format: _String, args: AnyRef*): _String = format(Locale.getDefault, format, args)\n+  def format(loc: Locale, format: _String, args: AnyRef*): _String = {\n+    if (format == null) {\n+      throw new NullPointerException(\"null format argument\")\n+    }\n+    val bufferSize = format.length + (if (args == null) 0 else args.length * 10)\n+    val f = new Formatter(new StringBuilder(bufferSize), loc)\n+    f.format(format, args).to_String\n+  }\n+\n+  private def indexOf(haystackString: _String,\n+                      needleString: _String,\n+                      cache: Int,\n+                      md2: Int,\n+                      lastChar: Char): Int = {\n+    val haystack = haystackString.value\n+    val haystackOffset = haystackString.offset\n+    val haystackLength = haystackString.count\n+    val needle = needleString.value\n+    val needleOffset = needleString.offset\n+    val needleLength = needleString.count\n+    val needleLengthMinus1 = needleLength - 1\n+    val haystackEnd = haystackOffset + haystackLength\n+    outer_loop: var i = haystackOffset + needleLengthMinus1\n+    while (i < haystackEnd) {\n+      if (lastChar == haystack(i)) {\n+        for (j <- 0 until needleLengthMinus1 if needle(j + needleOffset) != haystack(i + j - needleLengthMinus1)) {"
  },
  {
    "id" : "13618df3-87de-47a2-a02f-6b6bc6b7de4a",
    "prId" : 140,
    "comments" : [
      {
        "id" : "5f1b23dc-565f-4e0d-9686-9a80e8a2062f",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one is not actually overriding the hashCode. Probably better use a different name for it like `cashedHashCode`. \n",
        "createdAt" : "2016-06-02T13:07:10Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _"
  },
  {
    "id" : "6149ef45-7881-484a-aff0-f06ae127d5d7",
    "prId" : 140,
    "comments" : [
      {
        "id" : "713fa1d1-b414-4834-ab41-c07fdedb766c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:12Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)"
  },
  {
    "id" : "7d2d0718-b63f-4f8f-8fc0-900085b3ad86",
    "prId" : 140,
    "comments" : [
      {
        "id" : "f9035503-e21b-4d10-8349-69726066a60d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:20Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)"
  },
  {
    "id" : "4837a25a-8424-4321-8bc4-980f3bcfa517",
    "prId" : 140,
    "comments" : [
      {
        "id" : "b7f7a311-ce4c-4307-946d-d82f2d64ee6d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:26Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)"
  },
  {
    "id" : "b5fff9ad-d605-4ce5-b09b-5adea15acd2c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "83db9c0e-e499-4551-ae4e-aee45415f5f4",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:33Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)"
  },
  {
    "id" : "1023201d-93e6-4570-b546-7695f335f371",
    "prId" : 140,
    "comments" : [
      {
        "id" : "aa6ea6f2-8178-40bd-b5d1-74c992196136",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:43Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)"
  },
  {
    "id" : "8b30c11c-0071-43d1-9bfa-7c8d4c716fc8",
    "prId" : 140,
    "comments" : [
      {
        "id" : "e1c6b391-844c-439e-9b3c-3cae95807395",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:08:52Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)"
  },
  {
    "id" : "2b5a1e6f-eaf3-4aa0-8257-0dbee20aa063",
    "prId" : 140,
    "comments" : [
      {
        "id" : "16d483aa-cddd-4a77-b338-e3ab591e1933",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:00Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)"
  },
  {
    "id" : "01d92364-b6d9-4787-b97b-28ea8e828951",
    "prId" : 140,
    "comments" : [
      {
        "id" : "cf7a1246-991f-45fc-87c4-cc4de6fcd2f2",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:14Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)"
  },
  {
    "id" : "00e82f19-0aff-4713-974d-7cff11fb4e79",
    "prId" : 140,
    "comments" : [
      {
        "id" : "3a4ee31d-3163-4702-855d-0d1eab255bfb",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:26Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)"
  },
  {
    "id" : "e14d38f9-ac48-479a-9bfa-f5d5cf15866b",
    "prId" : 140,
    "comments" : [
      {
        "id" : "b003fd2e-29e4-46e3-af67-b21e3725ea0d",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:32Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)"
  },
  {
    "id" : "8aa4de6b-5aee-4bf5-b38a-c16c3ec92596",
    "prId" : 140,
    "comments" : [
      {
        "id" : "185131f1-0557-464f-9da1-0b823f4fd377",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:46Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)"
  },
  {
    "id" : "99bf9b69-81cd-4e48-a872-b7711477d8d1",
    "prId" : 140,
    "comments" : [
      {
        "id" : "8314c727-3d9a-4863-bf79-7169ab7d33fc",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:09:57Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())"
  },
  {
    "id" : "2d859c5d-1ebb-4ad2-84d4-c7c253b0f1fd",
    "prId" : 140,
    "comments" : [
      {
        "id" : "0ff93513-9472-4fe1-8a8e-e8cde1e02938",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:10:07Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())"
  },
  {
    "id" : "1bffad0a-6b2b-4df4-8c03-0ff3128a8cbf",
    "prId" : 140,
    "comments" : [
      {
        "id" : "98aa8877-1e24-4531-9f7c-859db0739bf6",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:10:11Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())"
  },
  {
    "id" : "761145aa-d9fa-43f2-b984-9767cf6d9d34",
    "prId" : 140,
    "comments" : [
      {
        "id" : "449e4557-1f11-4c8c-8ca7-7a56c55e2890",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This one can be `this(data, start, length, Charset.defaultCharset()`\n",
        "createdAt" : "2016-06-02T13:10:25Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,908 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+import scala.util.Try\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var hashcode: Int = _\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) = {\n+    this()"
  },
  {
    "id" : "a7a36207-8840-4fbb-9b6d-bdaff5c91d72",
    "prId" : 140,
    "comments" : [
      {
        "id" : "9aad7a79-16a9-4f36-b1cf-c2b304e990af",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:10:26Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)"
  },
  {
    "id" : "7565b0da-ed96-40d7-935d-2d8c4adc22e8",
    "prId" : 140,
    "comments" : [
      {
        "id" : "8876db36-0f84-4ee6-bd89-dc431d0ba133",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `new Array[Char](length)` instead.\n",
        "createdAt" : "2016-06-02T13:10:38Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {\n+    if (start == 0 && end == count) {\n+      return this\n+    }\n+    if (start < 0) {\n+      throw new StringIndexOutOfBoundsException(start)\n+    } else if (start > end) {\n+      throw new StringIndexOutOfBoundsException(end - start)\n+    } else if (end > count) {\n+      throw new StringIndexOutOfBoundsException(end)\n+    }\n+    new _String(offset + start, end - start, value)\n+  }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = Array.ofDim[Char](count)"
  },
  {
    "id" : "35f8bfde-7b89-45e7-b969-b205a61b7eab",
    "prId" : 140,
    "comments" : [
      {
        "id" : "1aa319e9-cc54-433a-9f64-b60c6f5cd2ca",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This should be `subString`. Names of the methods don't change, only the name of the `String` type. \n",
        "createdAt" : "2016-06-02T13:12:52Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {"
  },
  {
    "id" : "cf3efd49-9908-43be-bc23-fa2642a16748",
    "prId" : 140,
    "comments" : [
      {
        "id" : "ab174e69-3673-4132-ad67-04988a63a498",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This should be `subString`.\n",
        "createdAt" : "2016-06-02T13:13:03Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,951 @@\n package java.lang\n \n import java.io.Serializable\n+import java.util.Comparator\n+import java.util.Formatter\n+import java.util.Locale\n+import java.util.regex.Pattern\n+import java.nio.ByteBuffer\n+import java.nio.CharBuffer\n+import java.nio.charset.Charset\n+import java.nio.charset.IllegalCharsetNameException\n+import java.nio.charset.UnsupportedCharsetException\n+import java.security.AccessController\n+import scala.util.Try\n \n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+class _String extends Serializable with Comparable[_String] with CharSequence {\n+  private var value = new Array[Char](0)\n+  private var offset = 0\n+  private var count = 0\n+  private override var hashCode: Int = _\n+\n+  private def this(s: _String, ch: Char) {\n+    this()\n+    offset = 0\n+    value = Array.ofDim[Char](s.count + 1)\n+    count = s.count + 1\n+    System.arraycopy(s.value, s.offset, value, 0, s.count)\n+    value(s.count) = ch\n+  }\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = defaultCharset()\n+      val cb = charset.decode(ByteBuffer.wrap(data, start, length))\n+      val result: Int = cb.length\n+\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte],\n+           high: Int,\n+           start: Int,\n+           length: Int) {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      high <<= 8\n+      for (i <- 0 until count) {\n+        value(i) = (high + (data(start += 1) & 0xff)).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  @Deprecated\n+  def this(data: Array[scala.Byte], high: Int) {\n+    this(data, high, 0, data.length)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: _String) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset = getCharset(encoding)\n+      val cb = Try(\n+        charset.decode(ByteBuffer.wrap(data, start, length))\n+      ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+      val result = cb.length\n+      if (result > 0) {\n+        value = cb.array()\n+        count = result\n+      } else {\n+        count = 0\n+        value = Array.ofDim[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: _String) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[scala.Byte],\n+           start: Int,\n+           length: Int,\n+           encoding: Charset) {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    }\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      _String.lastCharset = encoding\n+      val cb = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = cb.array()\n+      count = cb.length\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) {\n+    this(data, 0, data.length, encoding)\n+  }\n+\n+  def this(data: Array[Char], start: Int, length: Int) {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = Array.ofDim[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) {\n+    this(data, 0, data.length)\n+  }\n+\n+  def this(start: Int, length: Int, data: Array[Char]) {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(_String: _String) {\n+    this()\n+    value = _String.value\n+    offset = _String.offset\n+    count = _String.count\n+  }\n+\n+  private def this(_s1: _String, _s2: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    count = s1.count + s2.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+  }\n+\n+  private def this(_s1: _String, _s2: _String, _s3: _String) {\n+    this()\n+    var s1 = _s1\n+    var s2 = _s2\n+    var s3 = _s3\n+\n+    if (s1 == null) {\n+      s1 = new _String(\"null\")\n+    }\n+\n+    if (s2 == null) {\n+      s2 = new _String(\"null\")\n+    }\n+\n+    if (s3 == null) {\n+      s3 = new _String(\"null\")\n+    }\n+    count = s1.count + s2.count + s3.count\n+    value = Array.ofDim[Char](count)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    System.arraycopy(s3.value, s3.offset, value, s1.count + s2.count, s3.count)\n+  }\n+\n+  def this(stringBuffer: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized (stringBuffer) {\n+      value = stringBuffer.shareValue()\n+      count = stringBuffer.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    super()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    }\n+    this.offset = 0\n+    this.value = Array.ofDim[Char](count * 2)\n+    val end = offset + count\n+    var c = 0\n+    for (i <- offset until end) {\n+      c += Character.toChars(codePoints(i), this.value, c)\n+    }\n+    this.count = c\n+  }\n+\n+  def this(sb: StringBuilder) {\n+    this()\n+    this.offset = 0\n+    this.count = sb.length\n+    this.value = Array.ofDim[Char](this.count)\n+    sb.getChars(0, this.count, this.value, 0)\n+  }\n+\n+  private def this(s1: _String, v1: Int) {\n+    this()\n+    if (s1 == null) {\n+      s1 = \"null\"\n+    }\n+    val s2 = _String.valueOf(v1)\n+    val len = s1.count + s2.count\n+    value = Array.ofDim[Char](len)\n+    offset = 0\n+    System.arraycopy(s1.value, s1.offset, value, 0, s1.count)\n+    System.arraycopy(s2.value, s2.offset, value, s1.count, s2.count)\n+    count = len\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      return value(offset + index)\n+    }\n+    throw new StringIndexOutOfBoundsException()\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        return (ch + ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toLowerCase(ch)\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        return (ch - ('a' - 'A')).toChar\n+      }\n+      return ch\n+    }\n+    Character.toUpperCase(ch)\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((result = value(o1 += 1) - target(o2 += 1)) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    var result: Int = 0\n+    val end = offset +\n+      (if (count < string.count) count else string.count)\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) == (c2 = target(o2 += 1))) {\n+        //continue\n+      }\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      if ((result = c1 - c2) != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count + string.count)\n+    if (count > 0) {\n+      System.arraycopy(value, offset, buffer, 0, count)\n+    }\n+    System.arraycopy(string.value, string.offset, buffer, count, string.count)\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = AccessController.doPrivileged(new PriviAction[_String](\"file.encoding\", \"ISO8859_1\"))\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+        case e: UnsupportedCharsetException =>\n+      }\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean = {\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+  }\n+\n+  override def equals(`object`: Any): scala.Boolean = {\n+    if (`object` == this) {\n+      return true\n+    }\n+    `object` match {\n+      case s: _String =>\n+        val hash = hashCode\n+        val shash = s.hashCode\n+        if (count != s.count || (hash != shash && hash != 0 && shash != 0)) {\n+          return false\n+        }\n+        for (i <- 0 until count if value(offset + i) != s.value(s.offset + i)) {\n+          return false\n+        }\n+        return true\n+      case _ =>\n+    }\n+    false\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      return true\n+    }\n+    if (string == null || count != string.count) {\n+      return false\n+    }\n+    val o1 = offset\n+    val o2 = string.offset\n+    val end = offset + count\n+    var c1: Char = 0\n+    var c2: Char = 0\n+    val target = string.value\n+    while (o1 < end) {\n+      if ((c1 = value(o1 += 1)) != (c2 = target(o2 += 1)) && toUpperCase(c1) != toUpperCase(c2) &&\n+        toLowerCase(c1) != toLowerCase(c2)) {\n+        return false\n+      }\n+    }\n+    true\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(start: Int,\n+               end: Int,\n+               data: Array[scala.Byte],\n+               index: Int) {\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+      for (i <- offset + start until end) {\n+        data(index += 1) = value(i).toByte\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer = getCharset(encoding).encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      charset = Charset.forName(encoding)\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(this.value, this.offset, this.count))\n+    val bytes = Array.ofDim[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int,\n+               end: Int,\n+               buffer: Array[Char],\n+               index: Int) = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      }\n+      var hash = 0\n+      for (i <- offset until count + offset) {\n+        hash = value(i) + ((hash << 5) - hash)\n+      }\n+      hashCode = hash\n+    }\n+    hashCode\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(c: Int, start: Int): Int = {\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, start: Int): Int = {\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        var o1 = offset + i\n+        var o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {\n+        }\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = VM.intern(this)\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(c: Int, start: Int): Int = {\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= java.lang.Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > java.lang.Character.MAX_VALUE && c <= java.lang.Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, start: Int): Int = {\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          var o1 = offset + i\n+          var o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {\n+          }\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      return false\n+    }\n+    if (thisStart < 0 || count - thisStart < length) {\n+      return false\n+    }\n+    if (length <= 0) {\n+      return true\n+    }\n+    val o1 = offset + thisStart\n+    val o2 = string.offset + start\n+    for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+      return false\n+    }\n+    true\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (!ignoreCase) {\n+      return regionMatches(thisStart, string, start, length)\n+    }\n+    if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        return false\n+      }\n+      if (start < 0 || length > string.count - start) {\n+        return false\n+      }\n+      thisStart += offset\n+      start += string.offset\n+      val end = thisStart + length\n+      var c1: Char = 0\n+      var c2: Char = 0\n+      val target = string.value\n+      while (thisStart < end) {\n+        if ((c1 = value(thisStart += 1)) != (c2 = target(start += 1)) &&\n+          toUpperCase(c1) != toUpperCase(c2) &&\n+          toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      return true\n+    }\n+    throw new NullPointerException()\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      return this\n+    }\n+    val buffer = Array.ofDim[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    do {\n+      buffer(index += 1) = newChar\n+    } while ((index = indexOf(oldChar, index)) != -1);\n+    new _String(0, count, buffer)\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    }\n+    if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    }\n+    val ts = target.toString\n+    var index = indexOf(ts, 0)\n+    if (index == -1) return this\n+    val rs = replacement.toString\n+    if (\"\" == ts) {\n+      val buffer = new StringBuilder(count + (rs.length * (count + 1)))\n+      buffer.append(rs)\n+      for (i <- 0 until count) {\n+        buffer.append(value(offset + i))\n+        buffer.append(rs)\n+      }\n+      return buffer.toString\n+    }\n+    val buffer = new StringBuilder(count + rs.length)\n+    val tl = target.length\n+    var tail = 0\n+    do {\n+      buffer.append(value, offset + tail, index - tail)\n+      buffer.append(rs)\n+      tail = index + tl\n+    } while ((index = indexOf(ts, tail)) != -1);\n+    buffer.append(value, offset + tail, count - tail)\n+    buffer.toString\n+  }\n+\n+  def startsWith(prefix: _String): scala.Boolean = startsWith(prefix, 0)\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean = {\n+    regionMatches(start, prefix, 0, prefix.count)\n+  }\n+\n+  def sub_String(start: Int): _String = {\n+    if (start == 0) {\n+      return this\n+    }\n+    if (0 <= start && start <= count) {\n+      return new _String(offset + start, count - start, value)\n+    }\n+    throw new StringIndexOutOfBoundsException(start)\n+  }\n+\n+  def sub_String(start: Int, end: Int): _String = {"
  },
  {
    "id" : "cbc21306-7120-4c66-970f-88a10aa60faa",
    "prId" : 140,
    "comments" : [
      {
        "id" : "092258dd-7392-4b24-91e1-d06ebd0630d8",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "These checks are redundant, because they are supposed to be performed by `ByteBuffer.wrap`.\n",
        "createdAt" : "2016-06-02T13:15:40Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6157ce3c-1f28-4d76-b8b8-812090c16a34",
        "parentId" : "092258dd-7392-4b24-91e1-d06ebd0630d8",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "But `CharBuffer` throws `IndexOutOfBoundsException`, not `StringIndexOutOfBoundsException`, doesn't it?\n",
        "createdAt" : "2016-06-02T13:22:02Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b4fc3af-143f-410b-a49e-7bba2740c973",
        "parentId" : "092258dd-7392-4b24-91e1-d06ebd0630d8",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Yes, and that's exactly what this constructor is supposed to throw: http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#String%28byte[],%20int,%20int,%20java.nio.charset.Charset%29\n",
        "createdAt" : "2016-06-02T13:26:32Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "59c4d05f-1e65-43a9-99b6-84c06df59b51",
        "parentId" : "092258dd-7392-4b24-91e1-d06ebd0630d8",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Good point. 👍 \n",
        "createdAt" : "2016-06-02T13:27:25Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,908 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+import scala.util.Try\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var hashcode: Int = _\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset    = defaultCharset()\n+      val charBuffer = charset.decode(ByteBuffer.wrap(data, start, length))\n+      if (charBuffer.length > 0) {\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        count = 0\n+        value = new Array[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+      for (i <- 0 until length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {\n+        offset = 0\n+        val charset = getCharset(encoding)\n+        val charBuffer = Try(\n+            charset.decode(ByteBuffer.wrap(data, start, length))\n+        ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+        if (charBuffer.length > 0) {\n+          value = charBuffer.array\n+          count = charBuffer.length\n+        } else {\n+          count = 0\n+          value = new Array[Char](0)\n+        }\n+      } else {\n+        throw new StringIndexOutOfBoundsException()\n+      }\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {"
  },
  {
    "id" : "09f9ff03-9380-4009-9377-1db107c0bd46",
    "prId" : 140,
    "comments" : [
      {
        "id" : "b992d9e5-d92d-4841-bb28-550ca18c9afd",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Those implicit conversions should not be necessary. Why do you need them? \n",
        "createdAt" : "2016-06-02T13:28:13Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b25878b0-1e02-4590-950a-c6c749596321",
        "parentId" : "b992d9e5-d92d-4841-bb28-550ca18c9afd",
        "author" : {
          "login" : "t-hiroyoshi",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10783208?u=ee3909d61fb9f79884f23df85f5313e7d90855d0&v=4"
        },
        "body" : "Without these implicit conversions, we can't compile this source.\nIt would be the cause of failure in build X(\n",
        "createdAt" : "2016-06-03T10:04:46Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "t-hiroyoshi",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10783208?u=ee3909d61fb9f79884f23df85f5313e7d90855d0&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,908 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+import scala.util.Try\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var hashcode: Int = _\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset    = defaultCharset()\n+      val charBuffer = charset.decode(ByteBuffer.wrap(data, start, length))\n+      if (charBuffer.length > 0) {\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        count = 0\n+        value = new Array[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+      for (i <- 0 until length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {\n+        offset = 0\n+        val charset = getCharset(encoding)\n+        val charBuffer = Try(\n+            charset.decode(ByteBuffer.wrap(data, start, length))\n+        ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+        if (charBuffer.length > 0) {\n+          value = charBuffer.array\n+          count = charBuffer.length\n+        } else {\n+          count = 0\n+          value = new Array[Char](0)\n+        }\n+      } else {\n+        throw new StringIndexOutOfBoundsException()\n+      }\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {\n+        offset = 0\n+        _String.lastCharset = encoding\n+\n+        val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        throw new StringIndexOutOfBoundsException()\n+      }\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      for (i <- offset until end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        (ch + ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        (ch + ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        (ch - ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    val target = string.value\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - target(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    val target = string.value\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = target(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            return false\n+          }\n+          for (i <- 0 until count\n+                       if value(offset + i) != s.value(s.offset + i)) {\n+            return false\n+          }\n+          true\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      val end    = offset + count\n+      val target = string.value\n+      while (o1 < end) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = target(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        for (i <- offset + start until end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashcode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+        for (i <- offset until count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+        }\n+        hashcode = hash\n+      }\n+    }\n+    hashcode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            // continue\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target    = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end       = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        val o1 = offset + i\n+        val o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {}\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        val i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        val i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+      for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+        return false\n+      }\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+        for (i <- 0 until count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+        }\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def sub_String(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def sub_String(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.toString()\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    synchronized {\n+      val size = sb.length\n+\n+      if (count != size) {\n+        false\n+      } else {\n+        regionMatches(0, new _String(0, size, sb.getValue), 0, size)\n+      }\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+\n+    if (len != count) {\n+      false\n+    } else if (len == 0 && count == 0) {\n+      true\n+    } else {\n+      regionMatches(0, _String.valueOf(cs.toString), 0, len)\n+    }\n+  }\n+\n+  def matches(expr: _String): scala.Boolean =\n+    Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+\n+  def split(expr: _String): Array[String] =\n+    Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[String] =\n+    Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence =\n+    sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int =\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointAt(value, index + offset, offset + count)\n+    }\n+\n+  def codePointBefore(index: Int): Int =\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointBefore(value, index + offset)\n+    }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int =\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointCount(\n+          value, beginIndex + offset, endIndex - beginIndex)\n+    }\n+\n+  def contains(cs: CharSequence): scala.Boolean =\n+    indexOf(_String.valueOf(cs.toString)) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r =\n+      Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n+\n+  def getValue(): Array[Char] = value\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  final val CASE_INSENSITIVE_ORDER: Comparator[_String] =\n+    new CaseInsensitiveComparator()\n+  private final val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset    = _\n+\n+  for (i <- ascii.indices) {\n+    ascii(i) = i.toChar\n+  }\n+\n+  object ConsolePrintStream {\n+    private var charset = \"ISO-8859-1\"\n+//      AccessController.doPrivileged(new PriviActions[String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+      extends java.io.PrintStream(out, true) {\n+    def print(str: _String) {\n+      try {\n+        if (str == null) {\n+          write(\"null\".getBytes(ConsolePrintStream.charset))\n+        } else {\n+          write(str.getBytes(ConsolePrintStream.charset))\n+        }\n+      } catch {\n+        case e: java.io.IOException =>\n+          setError()\n+      }\n+    }\n+  }\n+\n+  private class CaseInsensitiveComparator\n+      extends Comparator[_String] with Serializable {\n+    def compare(o1: _String, o2: _String): Int =\n+      o1.compareToIgnoreCase(o2)\n+  }\n+\n+  def copyValueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+\n+  def copyValueOf(data: Array[Char]): _String =\n+    new _String(data, 0, data.length)\n+\n+  def valueOf(data: Array[Char]): _String = new _String(data)\n+\n+  def valueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+\n+  def valueOf(value: Char): _String = {\n+    val s =\n+      if (value < 128) new _String(value, 1, ascii)\n+      else new _String(0, 1, Array(value))\n+    s.hashcode = value\n+    s\n+  }\n+\n+  def valueOf(value: scala.Double): _String = Double.toString(value)\n+\n+  def valueOf(value: scala.Float): _String = Float.toString(value)\n+\n+  def valueOf(value: scala.Int): _String = Integer.toString(value)\n+\n+  def valueOf(value: scala.Long): _String = Long.toString(value)\n+\n+  def valueOf(value: scala.Boolean): _String = if (value) \"true\" else \"false\"\n+\n+  def valueOf(value: AnyRef): _String =\n+    if (value != null) valueOf(value.toString) else \"null\"\n+\n+  def format(_format: _String, args: AnyRef*): _String =\n+    format(Locale.getDefault(), _format, args)\n+\n+  def format(loc: Locale, _format: _String, args: AnyRef*): _String = {\n+    if (_format == null) {\n+      throw new NullPointerException(\"null format argument\")\n+    } else {\n+      val bufferSize =\n+        if (args == null) _format.length + 0\n+        else _format.length + args.length * 10\n+      val f = new Formatter(new java.lang.StringBuilder(bufferSize), loc)\n+      f.format(_format, args).toString\n+    }\n+  }\n+\n+  import scala.language.implicitConversions\n+  private implicit def to_String(s: String): _String = valueOf(s.toCharArray)\n+  private implicit def toString(s: _String): String  = s.toString()"
  },
  {
    "id" : "c19f35a9-de91-4d2b-986c-acba78de865c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "198b96ca-2d70-4a71-bfab-30fcd3938aac",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This signature will not be binary compatible. In Java, varargs are encoded as arrays. The proper binary-compatible signature is (unfortunately) `args: Array[AnyRef]` (and no, not `Array[Any]`, as that erases to `Object` instead of `Array[Object]`)\n",
        "createdAt" : "2016-06-02T13:41:33Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,908 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+import scala.util.Try\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var hashcode: Int = _\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      val charset    = defaultCharset()\n+      val charBuffer = charset.decode(ByteBuffer.wrap(data, start, length))\n+      if (charBuffer.length > 0) {\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        count = 0\n+        value = new Array[Char](0)\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+      for (i <- 0 until length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {\n+        offset = 0\n+        val charset = getCharset(encoding)\n+        val charBuffer = Try(\n+            charset.decode(ByteBuffer.wrap(data, start, length))\n+        ).getOrElse(CharBuffer.wrap(\"?\".toCharArray))\n+\n+        if (charBuffer.length > 0) {\n+          value = charBuffer.array\n+          count = charBuffer.length\n+        } else {\n+          count = 0\n+          value = new Array[Char](0)\n+        }\n+      } else {\n+        throw new StringIndexOutOfBoundsException()\n+      }\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      if (start >= 0 && 0 <= length && length <= data.length - start) {\n+        offset = 0\n+        _String.lastCharset = encoding\n+\n+        val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+        value = charBuffer.array\n+        count = charBuffer.length\n+      } else {\n+        throw new StringIndexOutOfBoundsException()\n+      }\n+    }\n+  }\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      for (i <- offset until end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        (ch + ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') {\n+        (ch + ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') {\n+        (ch - ('a' - 'A')).toChar\n+      } else {\n+        ch\n+      }\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    val target = string.value\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - target(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    val target = string.value\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = target(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            return false\n+          }\n+          for (i <- 0 until count\n+                       if value(offset + i) != s.value(s.offset + i)) {\n+            return false\n+          }\n+          true\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      val end    = offset + count\n+      val target = string.value\n+      while (o1 < end) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = target(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        for (i <- offset + start until end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (hashcode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+        for (i <- offset until count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+        }\n+        hashcode = hash\n+      }\n+    }\n+    hashcode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        for (i <- offset + start until offset + count if value(i) == c) {\n+          return i - offset\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        for (i <- start until count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            // continue\n+          }\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      }\n+      val target    = subString.value\n+      val subOffset = subString.offset\n+      val firstChar = target(subOffset)\n+      val end       = subOffset + subCount\n+      while (true) {\n+        val i = indexOf(firstChar, start)\n+        if (i == -1 || subCount + i > count) {\n+          return -1\n+        }\n+        val o1 = offset + i\n+        val o2 = subOffset\n+        while (o2 < end && value(o1) == target(o2)) {}\n+        if (o2 == end) {\n+          return i\n+        }\n+        start = i + 1\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        val i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          }\n+          i\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        val i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i\n+          }\n+          i\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(string: _String): Int = lastIndexOf(string, count)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+      return if (start < count) start else count\n+    }\n+    -1\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+      for (i <- 0 until length if value(o1 + i) != string.value(o2 + i)) {\n+        return false\n+      }\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+        for (i <- 0 until count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+        }\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def sub_String(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def sub_String(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.toString()\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    synchronized {\n+      val size = sb.length\n+\n+      if (count != size) {\n+        false\n+      } else {\n+        regionMatches(0, new _String(0, size, sb.getValue), 0, size)\n+      }\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+\n+    if (len != count) {\n+      false\n+    } else if (len == 0 && count == 0) {\n+      true\n+    } else {\n+      regionMatches(0, _String.valueOf(cs.toString), 0, len)\n+    }\n+  }\n+\n+  def matches(expr: _String): scala.Boolean =\n+    Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+\n+  def split(expr: _String): Array[String] =\n+    Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[String] =\n+    Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence =\n+    sub_String(start, end)\n+\n+  def codePointAt(index: Int): Int =\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointAt(value, index + offset, offset + count)\n+    }\n+\n+  def codePointBefore(index: Int): Int =\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointBefore(value, index + offset)\n+    }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int =\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointCount(\n+          value, beginIndex + offset, endIndex - beginIndex)\n+    }\n+\n+  def contains(cs: CharSequence): scala.Boolean =\n+    indexOf(_String.valueOf(cs.toString)) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r =\n+      Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n+\n+  def getValue(): Array[Char] = value\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  final val CASE_INSENSITIVE_ORDER: Comparator[_String] =\n+    new CaseInsensitiveComparator()\n+  private final val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset    = _\n+\n+  for (i <- ascii.indices) {\n+    ascii(i) = i.toChar\n+  }\n+\n+  object ConsolePrintStream {\n+    private var charset = \"ISO-8859-1\"\n+//      AccessController.doPrivileged(new PriviActions[String](\"console.encoding\", \"ISO8859_1\"))\n+\n+    if (!Charset.isSupported(charset)) {\n+      charset = \"ISO-8859-1\"\n+    }\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+      extends java.io.PrintStream(out, true) {\n+    def print(str: _String) {\n+      try {\n+        if (str == null) {\n+          write(\"null\".getBytes(ConsolePrintStream.charset))\n+        } else {\n+          write(str.getBytes(ConsolePrintStream.charset))\n+        }\n+      } catch {\n+        case e: java.io.IOException =>\n+          setError()\n+      }\n+    }\n+  }\n+\n+  private class CaseInsensitiveComparator\n+      extends Comparator[_String] with Serializable {\n+    def compare(o1: _String, o2: _String): Int =\n+      o1.compareToIgnoreCase(o2)\n+  }\n+\n+  def copyValueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+\n+  def copyValueOf(data: Array[Char]): _String =\n+    new _String(data, 0, data.length)\n+\n+  def valueOf(data: Array[Char]): _String = new _String(data)\n+\n+  def valueOf(data: Array[Char], start: Int, length: Int): _String =\n+    new _String(data, start, length)\n+\n+  def valueOf(value: Char): _String = {\n+    val s =\n+      if (value < 128) new _String(value, 1, ascii)\n+      else new _String(0, 1, Array(value))\n+    s.hashcode = value\n+    s\n+  }\n+\n+  def valueOf(value: scala.Double): _String = Double.toString(value)\n+\n+  def valueOf(value: scala.Float): _String = Float.toString(value)\n+\n+  def valueOf(value: scala.Int): _String = Integer.toString(value)\n+\n+  def valueOf(value: scala.Long): _String = Long.toString(value)\n+\n+  def valueOf(value: scala.Boolean): _String = if (value) \"true\" else \"false\"\n+\n+  def valueOf(value: AnyRef): _String =\n+    if (value != null) valueOf(value.toString) else \"null\"\n+\n+  def format(_format: _String, args: AnyRef*): _String =\n+    format(Locale.getDefault(), _format, args)\n+\n+  def format(loc: Locale, _format: _String, args: AnyRef*): _String = {"
  },
  {
    "id" : "b93545b4-e780-4ef3-86de-94b9113a74f1",
    "prId" : 140,
    "comments" : [
      {
        "id" : "f2c6b9fe-9706-4444-b3d7-3d2942502b28",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Why is this part commented out? \n",
        "createdAt" : "2016-06-03T10:49:20Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }"
  },
  {
    "id" : "8a4141f1-c63e-4d37-b9ff-1f088e9ad1f7",
    "prId" : 140,
    "comments" : [
      {
        "id" : "93c0ef55-4da1-4fe5-9005-3f9cfd52b928",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This line is not necessary, we're not going to support java-style security management. \n",
        "createdAt" : "2016-06-03T10:50:49Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var i = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cashedHashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+\n+        var i = offset\n+        while (i < count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+          i += 1\n+        }\n+\n+        cashedHashCode = hash\n+      }\n+    }\n+    cashedHashCode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i < offset + count) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i += 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i < count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+\n+          i += 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      } else {\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = indexOf(firstChar, start)\n+          if (i == -1 || subCount + i > count) {\n+            return -1\n+          }\n+\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i + 1\n+        }\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i -= 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i -= 1\n+          }\n+\n+          i -= 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+\n+      if (start < count) start else count\n+    } else {\n+      -1\n+    }\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+\n+      var i = 0\n+      while (i < length) {\n+        if (value(o1 + i) != string.value(o2 + i)) {\n+          return false\n+        }\n+        i += 1\n+      }\n+\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+\n+        var i = 0\n+        while (i < count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+          i += 1\n+        }\n+\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def subString(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def subString(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.asInstanceOf[_String]\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    synchronized {\n+      val size = sb.length\n+\n+      if (count != size) {\n+        false\n+      } else {\n+        regionMatches(0, new _String(0, size, sb.getValue), 0, size)\n+      }\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+\n+    if (len != count) {\n+      false\n+    } else if (len == 0 && count == 0) {\n+      true\n+    } else {\n+      regionMatches(0, _String.valueOf(cs.toString), 0, len)\n+    }\n+  }\n+\n+  def matches(expr: _String): scala.Boolean =\n+    Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+\n+  def split(expr: _String): Array[String] =\n+    Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[String] =\n+    Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence =\n+    subString(start, end)\n+\n+  def codePointAt(index: Int): Int =\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointAt(value, index + offset, offset + count)\n+    }\n+\n+  def codePointBefore(index: Int): Int =\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointBefore(value, index + offset)\n+    }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int =\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointCount(\n+          value, beginIndex + offset, endIndex - beginIndex)\n+    }\n+\n+  def contains(cs: CharSequence): scala.Boolean =\n+    indexOf(_String.valueOf(cs.toString)) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r =\n+      Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n+\n+  def getValue(): Array[Char] = value\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  final val CASE_INSENSITIVE_ORDER: Comparator[_String] =\n+    new CaseInsensitiveComparator()\n+  private final val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset    = _\n+\n+  var i = 0\n+  while (i < ascii.length) {\n+    ascii(i) = i.toChar\n+    i += 1\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)\n+      extends java.io.PrintStream(out, true) {\n+    private var charset = \"ISO-8859-1\"\n+    //      AccessController.doPrivileged(new PriviActions[String](\"console.encoding\", \"ISO8859_1\"))"
  },
  {
    "id" : "f62df090-0f44-4415-9f73-780355096378",
    "prId" : 140,
    "comments" : [
      {
        "id" : "c409d7fb-cf73-4528-9061-52a93255a5b0",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Not necessary either.\n",
        "createdAt" : "2016-06-03T10:51:19Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))"
  },
  {
    "id" : "7ebe3f82-938a-4c97-907d-28cfd9a2e8c8",
    "prId" : 140,
    "comments" : [
      {
        "id" : "2ece8d02-2c59-4444-840e-c1d19e473fe2",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Typo: cached\n",
        "createdAt" : "2016-06-03T12:45:19Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _"
  },
  {
    "id" : "62bab62b-050f-4445-9229-fe5096fb1a10",
    "prId" : 140,
    "comments" : [
      {
        "id" : "14c94b11-b003-47d3-a5c7-b793c82d23c8",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The 0-argument constructor should be public. It creates a string of length 0 (i.e., `\"\"`).\n",
        "createdAt" : "2016-06-03T12:46:14Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()"
  },
  {
    "id" : "58bff6a9-18bb-4868-a056-7d698da53b1c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "9a529e71-2c26-4bcb-b218-298a43b2e884",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "`val high = _high << 8`?\n",
        "createdAt" : "2016-06-03T12:46:49Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8"
  },
  {
    "id" : "66b641d6-0811-475c-9eb4-e05cca8ef7bc",
    "prId" : 140,
    "comments" : [
      {
        "id" : "88ec05cd-40a6-40e4-ac87-95423171a252",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider `|` instead of `+`, as the intent is clearer.\n",
        "createdAt" : "2016-06-03T12:47:49Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar"
  },
  {
    "id" : "0950adff-eb52-40e4-b8f2-c75de1aaeb27",
    "prId" : 140,
    "comments" : [
      {
        "id" : "6ab7ad55-12c8-4bbf-8494-3f7c9c2c48d6",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I'm skeptical about this `lastCharset` business. It looks like premature optimization to me, and it's not even clear that it's an optimization. An application sensibly working always with `Charset`s (rather than charset names) would just pay the cost of storing this global field every time for nothing.\n\nBesides, if there's anywhere this caching should be done, it should be in `Charset.forName`, not in every single method that takes a charset name as parameter.\n",
        "createdAt" : "2016-06-03T12:50:51Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding"
  },
  {
    "id" : "5c65e357-afb1-4304-9a80-a88421dc3ade",
    "prId" : 140,
    "comments" : [
      {
        "id" : "edfcbe58-f162-4bd3-abaa-c7e54ffadcae",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This check is redundant, as it's an implicit consequence of the call `encoding.decode(...)`.\n",
        "createdAt" : "2016-06-03T12:51:32Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()"
  },
  {
    "id" : "500b8708-c7ee-464b-afab-8dc31a6da19c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "d451f756-33e3-4cc5-aec6-40db8b66b0d6",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This should be an `IndexOutOfBoundsException`. See http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#String-char:A-int-int-\n",
        "createdAt" : "2016-06-03T12:55:30Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()"
  },
  {
    "id" : "e4588413-0dbb-4ff3-a352-bccd2e5a3a52",
    "prId" : 140,
    "comments" : [
      {
        "id" : "f8d5d3ab-3478-4053-a427-347f3a0afc81",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This is not necessary.\n",
        "createdAt" : "2016-06-03T12:56:38Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {"
  },
  {
    "id" : "5583b75b-021f-49f7-a0e7-b865422cb17c",
    "prId" : 140,
    "comments" : [
      {
        "id" : "01b8dc6a-883a-4708-a9ee-e91e9c3f24e2",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Looks like these micro-optimizations are best left to `Character.toLowerCase()` itself.\n",
        "createdAt" : "2016-06-03T12:59:10Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch"
  },
  {
    "id" : "97cf9f43-9311-4e3e-9d53-0ba6ca3e430f",
    "prId" : 140,
    "comments" : [
      {
        "id" : "13c7b6da-4296-4ee7-92ab-186708a6a7d8",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Consider:\n\n``` scala\nval c1 = compareValue(value(o1))\nval c2 = compareValue(string.value(o2))\n```\n",
        "createdAt" : "2016-06-03T13:00:15Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)"
  },
  {
    "id" : "637c73e1-5f23-4ad9-93cb-1fed8afa10f9",
    "prId" : 140,
    "comments" : [
      {
        "id" : "e9c09a3e-8a57-4f90-a451-6d87e54c1e25",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Why is this method not simply calling `Charset.defaultCharset()`?\n",
        "createdAt" : "2016-06-03T13:01:32Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {"
  },
  {
    "id" : "52783194-3574-4191-89ed-5156fb862a7a",
    "prId" : 140,
    "comments" : [
      {
        "id" : "63d794ae-870d-4e07-99ab-be7a78bb9d16",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "The `count == 0` part is unnecessary. The loop below will correctly compute `0` if `count == 0`. There's no need for that special-case.\n",
        "createdAt" : "2016-06-03T13:04:20Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var i = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cashedHashCode == 0) {\n+      if (count == 0) {\n+        return 0"
  },
  {
    "id" : "eea64b70-0775-4d26-a82a-a9eeed1299bc",
    "prId" : 140,
    "comments" : [
      {
        "id" : "0940236d-33de-486f-b7cf-3e51c7b76415",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I recommend commenting that out if it is not correctly implemented, so that the linker can report linking errors, rather than silently producing an incorrect program.\n",
        "createdAt" : "2016-06-03T13:06:22Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var i = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cashedHashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+\n+        var i = offset\n+        while (i < count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+          i += 1\n+        }\n+\n+        cashedHashCode = hash\n+      }\n+    }\n+    cashedHashCode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i < offset + count) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i += 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i < count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+\n+          i += 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      } else {\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = indexOf(firstChar, start)\n+          if (i == -1 || subCount + i > count) {\n+            return -1\n+          }\n+\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i + 1\n+        }\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???"
  },
  {
    "id" : "177d2447-1ae6-40d6-a859-347d21e0a868",
    "prId" : 140,
    "comments" : [
      {
        "id" : "c0fcba64-6c44-4c5a-a35b-75d7b24e8e3c",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Unnecessary.\n",
        "createdAt" : "2016-06-03T13:07:37Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var i = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cashedHashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+\n+        var i = offset\n+        while (i < count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+          i += 1\n+        }\n+\n+        cashedHashCode = hash\n+      }\n+    }\n+    cashedHashCode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i < offset + count) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i += 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i < count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+\n+          i += 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      } else {\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = indexOf(firstChar, start)\n+          if (i == -1 || subCount + i > count) {\n+            return -1\n+          }\n+\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i + 1\n+        }\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i -= 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i -= 1\n+          }\n+\n+          i -= 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+\n+      if (start < count) start else count\n+    } else {\n+      -1\n+    }\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+\n+      var i = 0\n+      while (i < length) {\n+        if (value(o1 + i) != string.value(o2 + i)) {\n+          return false\n+        }\n+        i += 1\n+      }\n+\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+\n+        var i = 0\n+        while (i < count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+          i += 1\n+        }\n+\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def subString(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def subString(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.asInstanceOf[_String]\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    synchronized {"
  },
  {
    "id" : "28c9c3cb-c878-4fd4-bd81-70ed6da6e898",
    "prId" : 140,
    "comments" : [
      {
        "id" : "4cb7620e-3b01-490a-bd57-7e66d7fed2f2",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This will create a _field_ `i`. Consider:\n\n``` scala\nprivate val ascii = {\n  val ascii = new Array[Char](128)\n  var i = 0\n  while (i < ascii.length) {\n    ascii(i) = i.toChar\n    i += 1\n  }\n  ascii\n}\n```\n",
        "createdAt" : "2016-06-03T13:09:24Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,890 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String private ()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value         = new Array[Char](0)\n+  private var offset        = 0\n+  private var count         = 0\n+  private var cashedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], _high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      var high = _high\n+      high <<= 8\n+\n+      var i = 0\n+      while (i < length) {\n+        value(i) = (high + data(start + i) & 0xff).toChar\n+        i += 1\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    if (encoding == null) {\n+      throw new NullPointerException()\n+    } else {\n+      offset = 0\n+      _String.lastCharset = encoding\n+\n+      val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+      value = charBuffer.array\n+      count = charBuffer.length\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    synchronized {\n+      value = sb.getValue\n+      count = sb.length\n+    }\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    ???\n+//    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+//      throw new IndexOutOfBoundsException()\n+//    } else {\n+//      this.offset = 0\n+//      this.value = new Array[Char](count * 2)\n+//      val end = offset + count\n+//      var c = 0\n+//\n+//      var i = offset\n+//      while (i < end) {\n+//        c +=\n+//          Character.toChars(codePoints(i), this.value, c)\n+//      }\n+//\n+//      this.count = c\n+//    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(Character.toUpperCase(ch))\n+    }\n+  }\n+\n+  private def toLowerCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('A' <= ch && ch <= 'Z') (ch + ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toLowerCase(ch)\n+    }\n+  }\n+\n+  private def toUpperCase(ch: Char): Char = {\n+    if (ch < 128) {\n+      if ('a' <= ch && ch <= 'z') (ch - ('a' - 'A')).toChar\n+      else ch\n+    } else {\n+      Character.toUpperCase(ch)\n+    }\n+  }\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      var c1: Char = value(o1)\n+      var c2: Char = string.value(o2)\n+      c1 = compareValue(c1)\n+      c2 = compareValue(c2)\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = {\n+    if (_String.DefaultCharset == null) {\n+      val encoding = \"ISO-8859-1\"\n+//        AccessController.doPrivileged(new PriviAction[String](\"file.encoding\", \"ISO8859_1\"))\n+\n+      try {\n+        _String.DefaultCharset = Charset.forName(encoding)\n+      } catch {\n+        case _: IllegalCharsetNameException | _: UnsupportedCharsetException =>\n+        // Ignored\n+      }\n+\n+      if (_String.DefaultCharset == null) {\n+        _String.DefaultCharset = Charset.forName(\"ISO-8859-1\")\n+      }\n+    }\n+    _String.DefaultCharset\n+  }\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end   = _end\n+    var index = _index\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var i = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val buffer =\n+      getCharset(encoding).encode(CharBuffer.wrap(value, offset, count))\n+    val bytes = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  private def getCharset(encoding: _String): Charset = {\n+    var charset = _String.lastCharset\n+\n+    if (charset == null || !encoding.equalsIgnoreCase(charset.name())) {\n+      try {\n+        charset = Charset.forName(encoding)\n+      } catch {\n+        case e: IllegalCharsetNameException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+        case e: UnsupportedCharsetException =>\n+          throw new UnsupportedEncodingException(encoding).initCause(e)\n+      }\n+\n+      _String.lastCharset = charset\n+    }\n+    charset\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cashedHashCode == 0) {\n+      if (count == 0) {\n+        return 0\n+      } else {\n+        var hash = 0\n+\n+        var i = offset\n+        while (i < count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+          i += 1\n+        }\n+\n+        cashedHashCode = hash\n+      }\n+    }\n+    cashedHashCode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i < offset + count) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i += 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i < count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+\n+          i += 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      } else {\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = indexOf(firstChar, start)\n+          if (i == -1 || subCount + i > count) {\n+            return -1\n+          }\n+\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i + 1\n+        }\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i -= 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i -= 1\n+          }\n+\n+          i -= 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+\n+      if (start < count) start else count\n+    } else {\n+      -1\n+    }\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+\n+      var i = 0\n+      while (i < length) {\n+        if (value(o1 + i) != string.value(o2 + i)) {\n+          return false\n+        }\n+        i += 1\n+      }\n+\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+\n+        var i = 0\n+        while (i < count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+          i += 1\n+        }\n+\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def subString(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def subString(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.asInstanceOf[_String]\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    synchronized {\n+      val size = sb.length\n+\n+      if (count != size) {\n+        false\n+      } else {\n+        regionMatches(0, new _String(0, size, sb.getValue), 0, size)\n+      }\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+\n+    if (len != count) {\n+      false\n+    } else if (len == 0 && count == 0) {\n+      true\n+    } else {\n+      regionMatches(0, _String.valueOf(cs.toString), 0, len)\n+    }\n+  }\n+\n+  def matches(expr: _String): scala.Boolean =\n+    Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+\n+  def split(expr: _String): Array[String] =\n+    Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[String] =\n+    Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence =\n+    subString(start, end)\n+\n+  def codePointAt(index: Int): Int =\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointAt(value, index + offset, offset + count)\n+    }\n+\n+  def codePointBefore(index: Int): Int =\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointBefore(value, index + offset)\n+    }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int =\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointCount(\n+          value, beginIndex + offset, endIndex - beginIndex)\n+    }\n+\n+  def contains(cs: CharSequence): scala.Boolean =\n+    indexOf(_String.valueOf(cs.toString)) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r =\n+      Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n+\n+  def getValue(): Array[Char] = value\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  final val CASE_INSENSITIVE_ORDER: Comparator[_String] =\n+    new CaseInsensitiveComparator()\n+  private final val ascii = new Array[Char](128)\n+  private var DefaultCharset: Charset = _\n+  private var lastCharset: Charset    = _\n+\n+  var i = 0"
  },
  {
    "id" : "7eb90cf3-2418-4439-a1d5-356d351385e8",
    "prId" : 140,
    "comments" : [
      {
        "id" : "ab02b16f-5065-4976-8a9a-f19286d38574",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This method is not necessary any longer. \n",
        "createdAt" : "2016-06-03T15:21:57Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,812 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value               = new Array[Char](0)\n+  private var offset              = 0\n+  private var count               = 0\n+  private var cachedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = {\n+        val value = new Array[Char](length)\n+        var i = 0\n+        while (i < length) {\n+          value(i) = ((high & 0xff) << 8 | (data(start + i) & 0xff)).toChar\n+          i += 1\n+        }\n+        value\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    offset = 0\n+    val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+    value = charBuffer.array\n+    count = charBuffer.length\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new IndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    value = sb.getValue\n+    count = sb.length\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      this.offset = 0\n+      this.value = new Array[Char](count * 2)\n+      this.count = {\n+        var c = 0\n+        var i = offset\n+        while (i < offset + count) {\n+          c += Character.toChars(codePoints(i), this.value, c)\n+          i += 1\n+        }\n+        c\n+      }\n+    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char =\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+\n+  private def toLowerCase(ch: Char): Char =\n+    Character.toLowerCase(ch)\n+\n+  private def toUpperCase(ch: Char): Char =\n+    Character.toUpperCase(ch)\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val c1: Char    = compareValue(value(o1))\n+      val c2: Char    = compareValue(string.value(o2))\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = Charset.defaultCharset()"
  },
  {
    "id" : "6b8afe97-2e95-4f4b-9d56-9c839d6336b3",
    "prId" : 140,
    "comments" : [
      {
        "id" : "b40cda37-c641-46ef-8769-00660bedd9da",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This class has to be nested inside of the String class, not object. \n",
        "createdAt" : "2016-06-03T15:29:52Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52e88015-361f-43bb-8f07-d2f93842b108",
        "parentId" : "b40cda37-c641-46ef-8769-00660bedd9da",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Are you sure? What is this class anyway? It doesn't seem to exist in the JavaDoc.\n",
        "createdAt" : "2016-06-03T15:48:13Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c1417ed8-11dd-4768-bfae-c114665c3204",
        "parentId" : "b40cda37-c641-46ef-8769-00660bedd9da",
        "author" : {
          "login" : "t-hiroyoshi",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10783208?u=ee3909d61fb9f79884f23df85f5313e7d90855d0&v=4"
        },
        "body" : "This class was ported from harmony https://github.com/apache/harmony/blob/724deb045a85b722c961d8b5a83ac7a697319441/classlib/modules/luni/src/main/java/java/lang/String.java#L62\n",
        "createdAt" : "2016-06-03T15:54:22Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "t-hiroyoshi",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10783208?u=ee3909d61fb9f79884f23df85f5313e7d90855d0&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "38f38cc9-40af-4ded-b89b-0e56dadad70c",
        "parentId" : "b40cda37-c641-46ef-8769-00660bedd9da",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "My bad. It's an artifact of Apache Harmony's implementation. No change necessary here.\n",
        "createdAt" : "2016-06-03T15:55:59Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2d68ea4d-fe21-466a-a5c0-2eba385624b0",
        "parentId" : "b40cda37-c641-46ef-8769-00660bedd9da",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "It does not seem to be used. IMO it should be removed, unless and until it proves useful.\n",
        "createdAt" : "2016-06-03T15:59:07Z",
        "updatedAt" : "2016-06-04T06:40:17Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d30e3acc4a222380e98ab23d884f1ae4aa1ae4a1",
    "line" : null,
    "diffHunk" : "@@ -1,42 +1,812 @@\n package java.lang\n \n-import java.io.Serializable\n-\n-class _String private() extends CharSequence with Serializable with Comparable[_String] {\n-  def this(value: Array[scala.Char], offset: scala.Int, count: scala.Int) = this()\n-\n-  def length(): scala.Int = ???\n-  def charAt(index: scala.Int): Char = ???\n-  def compareTo(another_String: _String): scala.Int = ???\n-  def subSequence(beginIndex: scala.Int, endIndex: scala.Int): CharSequence = ???\n-  def concat(str: _String): _String = ???\n-  def indexOf(ch: scala.Int): scala.Int = ???\n-  def indexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int): scala.Int = ???\n-  def lastIndexOf(ch: scala.Int, fromIndex: scala.Int): scala.Int = ???\n-  def substring(beginIndex: scala.Int): _String = ???\n-  def substring(beginIndex: scala.Int, endIndex: scala.Int): _String = ???\n-  def startsWith(prefix: _String): scala.Boolean = ???\n-  def toLowerCase(): _String = ???\n-  def toCharArray(): Array[Char] = ???\n-  def equalsIgnoreCase(str: _String): scala.Boolean = ???\n-  def getChars(srcBegin: scala.Int, srcEnd: scala.Int, dst: Array[scala.Char],\n-      dstBegin: scala.Int): Unit = ???\n-  override def hashCode(): scala.Int = ???\n-\n-  // TODO: rest of the api\n+import java.io.{Serializable, UnsupportedEncodingException}\n+import java.util._\n+import java.util.regex._\n+import java.nio._\n+import java.nio.charset._\n+\n+final class _String()\n+    extends Serializable with Comparable[_String] with CharSequence {\n+  private var value               = new Array[Char](0)\n+  private var offset              = 0\n+  private var count               = 0\n+  private var cachedHashCode: Int = _\n+\n+  def this(data: Array[scala.Byte], high: Int, start: Int, length: Int) = {\n+    this()\n+    if (length <= data.length - start && start >= 0 && 0 <= length) {\n+      offset = 0\n+      value = {\n+        val value = new Array[Char](length)\n+        var i = 0\n+        while (i < length) {\n+          value(i) = ((high & 0xff) << 8 | (data(start + i) & 0xff)).toChar\n+          i += 1\n+        }\n+        value\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: Charset) = {\n+    this()\n+    offset = 0\n+    val charBuffer = encoding.decode(ByteBuffer.wrap(data, start, length))\n+    value = charBuffer.array\n+    count = charBuffer.length\n+  }\n+\n+  def this(\n+      data: Array[scala.Byte], start: Int, length: Int, encoding: _String) =\n+    this(data, start, length, Charset.forName(encoding))\n+\n+  def this(data: Array[scala.Byte], start: Int, length: Int) =\n+    this(data, start, length, Charset.defaultCharset())\n+\n+  def this(data: Array[scala.Byte], high: Int) =\n+    this(data, high, 0, data.length)\n+\n+  def this(data: Array[scala.Byte], encoding: _String) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte], encoding: Charset) =\n+    this(data, 0, data.length, encoding)\n+\n+  def this(data: Array[scala.Byte]) =\n+    this(data, 0, data.length)\n+\n+  def this(data: Array[Char], start: Int, length: Int) = {\n+    this()\n+    if (start >= 0 && 0 <= length && length <= data.length - start) {\n+      offset = 0\n+      value = new Array[Char](length)\n+      count = length\n+      System.arraycopy(data, start, value, 0, count)\n+    } else {\n+      throw new IndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def this(data: Array[Char]) =\n+    this(data, 0, data.length)\n+\n+  def this(start: Int, length: Int, data: Array[Char]) = {\n+    this()\n+    value = data\n+    offset = start\n+    count = length\n+  }\n+\n+  def this(string: _String) = {\n+    this()\n+    value = string.value\n+    offset = string.offset\n+    count = string.length()\n+  }\n+\n+  def this(sb: StringBuffer) {\n+    this()\n+    offset = 0\n+    value = sb.getValue\n+    count = sb.length\n+  }\n+\n+  def this(codePoints: Array[Int], offset: Int, count: Int) {\n+    this()\n+    if (offset < 0 || count < 0 || offset > codePoints.length - count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      this.offset = 0\n+      this.value = new Array[Char](count * 2)\n+      this.count = {\n+        var c = 0\n+        var i = offset\n+        while (i < offset + count) {\n+          c += Character.toChars(codePoints(i), this.value, c)\n+          i += 1\n+        }\n+        c\n+      }\n+    }\n+  }\n+\n+  def this(sb: java.lang.StringBuilder) {\n+    this()\n+    offset = 0\n+    count = sb.length\n+    value = new Array[Char](count)\n+    sb.getChars(0, count, value, 0)\n+  }\n+\n+  def charAt(index: Int): Char = {\n+    if (0 <= index && index < count) {\n+      value(offset + index)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  private def compareValue(ch: Char): Char =\n+    Character.toLowerCase(Character.toUpperCase(ch))\n+\n+  private def toLowerCase(ch: Char): Char =\n+    Character.toLowerCase(ch)\n+\n+  private def toUpperCase(ch: Char): Char =\n+    Character.toUpperCase(ch)\n+\n+  def compareTo(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val result: Int = value(o1) - string.value(o2)\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def compareToIgnoreCase(string: _String): Int = {\n+    var o1 = offset\n+    var o2 = string.offset\n+    val end =\n+      if (count < string.count) offset + count\n+      else offset + string.count\n+    while (o1 < end) {\n+      o1 += 1\n+      o2 += 1\n+      val c1: Char    = compareValue(value(o1))\n+      val c2: Char    = compareValue(string.value(o2))\n+      val result: Int = c1 - c2\n+      if (result != 0) {\n+        return result\n+      }\n+    }\n+    count - string.count\n+  }\n+\n+  def concat(string: _String): _String = {\n+    if (string.count == 0) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count + string.count)\n+\n+      if (count > 0) {\n+        System.arraycopy(value, offset, buffer, 0, count)\n+      }\n+\n+      System.arraycopy(\n+          string.value, string.offset, buffer, count, string.count)\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n+\n+  private def defaultCharset(): Charset = Charset.defaultCharset()\n+\n+  def endsWith(suffix: _String): scala.Boolean =\n+    regionMatches(count - suffix.count, suffix, 0, suffix.count)\n+\n+  override def equals(obj: Any): scala.Boolean = {\n+    if (obj == this) {\n+      true\n+    } else {\n+      obj match {\n+        case s: _String =>\n+          val thisHash = this.hashCode()\n+          val thatHash = s.hashCode()\n+\n+          if (count != s.count ||\n+              (thisHash != thatHash && thisHash != 0 && thatHash != 0)) {\n+            false\n+          } else {\n+            var i = 0\n+            while (i < count) {\n+              if (value(offset + i) != s.value(s.offset + i)) {\n+                return false\n+              } else {\n+                i += 1\n+              }\n+            }\n+\n+            true\n+          }\n+        case _ =>\n+          false\n+      }\n+    }\n+  }\n+\n+  def equalsIgnoreCase(string: _String): scala.Boolean = {\n+    if (string == this) {\n+      true\n+    } else if (string == null || count != string.count) {\n+      false\n+    } else {\n+      var o1 = offset\n+      var o2 = string.offset\n+      while (o1 < offset + count) {\n+        o1 += 1\n+        o2 += 1\n+        val c1 = value(o1)\n+        val c2 = string.value(o2)\n+        if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+            toLowerCase(c1) != toLowerCase(c2)) {\n+          return false\n+        }\n+      }\n+      true\n+    }\n+  }\n+\n+  def getBytes(): Array[scala.Byte] = {\n+    val buffer = defaultCharset().encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  @Deprecated\n+  def getBytes(\n+      start: Int, _end: Int, data: Array[scala.Byte], _index: Int): Unit = {\n+    var end = _end\n+    if (0 <= start && start <= end && end <= count) {\n+      end += offset\n+\n+      try {\n+        var index = _index\n+        var i     = offset + start\n+        while (i < end) {\n+          index += 1\n+          data(index) = value(i).toByte\n+          i += 1\n+        }\n+      } catch {\n+        case e: ArrayIndexOutOfBoundsException =>\n+          throw new StringIndexOutOfBoundsException()\n+      }\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  def getBytes(encoding: _String): Array[scala.Byte] = {\n+    val charset = Charset.forName(encoding)\n+    val buffer  = charset.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes   = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getBytes(encoding: Charset): Array[scala.Byte] = {\n+    val buffer = encoding.encode(CharBuffer.wrap(value, offset, count))\n+    val bytes  = new Array[scala.Byte](buffer.limit())\n+    buffer.get(bytes)\n+    bytes\n+  }\n+\n+  def getChars(start: Int, end: Int, buffer: Array[Char], index: Int): Unit = {\n+    if (0 <= start && start <= end && end <= count) {\n+      System.arraycopy(value, start + offset, buffer, index, end - start)\n+    } else {\n+      throw new StringIndexOutOfBoundsException()\n+    }\n+  }\n+\n+  override def hashCode(): Int = {\n+    if (cachedHashCode == 0) {\n+      cachedHashCode = {\n+        var hash = 0\n+        var i    = offset\n+        while (i < count + offset) {\n+          hash = value(i) + ((hash << 5) - hash)\n+          i += 1\n+        }\n+        hash\n+      }\n+    }\n+    cachedHashCode\n+  }\n+\n+  def indexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start < count) {\n+      if (start < 0) {\n+        start = 0\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i < offset + count) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i += 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i < count) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i += 1\n+          }\n+\n+          i += 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def indexOf(c: Int): Int = indexOf(c, 0)\n+\n+  def indexOf(string: _String): Int = indexOf(string, 0)\n+\n+  def indexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    if (start < 0) {\n+      start = 0\n+    }\n+    val subCount = subString.count\n+    if (subCount > 0) {\n+      if (subCount + start > count) {\n+        return -1\n+      } else {\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = indexOf(firstChar, start)\n+          if (i == -1 || subCount + i > count) {\n+            return -1\n+          }\n+\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i + 1\n+        }\n+      }\n+    }\n+    if (start < count) start else count\n+  }\n+\n+//  def intern(): _String = ???\n+\n+  def lastIndexOf(c: Int, _start: Int): Int = {\n+    var start = _start\n+    if (start >= 0) {\n+      if (start >= count) {\n+        start = count - 1\n+      }\n+      if (c >= 0 && c <= Character.MAX_VALUE) {\n+        var i = offset + start\n+        while (i >= offset) {\n+          if (value(i) == c) {\n+            return i - offset\n+          } else {\n+            i -= 1\n+          }\n+        }\n+      } else if (c > Character.MAX_VALUE && c <= Character.MAX_CODE_POINT) {\n+        var i = start\n+        while (i >= 0) {\n+          val codePoint = codePointAt(i)\n+          if (codePoint == c) {\n+            return i\n+          } else if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            i -= 1\n+          }\n+\n+          i -= 1\n+        }\n+      }\n+    }\n+    -1\n+  }\n+\n+  def lastIndexOf(c: Int): Int = lastIndexOf(c, count - 1)\n+\n+  def lastIndexOf(subString: _String, _start: Int): Int = {\n+    var start = _start\n+    val subCount = subString.count\n+    if (subCount <= count && start >= 0) {\n+      if (subCount > 0) {\n+        if (start > count - subCount) {\n+          start = count - subCount\n+        }\n+        val target    = subString.value\n+        val subOffset = subString.offset\n+        val firstChar = target(subOffset)\n+        val end       = subOffset + subCount\n+        while (true) {\n+          val i = lastIndexOf(firstChar, start)\n+          if (i == -1) {\n+            return -1\n+          }\n+          val o1 = offset + i\n+          val o2 = subOffset\n+          while (o2 < end && value(o1) == target(o2)) {}\n+          if (o2 == end) {\n+            return i\n+          }\n+          start = i - 1\n+        }\n+      }\n+\n+      if (start < count) start else count\n+    } else {\n+      -1\n+    }\n+  }\n+\n+  def length(): Int = count\n+\n+  def isEmpty(): scala.Boolean = 0 == count\n+\n+  def regionMatches(thisStart: Int,\n+                    string: _String,\n+                    start: Int,\n+                    length: Int): scala.Boolean = {\n+    if (string.count - start < length || start < 0) {\n+      false\n+    } else if (thisStart < 0 || count - thisStart < length) {\n+      false\n+    } else if (length <= 0) {\n+      true\n+    } else {\n+      val o1 = offset + thisStart\n+      val o2 = string.offset + start\n+\n+      var i = 0\n+      while (i < length) {\n+        if (value(o1 + i) != string.value(o2 + i)) {\n+          return false\n+        }\n+        i += 1\n+      }\n+\n+      true\n+    }\n+  }\n+\n+  def regionMatches(ignoreCase: scala.Boolean,\n+                    _thisStart: Int,\n+                    string: _String,\n+                    _start: Int,\n+                    length: Int): scala.Boolean = {\n+    var thisStart = _thisStart\n+    var start     = _start\n+    if (!ignoreCase) {\n+      regionMatches(thisStart, string, start, length)\n+    } else if (string != null) {\n+      if (thisStart < 0 || length > count - thisStart) {\n+        false\n+      } else if (start < 0 || length > string.count - start) {\n+        false\n+      } else {\n+        thisStart += offset\n+        start += string.offset\n+        val end    = thisStart + length\n+        val target = string.value\n+\n+        while (thisStart < end) {\n+          thisStart += 1\n+          start += 1\n+          val c1 = value(thisStart)\n+          val c2 = target(start)\n+          if (c1 != c2 && toUpperCase(c1) != toUpperCase(c2) &&\n+              toLowerCase(c1) != toLowerCase(c2)) {\n+            return false\n+          }\n+        }\n+\n+        true\n+      }\n+    } else {\n+      throw new NullPointerException()\n+    }\n+  }\n+\n+  def replace(oldChar: Char, newChar: Char): _String = {\n+    var index = indexOf(oldChar, 0)\n+    if (index == -1) {\n+      this\n+    } else {\n+      val buffer = new Array[Char](count)\n+      System.arraycopy(value, offset, buffer, 0, count)\n+\n+      do {\n+        index += 1\n+        buffer(index) = newChar\n+        index = indexOf(oldChar, index)\n+      } while (index != -1)\n+\n+      new _String(0, count, buffer)\n+    }\n+  }\n+\n+  def replace(target: CharSequence, replacement: CharSequence): _String = {\n+    if (target == null) {\n+      throw new NullPointerException(\"target should not be null\")\n+    } else if (replacement == null) {\n+      throw new NullPointerException(\"replacement should not be null\")\n+    } else {\n+      val ts = target.toString\n+      var index = indexOf(ts, 0)\n+\n+      if (index == -1) return this\n+\n+      val rs = replacement.toString\n+\n+      if (\"\".equals(rs)) {\n+        val buffer =\n+          new java.lang.StringBuilder(count + (rs.length * (count + 1)))\n+        buffer.append(rs)\n+\n+        var i = 0\n+        while (i < count) {\n+          buffer.append(value(offset + i))\n+          buffer.append(rs)\n+          i += 1\n+        }\n+\n+        return buffer.toString\n+      }\n+\n+      val buffer = new java.lang.StringBuilder(count + rs.length)\n+      val tl     = target.length\n+      var tail = 0\n+      do {\n+        buffer.append(value, offset + tail, index - tail)\n+        buffer.append(rs)\n+        tail = index + tl\n+        index = indexOf(ts, tail)\n+      } while (index != -1)\n+      buffer.append(value, offset + tail, count - tail)\n+\n+      buffer.toString\n+    }\n+  }\n+\n+  def startsWith(prefix: _String, start: Int): scala.Boolean =\n+    regionMatches(start, prefix, 0, prefix.count)\n+\n+  def startsWith(prefix: _String): scala.Boolean =\n+    startsWith(prefix, 0)\n+\n+  def subString(start: Int): _String =\n+    if (start == 0) {\n+      this\n+    } else if (0 <= start && start <= count) {\n+      new _String(offset + start, count - start, value)\n+    } else {\n+      throw new StringIndexOutOfBoundsException(start)\n+    }\n+\n+  def subString(start: Int, end: Int): _String =\n+    if (start == 0 && end == count) {\n+      this\n+    } else {\n+      if (start < 0) {\n+        throw new StringIndexOutOfBoundsException(start)\n+      } else if (start > end) {\n+        throw new StringIndexOutOfBoundsException(end - start)\n+      } else if (end > count) {\n+        throw new StringIndexOutOfBoundsException(end)\n+      }\n+\n+      new _String(offset + start, end - start, value)\n+    }\n+\n+  def toCharArray(): Array[Char] = {\n+    val buffer = new Array[Char](count)\n+    System.arraycopy(value, offset, buffer, 0, count)\n+    buffer\n+  }\n+\n+  def toLowerCase(locale: Locale): _String = ???\n+\n+  def toLowerCase(): _String =\n+    toLowerCase(Locale.getDefault)\n+\n+  override def toString(): String = this.asInstanceOf[_String]\n+\n+  def toUpperCase(locale: Locale): _String = ???\n+\n+  def toUpperCase(): _String =\n+    toUpperCase(Locale.getDefault)\n+\n+  def trim(): _String = {\n+    var start = offset\n+    val last = offset + count - 1\n+    var end = last\n+\n+    while ( (start <= end) && (value(start) <= ' ')) {\n+      start += 1\n+    }\n+\n+    while ( (end >= start) && (value(end) <= ' ')) {\n+      end -= 1\n+    }\n+\n+    if (start == offset && end == last) {\n+      this\n+    } else {\n+      new _String(start, end - start + 1, value)\n+    }\n+  }\n+\n+  def contentEquals(sb: StringBuffer): scala.Boolean = {\n+    val size = sb.length\n+    if (count != size) {\n+      false\n+    } else {\n+      regionMatches(0, new _String(0, size, sb.getValue), 0, size)\n+    }\n+  }\n+\n+  def contentEquals(cs: CharSequence): scala.Boolean = {\n+    val len = cs.length\n+    if (len != count) {\n+      false\n+    } else if (len == 0 && count == 0) {\n+      true\n+    } else {\n+      regionMatches(0, _String.valueOf(cs.toString), 0, len)\n+    }\n+  }\n+\n+  def matches(expr: _String): scala.Boolean =\n+    Pattern.matches(expr, this)\n+\n+  def replaceAll(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceAll(substitute)\n+\n+  def replaceFirst(expr: _String, substitute: _String): _String =\n+    Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n+\n+  def split(expr: _String): Array[String] =\n+    Pattern.compile(expr).split(this)\n+\n+  def split(expr: _String, max: Int): Array[String] =\n+    Pattern.compile(expr).split(this, max)\n+\n+  def subSequence(start: Int, end: Int): CharSequence =\n+    subString(start, end)\n+\n+  def codePointAt(index: Int): Int =\n+    if (index < 0 || index >= count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointAt(value, index + offset, offset + count)\n+    }\n+\n+  def codePointBefore(index: Int): Int =\n+    if (index < 1 || index > count) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointBefore(value, index + offset)\n+    }\n+\n+  def codePointCount(beginIndex: Int, endIndex: Int): Int =\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {\n+      throw new IndexOutOfBoundsException()\n+    } else {\n+      Character.codePointCount(\n+          value, beginIndex + offset, endIndex - beginIndex)\n+    }\n+\n+  def contains(cs: CharSequence): scala.Boolean =\n+    indexOf(_String.valueOf(cs.toString)) >= 0\n+\n+  def offsetByCodePoints(index: Int, codePointOffset: Int): Int = {\n+    val s = index + offset\n+    val r =\n+      Character.offsetByCodePoints(value, offset, count, s, codePointOffset)\n+    r - offset\n+  }\n+\n+  def getValue(): Array[Char] = value\n }\n \n object _String {\n-  def valueOf(obj: Object): _String = ???\n-  def valueOf(data: Array[Char]): _String = ???\n-  def valueOf(data: Array[Char], offset: scala.Int, count: scala.Int): _String = ???\n-  def valueOf(b: scala.Boolean): _String = ???\n-  def valueOf(c: scala.Char): _String = ???\n-  def valueOf(s: scala.Short): _String = ???\n-  def valueOf(i: scala.Int): _String = ???\n-  def valueOf(l: scala.Long): _String = ???\n-  def valueOf(f: scala.Float): _String = ???\n-  def valueOf(d: scala.Double): _String = ???\n-  def format(format: String, args: scala.Array[Object]): _String = ???\n+  final val CASE_INSENSITIVE_ORDER: Comparator[_String] =\n+    new CaseInsensitiveComparator()\n+  private final val ascii = {\n+    val ascii = new Array[Char](128)\n+    var i = 0\n+    while (i < ascii.length) {\n+      ascii(i) = i.toChar\n+      i += 1\n+    }\n+    ascii\n+  }\n+\n+  class ConsolePrintStream(out: java.io.OutputStream)"
  },
  {
    "id" : "9ce3db37-bb30-4f10-b9f0-8a93b87f9bae",
    "prId" : 173,
    "comments" : [
      {
        "id" : "8ac02e6e-a33a-442f-8c15-ee3a6a5fb2a1",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Why do you need making those visible from outside? You can just keep using normal `String` type everywhere outside of `java/lang/String.scala` and it would map to the same class at runtime automatically. \n",
        "createdAt" : "2016-06-25T10:29:54Z",
        "updatedAt" : "2016-06-25T10:30:09Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 8,
    "diffHunk" : "@@ -796,8 +796,8 @@ object _String {\n   }\n \n   import scala.language.implicitConversions\n-  @inline private implicit def _string2string(s: _String): String =\n+  @inline private[java] implicit def _string2string(s: _String): String =\n     s.asInstanceOf[String]\n-  @inline private implicit def string2_string(s: String): _String =\n+  @inline private[java] implicit def string2_string(s: String): _String ="
  },
  {
    "id" : "7c07b8b3-ce56-4cdc-b26f-926e225110b6",
    "prId" : 573,
    "comments" : [
      {
        "id" : "7afb7562-d794-45b5-a7e0-39881f7ef786",
        "parentId" : null,
        "author" : {
          "login" : "MasseGuillaume",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/921490?u=1ea96b0787a224aed96b7091c354e76d0f55960c&v=4"
        },
        "body" : "it ignores the locale for now?",
        "createdAt" : "2017-03-22T16:05:04Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "MasseGuillaume",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/921490?u=1ea96b0787a224aed96b7091c354e76d0f55960c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b62c909a-1a8a-47ba-bd8a-ac8541bbb5d2",
        "parentId" : "7afb7562-d794-45b5-a7e0-39881f7ef786",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "Yes, `Locale` is not used for now. In Harmony 6.0 there was a special case for Turkish. The newer Harmony https://github.com/apache/harmony/blob/java6/classlib/modules/luni/src/main/java/java/lang/String.java#L1629-L1642 defers to icu4j `UCharacter` which defers to `UCaseProps` which has a couple of special cases for Turkish and Lithuanian but I think this should get us pretty close. Overall, this stuff is really complex especially icu4j which is a complete Unicode implementation.\r\n\r\nAlso, we are waiting for `System.getProperties: Properties` so that we can create a `Locale` object based on `LANG` in the `env`. See #577.",
        "createdAt" : "2017-03-22T17:05:35Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75b2bc6a-01b6-442d-addb-d94a69d09f5a",
        "parentId" : "7afb7562-d794-45b5-a7e0-39881f7ef786",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "I think it's acceptable to ignore it for now as long as there is an issue open. We'll improve it later on.",
        "createdAt" : "2017-03-31T11:42:13Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cbdf364c98063d7d7b2615615657b4ad61487cd",
    "line" : null,
    "diffHunk" : "@@ -633,18 +633,49 @@ final class _String()\n     buffer\n   }\n \n-  def toLowerCase(locale: Locale): _String = ???\n+  def toLowerCase(locale: Locale): _String = {\n+    toCase(locale, Character.toLowerCase)\n+  }\n \n   def toLowerCase(): _String =\n     toLowerCase(Locale.getDefault)\n \n   override def toString(): String = this\n \n-  def toUpperCase(locale: Locale): _String = ???\n-\n+  def toUpperCase(locale: Locale): _String = {\n+    toCase(locale, Character.toUpperCase)\n+  }\n   def toUpperCase(): _String =\n     toUpperCase(Locale.getDefault)\n \n+  private[this] def toCase(locale: Locale, convert: Int => Int): _String = {\n+    if (count == 0) value"
  },
  {
    "id" : "fb65bbae-68bf-4f2c-8f4d-e34e0b02225e",
    "prId" : 573,
    "comments" : [
      {
        "id" : "7a122101-19b0-47da-8bbe-78e92419eb13",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Redundant curly braces around the method body. ",
        "createdAt" : "2017-03-31T11:42:32Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cbdf364c98063d7d7b2615615657b4ad61487cd",
    "line" : null,
    "diffHunk" : "@@ -633,18 +633,52 @@ final class _String()\n     buffer\n   }\n \n-  def toLowerCase(locale: Locale): _String = ???\n+  def toLowerCase(locale: Locale): _String = {\n+    toCase(locale, Character.toLowerCase)\n+  }\n \n   def toLowerCase(): _String =\n     toLowerCase(Locale.getDefault)\n \n   override def toString(): String = this\n \n-  def toUpperCase(locale: Locale): _String = ???\n-\n+  def toUpperCase(locale: Locale): _String = {\n+    toCase(locale, Character.toUpperCase)\n+  }"
  },
  {
    "id" : "30ccd81a-0875-4d08-bc40-0762ba89291c",
    "prId" : 573,
    "comments" : [
      {
        "id" : "6eb07e12-c57e-472f-91ad-6faad871c1e2",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Redundant curly braces around the method body.",
        "createdAt" : "2017-03-31T11:59:08Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cbdf364c98063d7d7b2615615657b4ad61487cd",
    "line" : null,
    "diffHunk" : "@@ -633,18 +633,52 @@ final class _String()\n     buffer\n   }\n \n-  def toLowerCase(locale: Locale): _String = ???\n+  def toLowerCase(locale: Locale): _String = {\n+    toCase(locale, Character.toLowerCase)\n+  }"
  },
  {
    "id" : "ed0c91ae-bedc-42ac-acc1-c499e5b87b18",
    "prId" : 573,
    "comments" : [
      {
        "id" : "eebc2a42-1144-4d0a-8e84-5b2b409ac81c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Did you mean `if (count == 0) return value` ? Currently this check doesn't do anything. ",
        "createdAt" : "2017-03-31T12:03:08Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "667d82ec-a1cf-45fb-8e3e-83ed65082383",
        "parentId" : "eebc2a42-1144-4d0a-8e84-5b2b409ac81c",
        "author" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "body" : "My intent here was to handle the empty String case - yes that is what I meant. I think it needs to be `return this` though.",
        "createdAt" : "2017-03-31T12:21:01Z",
        "updatedAt" : "2017-03-31T13:35:10Z",
        "lastEditedBy" : {
          "login" : "ekrich",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/933058?u=072fbca7645ffc9b0d6981f51b91eeeafb93c4cc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cbdf364c98063d7d7b2615615657b4ad61487cd",
    "line" : null,
    "diffHunk" : "@@ -633,18 +633,52 @@ final class _String()\n     buffer\n   }\n \n-  def toLowerCase(locale: Locale): _String = ???\n+  def toLowerCase(locale: Locale): _String = {\n+    toCase(locale, Character.toLowerCase)\n+  }\n \n   def toLowerCase(): _String =\n     toLowerCase(Locale.getDefault)\n \n   override def toString(): String = this\n \n-  def toUpperCase(locale: Locale): _String = ???\n-\n+  def toUpperCase(locale: Locale): _String = {\n+    toCase(locale, Character.toUpperCase)\n+  }\n   def toUpperCase(): _String =\n     toUpperCase(Locale.getDefault)\n \n+  private[this] def toCase(locale: Locale, convert: Int => Int): _String = {\n+    if (count == 0) value"
  },
  {
    "id" : "2a2c2feb-951f-4b14-9770-35fe32afa671",
    "prId" : 616,
    "comments" : [
      {
        "id" : "bdffe7bc-18be-4053-9d2b-d5cb94b70b0f",
        "parentId" : null,
        "author" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "body" : "This special case is bogus given that `rs.length == 0` so this would be `StringBuilder(count)` and below the `buffer.append(rs)` is a noop. Is this optimization needed?",
        "createdAt" : "2017-04-05T03:14:49Z",
        "updatedAt" : "2017-04-06T02:56:07Z",
        "lastEditedBy" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c35e4e2f-8ee6-430e-a63d-b992200c2fd4",
        "parentId" : "bdffe7bc-18be-4053-9d2b-d5cb94b70b0f",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "It should have been `\"\".equals(ts)` instead. The reason is that `str.replace(\"\", \"foobar\")` should insert foobar before the string, in between every character of the string, and at the end.",
        "createdAt" : "2017-04-05T09:46:18Z",
        "updatedAt" : "2017-04-06T02:56:07Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e35cc4ab-2c77-4844-8d0c-521920e7faf9",
        "parentId" : "bdffe7bc-18be-4053-9d2b-d5cb94b70b0f",
        "author" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "body" : "Finally, you the bug was this equals check.",
        "createdAt" : "2017-04-06T02:58:26Z",
        "updatedAt" : "2017-04-06T02:58:26Z",
        "lastEditedBy" : {
          "login" : "jonas",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/8417?u=fd2f29f433df62751b5690a1bddee04bb4627d21&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bdf0cccb109bd42dbba08eabae8e0c2d6b341291",
    "line" : null,
    "diffHunk" : "@@ -560,28 +560,15 @@ final class _String()\n     } else if (replacement == null) {\n       throw new NullPointerException(\"replacement should not be null\")\n     } else {\n+      if (target.length == 0) return this\n+\n       val ts    = target.toString\n       var index = indexOf(ts, 0)\n \n       if (index == -1) return this\n \n       val rs = replacement.toString\n \n-      if (\"\".equals(rs)) {\n-        val buffer =\n-          new java.lang.StringBuilder(count + (rs.length * (count + 1)))"
  },
  {
    "id" : "e6a7d676-7714-455e-902f-58dc884ba479",
    "prId" : 1220,
    "comments" : [
      {
        "id" : "7dd24be2-9fbe-4a1e-bd4a-ab8bf32da55c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Please put curly braces around then branch. We tend to either have no curlies at all (small/single-line ifs) or curlies for both then and else cases.",
        "createdAt" : "2018-07-10T11:41:09Z",
        "updatedAt" : "2018-07-11T00:50:08Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f59e7def-100b-426c-9952-c19d4f8c7292",
        "parentId" : "7dd24be2-9fbe-4a1e-bd4a-ab8bf32da55c",
        "author" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "body" : "Make sense. Done.",
        "createdAt" : "2018-07-11T00:50:14Z",
        "updatedAt" : "2018-07-11T00:50:14Z",
        "lastEditedBy" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3a94f36cbba6dd6174d008e0dd2a00ef4ec4259f",
    "line" : null,
    "diffHunk" : "@@ -733,11 +733,56 @@ final class _String()\n   def replaceFirst(expr: _String, substitute: _String): _String =\n     Pattern.compile(expr).matcher(this).replaceFirst(substitute)\n \n+  def fastSplit(ch: Char, max: Int): Array[String] = {\n+    var separatorCount = 0\n+    var begin          = 0\n+    var end            = 0\n+    while (separatorCount + 1 != max && { end = indexOf(ch, begin); end != -1 }) {\n+      separatorCount += 1\n+      begin = end + 1\n+    }\n+    val lastPartEnd = if (max == 0 && begin == count) {\n+      if (separatorCount == count) {\n+        return Array.empty[String]\n+      }\n+      do {\n+        begin -= 1\n+      } while (charAt(begin - 1) == ch)\n+      separatorCount -= count - begin\n+      begin\n+    } else {\n+      count\n+    }\n+\n+    val result = new Array[String](separatorCount + 1)\n+    begin = 0\n+    var i = 0\n+    while (i < separatorCount) {\n+      end = indexOf(ch, begin)\n+      result(i) = substring(begin, end);\n+      begin = end + 1\n+      i += 1\n+    }\n+    result(separatorCount) = substring(begin, lastPartEnd)\n+    result\n+  }\n+\n+  private[this] final val REGEX_METACHARACTERS = \".$()[{^?*+\\\\\"\n+  @inline private def isRegexMeta(c: Char) =\n+    REGEX_METACHARACTERS.indexOf(c) >= 0\n+\n   def split(expr: _String): Array[String] =\n-    Pattern.compile(expr).split(this)\n+    split(expr, 0)\n \n   def split(expr: _String, max: Int): Array[String] =\n-    Pattern.compile(expr).split(this, max)\n+    if (isEmpty) Array(\"\")"
  },
  {
    "id" : "fc87caa1-d816-4afb-9018-8b8e69df20e6",
    "prId" : 1844,
    "comments" : [
      {
        "id" : "522520a5-98f1-430c-81f3-ee4719ba5d85",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This is uselessly inefficient for such a core class. We should avoid the double reversal. Here is another oneliner that doesn't reverse twice:\r\n```scala\r\nthis.substring(0, this.lastIndexWhere(!_.isWhitespace) + 1)\r\n```",
        "createdAt" : "2020-07-10T14:37:07Z",
        "updatedAt" : "2020-07-10T16:14:53Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d4143d33db0c36f92bbb3d2dde9471a33cc1bef0",
    "line" : null,
    "diffHunk" : "@@ -846,6 +847,39 @@ final class _String()\n     r - offset\n   }\n \n+  // Added in JDK 11.\n+  def strip(): _String = {\n+    this.stripTrailing().stripLeading()\n+  }\n+\n+  // Added in JDK 11.\n+  def stripLeading(): _String = {\n+    new _String(value.dropWhile(_.isWhitespace))\n+  }\n+\n+  // Added in JDK 11.\n+  def stripTrailing(): _String = {\n+    new _String(value.reverse.dropWhile(_.isWhitespace).reverse)"
  },
  {
    "id" : "0608d811-9cbb-40d3-afd2-e992c8874fce",
    "prId" : 1844,
    "comments" : [
      {
        "id" : "6e192ddf-cee4-4eb4-b196-e2a0a38340da",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "`new _String` is redundant and will create another copy of the string:\r\n```suggestion\r\n    value.dropWhile(_.isWhitespace)\r\n```",
        "createdAt" : "2020-07-10T14:37:35Z",
        "updatedAt" : "2020-07-10T16:14:53Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d4143d33db0c36f92bbb3d2dde9471a33cc1bef0",
    "line" : null,
    "diffHunk" : "@@ -846,6 +847,39 @@ final class _String()\n     r - offset\n   }\n \n+  // Added in JDK 11.\n+  def strip(): _String = {\n+    this.stripTrailing().stripLeading()\n+  }\n+\n+  // Added in JDK 11.\n+  def stripLeading(): _String = {\n+    new _String(value.dropWhile(_.isWhitespace))"
  },
  {
    "id" : "39fbc77e-e5d8-40a5-9a10-e1a1d959afc0",
    "prId" : 1844,
    "comments" : [
      {
        "id" : "0db433bd-7a98-41a3-9b3c-fdee0803a051",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "`forall` on an empty sequence always returns `true` (since it is the neutral operation of `&&`:\r\n```suggestion\r\n    value.forall(_.isWhitespace)\r\n```",
        "createdAt" : "2020-07-10T14:38:19Z",
        "updatedAt" : "2020-07-10T16:14:53Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d4143d33db0c36f92bbb3d2dde9471a33cc1bef0",
    "line" : null,
    "diffHunk" : "@@ -846,6 +847,39 @@ final class _String()\n     r - offset\n   }\n \n+  // Added in JDK 11.\n+  def strip(): _String = {\n+    this.stripTrailing().stripLeading()\n+  }\n+\n+  // Added in JDK 11.\n+  def stripLeading(): _String = {\n+    new _String(value.dropWhile(_.isWhitespace))\n+  }\n+\n+  // Added in JDK 11.\n+  def stripTrailing(): _String = {\n+    new _String(value.reverse.dropWhile(_.isWhitespace).reverse)\n+  }\n+\n+  // Added in JDK 11.\n+  def isBlank: scala.Boolean = {\n+    value.isEmpty || value.forall(_.isWhitespace)"
  },
  {
    "id" : "aeb7d485-0d7a-4c80-b618-9470db9ac885",
    "prId" : 1844,
    "comments" : [
      {
        "id" : "afcd672d-c9a9-42db-95a4-c91fa1cb38fb",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "```suggestion\r\n    (this: String) * count\r\n```",
        "createdAt" : "2020-07-10T14:49:57Z",
        "updatedAt" : "2020-07-10T16:14:53Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d4143d33db0c36f92bbb3d2dde9471a33cc1bef0",
    "line" : null,
    "diffHunk" : "@@ -846,6 +847,39 @@ final class _String()\n     r - offset\n   }\n \n+  // Added in JDK 11.\n+  def strip(): _String = {\n+    this.stripTrailing().stripLeading()\n+  }\n+\n+  // Added in JDK 11.\n+  def stripLeading(): _String = {\n+    new _String(value.dropWhile(_.isWhitespace))\n+  }\n+\n+  // Added in JDK 11.\n+  def stripTrailing(): _String = {\n+    new _String(value.reverse.dropWhile(_.isWhitespace).reverse)\n+  }\n+\n+  // Added in JDK 11.\n+  def isBlank: scala.Boolean = {\n+    value.isEmpty || value.forall(_.isWhitespace)\n+  }\n+\n+  // Added in JDK 11.\n+  def lines(): Stream[_String] = {\n+    val split = this.split(\"\\r\\n\").flatMap(_.split(\"\\r\")).flatMap(_.split(\"\\n\"))\n+    Stream.of(split.asInstanceOf[Array[AnyRef]])\n+  }\n+\n+  // Added in JDK 11.\n+  def repeat(count: Int): _String = {\n+    new _String((0 until count).foldRight(Array.empty[Char]) { (_, soFar) =>\n+      soFar ++ value\n+    })"
  },
  {
    "id" : "4d8c5020-9dcd-44dc-985b-3d3a03820e65",
    "prId" : 1844,
    "comments" : [
      {
        "id" : "731b5679-fbf4-47a6-b638-5b4843753560",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "If using `split`, you can take advantage of the fact that it accepts a regex:\r\n```scala\r\nthis.split(\"\\r\\n?|\\n\")\r\n```\r\n",
        "createdAt" : "2020-07-10T15:06:38Z",
        "updatedAt" : "2020-07-10T16:14:53Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d4143d33db0c36f92bbb3d2dde9471a33cc1bef0",
    "line" : null,
    "diffHunk" : "@@ -846,6 +847,39 @@ final class _String()\n     r - offset\n   }\n \n+  // Added in JDK 11.\n+  def strip(): _String = {\n+    this.stripTrailing().stripLeading()\n+  }\n+\n+  // Added in JDK 11.\n+  def stripLeading(): _String = {\n+    new _String(value.dropWhile(_.isWhitespace))\n+  }\n+\n+  // Added in JDK 11.\n+  def stripTrailing(): _String = {\n+    new _String(value.reverse.dropWhile(_.isWhitespace).reverse)\n+  }\n+\n+  // Added in JDK 11.\n+  def isBlank: scala.Boolean = {\n+    value.isEmpty || value.forall(_.isWhitespace)\n+  }\n+\n+  // Added in JDK 11.\n+  def lines(): Stream[_String] = {\n+    val split = this.split(\"\\r\\n\").flatMap(_.split(\"\\r\")).flatMap(_.split(\"\\n\"))"
  }
]
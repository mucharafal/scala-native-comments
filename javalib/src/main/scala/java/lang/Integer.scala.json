[
  {
    "id" : "8204a12d-7fab-427e-859f-8562fcb09b53",
    "prId" : 173,
    "comments" : [
      {
        "id" : "48d5482f-1d51-40b6-8e24-b77dd50d4282",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`undefined` body.\n",
        "createdAt" : "2016-06-21T11:39:20Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -133,43 +320,277 @@ object Integer {\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n \n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): _String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new _String(0, count, buffer)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar\n+          }\n+\n+          k += 1\n+        }\n+\n+        last_digit += 1\n+        buffer(last_digit) = (positive_value + '0').toChar\n+        last_digit -= 1\n+        count = last_digit\n+\n+        new _String(0, count, buffer)\n+      }\n+    }\n+  }\n \n-  def toBinaryString(i: scala.Int): String = toStringBase(i, 2)\n-  def toHexString(i: scala.Int): String    = toStringBase(i, 16)\n-  def toOctalString(i: scala.Int): String  = toStringBase(i, 8)\n+  @inline def toString(_i: scala.Int, _radix: scala.Int): _String = {\n+    if (_i == 0) {\n+      \"0\"\n+    } else {\n+      val radix =\n+        if (_radix < Character.MIN_RADIX || _radix > Character.MAX_RADIX) 10\n+        else _radix\n+      val negative = _i < 0\n+      var (count, j) = if (negative) (2, _i) else (1, -_i)\n+      var i          = _i\n+      while (i != 0) {\n+        count += 1\n+        i = i / radix\n+      }\n+\n+      val buffer = new Array[Char](count)\n+      do {\n+        var ch = 0 - (j % radix)\n+        if (ch > 9) {\n+          ch = ch - 10 + 'a'\n+        } else {\n+          ch += '0'\n+        }\n+        buffer(count) = ch.toChar\n+        j = j / radix\n+      } while (j != 0)\n+\n+      if (negative) {\n+        buffer(0) = '-'\n+      }\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n \n-  @inline // because radix is almost certainly constant at call site\n-  def toString(i: Int, radix: Int): String = ???\n+  @inline def toUnsignedLong(x: scala.Int): scala.Long ="
  },
  {
    "id" : "aa679627-4fba-42e6-9c4c-c61e1de5c052",
    "prId" : 173,
    "comments" : [
      {
        "id" : "c05b3f19-08fa-43dd-8f7a-829ca3644cb2",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:44:29Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -105,19 +157,154 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+//  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)"
  },
  {
    "id" : "910cd1bb-d4ed-432c-a831-947a49ff6cf2",
    "prId" : 173,
    "comments" : [
      {
        "id" : "722ce6f6-53c9-49d3-a194-54e41fb856cd",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:44:38Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -105,19 +157,154 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+//  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+\n+    if (result == null) new Integer(v)\n+    else result\n+  }"
  },
  {
    "id" : "7f450f8c-a230-48dd-8295-ff275070a8ef",
    "prId" : 173,
    "comments" : [
      {
        "id" : "01244945-3302-4600-843d-1a1f76e74da6",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:45:07Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -105,19 +157,154 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+//  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n+\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) 32\n+    else 31 - numberOfLeadingZeros(i & -i)\n+\n+  @inline def parseInt(s: _String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: _String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int ="
  },
  {
    "id" : "910d3224-eadc-4f84-b06e-4ba9e1144a8e",
    "prId" : 173,
    "comments" : [
      {
        "id" : "666f0616-e28f-4d56-8bf0-5f74cefb5f05",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:45:25Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -105,19 +157,154 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+//  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n+\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) 32\n+    else 31 - numberOfLeadingZeros(i & -i)\n+\n+  @inline def parseInt(s: _String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: _String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  def reverse(_i: scala.Int): scala.Int = {"
  },
  {
    "id" : "51df1fc9-80f9-4cf6-87d2-b0da0fdb4fa2",
    "prId" : 173,
    "comments" : [
      {
        "id" : "53c8c579-1661-40f5-a5d7-e3bdad41428f",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:45:29Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -105,19 +157,154 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+//  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n+\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) 32\n+    else 31 - numberOfLeadingZeros(i & -i)\n+\n+  @inline def parseInt(s: _String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: _String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  def reverse(_i: scala.Int): scala.Int = {\n+    var i = _i\n+    i = (i & 0x55555555) << 1 | (i >> 1) & 0x55555555\n+    i = (i & 0x33333333) << 2 | (i >> 2) & 0x33333333\n+    i = (i & 0x0F0F0F0F) << 4 | (i >> 4) & 0x0F0F0F0F\n+    reverseBytes(i)\n+  }\n+\n   def reverseBytes(i: scala.Int): scala.Int = {"
  },
  {
    "id" : "b4afce0f-9751-4c55-8f18-d3c7964d76d7",
    "prId" : 173,
    "comments" : [
      {
        "id" : "e5a526a4-c7b6-4247-a428-d37ae0be919e",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`@inline`\n",
        "createdAt" : "2016-06-21T11:45:48Z",
        "updatedAt" : "2016-06-24T06:14:48Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : null,
    "diffHunk" : "@@ -133,43 +320,277 @@ object Integer {\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n \n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): _String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new _String(0, buffer.length, buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): _String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new _String(0, count, buffer)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar\n+          }\n+\n+          k += 1\n+        }\n+\n+        last_digit += 1\n+        buffer(last_digit) = (positive_value + '0').toChar\n+        last_digit -= 1\n+        count = last_digit\n+\n+        new _String(0, count, buffer)\n+      }\n+    }\n+  }\n \n-  def toBinaryString(i: scala.Int): String = toStringBase(i, 2)\n-  def toHexString(i: scala.Int): String    = toStringBase(i, 16)\n-  def toOctalString(i: scala.Int): String  = toStringBase(i, 8)\n+  @inline def toString(_i: scala.Int, _radix: scala.Int): _String = {\n+    if (_i == 0) {\n+      \"0\"\n+    } else {\n+      val radix =\n+        if (_radix < Character.MIN_RADIX || _radix > Character.MAX_RADIX) 10\n+        else _radix\n+      val negative = _i < 0\n+      var (count, j) = if (negative) (2, _i) else (1, -_i)\n+      var i          = _i\n+      while (i != 0) {\n+        count += 1\n+        i = i / radix\n+      }\n+\n+      val buffer = new Array[Char](count)\n+      do {\n+        var ch = 0 - (j % radix)\n+        if (ch > 9) {\n+          ch = ch - 10 + 'a'\n+        } else {\n+          ch += '0'\n+        }\n+        buffer(count) = ch.toChar\n+        j = j / radix\n+      } while (j != 0)\n+\n+      if (negative) {\n+        buffer(0) = '-'\n+      }\n+\n+      new _String(0, buffer.length, buffer)\n+    }\n+  }\n \n-  @inline // because radix is almost certainly constant at call site\n-  def toString(i: Int, radix: Int): String = ???\n+  @inline def toUnsignedLong(x: scala.Int): scala.Long =\n+    x.toLong & 0xffffffffL\n \n-  @inline def toUnsignedString(i: scala.Int): String = toUnsignedString(i, 10)\n+  def toUnsignedString(i: scala.Int): _String ="
  },
  {
    "id" : "4e7f2d3e-d2b6-4cfa-ac24-1fd0e8dd32f1",
    "prId" : 173,
    "comments" : [
      {
        "id" : "ec002d2e-2e74-4709-880d-1041231af9dc",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "`offset++` first returns old value and then increments. It means that `offset += 1` should be after `val digit = ...`. \n",
        "createdAt" : "2016-06-25T10:26:15Z",
        "updatedAt" : "2016-06-25T10:26:15Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 156,
    "diffHunk" : "@@ -49,40 +62,79 @@ object Integer {\n   final val MAX_VALUE = 2147483647\n   final val SIZE      = 32\n   final val BYTES     = 4\n-\n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n-\n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n-\n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n-\n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n-\n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n-\n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n-\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n   @inline\n-  private def parseIntImpl(\n-      s: String, radix: scala.Int, signed: scala.Boolean): scala.Int = ???\n-\n-  @inline def toString(i: scala.Int): String =\n-    ???\n-\n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n-\n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n+  private def parse(s: _String,\n+                    offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = 1\n+    while (offset < length) {\n+      offset += 1\n+      val digit = Character.digit(s.charAt(offset), radix)"
  },
  {
    "id" : "9ddf8bcb-4b78-43b1-9eb4-3e564ecc80ac",
    "prId" : 173,
    "comments" : [
      {
        "id" : "76c8e85f-2c9a-46b9-b4fd-f91f0d106c3e",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one is not an intrinsic and should be implemented here. \n",
        "createdAt" : "2016-06-25T10:27:53Z",
        "updatedAt" : "2016-06-25T10:32:32Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c56e451b-5f74-4bfe-afe5-2bf25374dbde",
        "parentId" : "76c8e85f-2c9a-46b9-b4fd-f91f0d106c3e",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "On the other hand you can comment-it-out, it's out of scope of this pr. \n",
        "createdAt" : "2016-06-25T10:49:23Z",
        "updatedAt" : "2016-06-25T10:49:23Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0cb6268c-a213-4740-8003-629f4c21b417",
        "parentId" : "76c8e85f-2c9a-46b9-b4fd-f91f0d106c3e",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "A possible implementation is `compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)`.\n",
        "createdAt" : "2016-06-25T11:35:30Z",
        "updatedAt" : "2016-06-25T11:35:30Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 187,
    "diffHunk" : "@@ -105,20 +157,156 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    undefined"
  },
  {
    "id" : "897246ef-2c22-4d4f-95f9-7364cff8bd4e",
    "prId" : 173,
    "comments" : [
      {
        "id" : "a53e79b0-1121-4c22-8214-67c813ae3dd1",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `llvm.ctlz.i32` here instead. \n",
        "createdAt" : "2016-06-25T10:34:44Z",
        "updatedAt" : "2016-06-25T10:34:51Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 274,
    "diffHunk" : "@@ -105,20 +157,156 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    undefined\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int ="
  },
  {
    "id" : "49b52ee3-c419-4f9a-8e8c-c36e0d144559",
    "prId" : 173,
    "comments" : [
      {
        "id" : "6803e445-0c71-4567-b888-f89bebf30a64",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `llvm.cttz.i32` here instead. \n",
        "createdAt" : "2016-06-25T10:35:28Z",
        "updatedAt" : "2016-06-25T10:35:28Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 287,
    "diffHunk" : "@@ -105,20 +157,156 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    undefined\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int ="
  },
  {
    "id" : "6b2c9cf9-1251-4ae7-9a12-888acd686519",
    "prId" : 173,
    "comments" : [
      {
        "id" : "1f8389af-4ebc-46b8-8b64-77e0fef38feb",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `llvm.bitreverse.i32` here. \n",
        "createdAt" : "2016-06-25T10:40:07Z",
        "updatedAt" : "2016-06-25T10:40:07Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 329,
    "diffHunk" : "@@ -105,20 +157,156 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    undefined\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) 32\n+    else 31 - numberOfLeadingZeros(i & -i)\n+\n+  @inline def parseInt(s: _String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: _String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(_i: scala.Int): scala.Int = {"
  },
  {
    "id" : "5f0d72fc-18bc-46fb-8239-2d727a890202",
    "prId" : 173,
    "comments" : [
      {
        "id" : "56270d52-fcb5-4bfe-b17b-8b91f1972bb9",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use `llvm.bswap.i32` here.\n",
        "createdAt" : "2016-06-25T10:41:37Z",
        "updatedAt" : "2016-06-25T10:41:37Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89f23c892632c30d769c688317dfdcda0654b1a0",
    "line" : 337,
    "diffHunk" : "@@ -105,20 +157,156 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    undefined\n+\n+  @inline def decode(nm: _String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: _String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: _String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: _String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) {\n+      32\n+    } else {\n+      var x = i\n+      var r = 1\n+      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n+      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n+      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n+      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n+      r + (x >> 31)\n+    }\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    if (i == 0) 32\n+    else 31 - numberOfLeadingZeros(i & -i)\n+\n+  @inline def parseInt(s: _String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: _String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: _String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(_i: scala.Int): scala.Int = {\n+    var i = _i\n+    i = (i & 0x55555555) << 1 | (i >> 1) & 0x55555555\n+    i = (i & 0x33333333) << 2 | (i >> 2) & 0x33333333\n+    i = (i & 0x0F0F0F0F) << 4 | (i >> 4) & 0x0F0F0F0F\n+    reverseBytes(i)\n+  }\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int = {"
  },
  {
    "id" : "d61050cd-2586-4021-937f-4ba6c3c88349",
    "prId" : 210,
    "comments" : [
      {
        "id" : "259606a0-6914-4ebf-8ba7-fbf8070214f7",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Use [`llvm.ctpop.i32`](http://llvm.org/docs/LangRef.html#llvm-ctpop-intrinsic) here. Also add `@inline`.\n",
        "createdAt" : "2016-06-30T12:09:05Z",
        "updatedAt" : "2016-06-30T12:09:05Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 176,
    "diffHunk" : "@@ -49,40 +62,79 @@ object Integer {\n   final val MAX_VALUE = 2147483647\n   final val SIZE      = 32\n   final val BYTES     = 4\n-\n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n-\n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n-\n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n-\n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n-\n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n-\n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n-\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n   @inline\n-  private def parseIntImpl(\n-      s: String, radix: scala.Int, signed: scala.Boolean): scala.Int = ???\n-\n-  @inline def toString(i: scala.Int): String =\n-    ???\n-\n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n-\n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n+  private def parse(s: String,\n+                    offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = 1\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+      offset += 1\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n \n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n \n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n+    result\n+  }\n \n   def bitCount(i: scala.Int): scala.Int = {"
  },
  {
    "id" : "4c18e4b0-8f7a-4792-9a10-06a54f78ac4b",
    "prId" : 210,
    "comments" : [
      {
        "id" : "49725c79-ca78-4099-ad5f-ea97482b77c5",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "That's a big method, no need for `@inline`. \n",
        "createdAt" : "2016-06-30T12:12:53Z",
        "updatedAt" : "2016-06-30T12:12:53Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 146,
    "diffHunk" : "@@ -49,40 +62,79 @@ object Integer {\n   final val MAX_VALUE = 2147483647\n   final val SIZE      = 32\n   final val BYTES     = 4\n-\n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n-\n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n-\n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n-\n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n-\n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n-\n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n-\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n   @inline\n-  private def parseIntImpl(\n-      s: String, radix: scala.Int, signed: scala.Boolean): scala.Int = ???\n-\n-  @inline def toString(i: scala.Int): String =\n-    ???\n-\n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n-\n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n+  private def parse(s: String,"
  },
  {
    "id" : "c47ddf5b-9578-4f1d-b0f8-745f61c25555",
    "prId" : 210,
    "comments" : [
      {
        "id" : "c3ee4ec3-4d96-4fbd-a890-1f723c8c4fce",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "That's a big method, no need for `@inline`.\n",
        "createdAt" : "2016-06-30T12:13:07Z",
        "updatedAt" : "2016-06-30T12:13:07Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 189,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {"
  },
  {
    "id" : "eb52359e-74f5-4e2f-aa4f-cf5df79938bd",
    "prId" : 210,
    "comments" : [
      {
        "id" : "aa8d8df9-549c-4fbe-95d4-0ab97822ecc8",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "No `@inline` here either.\n",
        "createdAt" : "2016-06-30T12:13:34Z",
        "updatedAt" : "2016-06-30T12:13:34Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 438,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {"
  },
  {
    "id" : "1f42cd43-d733-493a-b5af-ea82b83a4e27",
    "prId" : 210,
    "comments" : [
      {
        "id" : "628bbef6-aa03-4672-8b61-7d73161e0ad7",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "No `@inline`.\n",
        "createdAt" : "2016-06-30T12:13:46Z",
        "updatedAt" : "2016-06-30T12:13:46Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 554,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar\n+          }\n+\n+          k += 1\n+        }\n+\n+        last_digit += 1\n+        buffer(last_digit) = (positive_value + '0').toChar\n+        last_digit -= 1\n+        count = last_digit\n+\n+        new String(buffer, 0, count)\n+      }\n+    }\n+  }\n+\n+  @inline def toString(_i: scala.Int, _radix: scala.Int): String = {"
  },
  {
    "id" : "30de37c4-e38d-4b33-b3bb-d6cefb36b339",
    "prId" : 210,
    "comments" : [
      {
        "id" : "5854b8b3-7488-4a7a-99bd-dffa78853bcd",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This part used to be `buffer[last_digit++]` in Harmony, it means `last_digit += 1` should come after `buffer(last_digit) = ...`.\n",
        "createdAt" : "2016-06-30T12:39:27Z",
        "updatedAt" : "2016-06-30T12:39:27Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 462,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar"
  },
  {
    "id" : "0cb55361-f9ee-48cc-9f27-95b431905921",
    "prId" : 210,
    "comments" : [
      {
        "id" : "691d4b8c-fdee-4f30-bafc-471cf34fbe7c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Here is the same mistake, `last_digit--` means that you first read previous value and then decrement. `val count = last_digit` needs to come before `last_digit -= 1`.\n",
        "createdAt" : "2016-06-30T12:40:33Z",
        "updatedAt" : "2016-06-30T12:40:33Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 467,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit"
  },
  {
    "id" : "789a0817-d8a5-4cd3-b341-8d39c5871907",
    "prId" : 210,
    "comments" : [
      {
        "id" : "cf34ce26-af49-4d4b-af97-f20fac23f022",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake again.\n",
        "createdAt" : "2016-06-30T12:41:08Z",
        "updatedAt" : "2016-06-30T12:41:08Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 472,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)"
  },
  {
    "id" : "239ac4d4-8dfa-42eb-a122-ee5148a1f39c",
    "prId" : 210,
    "comments" : [
      {
        "id" : "86fae5ce-a8b3-47a8-adcc-11a4f3f6becc",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake again.\n",
        "createdAt" : "2016-06-30T12:41:20Z",
        "updatedAt" : "2016-06-30T12:41:20Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 475,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp"
  },
  {
    "id" : "05859f14-edd4-4e3e-9b06-a167ee0bde95",
    "prId" : 210,
    "comments" : [
      {
        "id" : "e84e90c7-b2da-49c3-a449-364d61f0ce97",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake as before.\n",
        "createdAt" : "2016-06-30T12:50:21Z",
        "updatedAt" : "2016-06-30T12:50:21Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 503,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'"
  },
  {
    "id" : "5a764a6a-b7bd-431e-b53b-c160bfd6384b",
    "prId" : 210,
    "comments" : [
      {
        "id" : "bb7149d8-c299-4102-a521-a898d4e85a0c",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake.\n",
        "createdAt" : "2016-06-30T12:51:08Z",
        "updatedAt" : "2016-06-30T12:51:08Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 538,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar"
  },
  {
    "id" : "97c15d37-b6e1-4128-a282-586468fa27c5",
    "prId" : 210,
    "comments" : [
      {
        "id" : "39d00714-9296-4920-9615-3f6c5246dffe",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake.\n",
        "createdAt" : "2016-06-30T12:52:05Z",
        "updatedAt" : "2016-06-30T12:52:05Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 545,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar\n+          }\n+\n+          k += 1\n+        }\n+\n+        last_digit += 1\n+        buffer(last_digit) = (positive_value + '0').toChar"
  },
  {
    "id" : "56ea5a90-9441-4509-a7e7-974b61b75009",
    "prId" : 210,
    "comments" : [
      {
        "id" : "b9db3e62-adbb-4dde-a709-6e5d1b6a5edd",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "The same mistake.\n",
        "createdAt" : "2016-06-30T12:52:09Z",
        "updatedAt" : "2016-06-30T12:52:09Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d046b2267df8f07b713099c1196b41ef081948f",
    "line" : 547,
    "diffHunk" : "@@ -105,71 +157,420 @@ object Integer {\n     (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n+\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n+\n+  @inline def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n+\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n+\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n+\n+    valueOf(parse(nm, i, base, negative))\n+  }\n+\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n     divUInt(dividend, divisor)\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n+\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n+  }\n+\n+  @inline def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n+\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  @noinline def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  @inline def parseUnsignedInt(s: String): scala.Int =\n+    parseUnsignedInt(s, 10)\n+\n+  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    // toUnsignedString(i, 1)\n+    var count = 1\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    // toUnsignedString(i, 4)\n+    var count = 1\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    // toUnsignedString(i, 3)\n+    var count = 1\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      var j = i\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    var k = i\n+    val buffer = new Array[Char](count)\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  @inline def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          last_digit += 1\n+          buffer(last_digit) = digit_value.toChar\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+\n+          last_digit -= 1\n+          buffer(last_digit) = buffer(first_digit)\n+\n+          first_digit += 1\n+          buffer(first_digit) = tmp\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              last_digit += 1\n+              buffer(last_digit) = '0'\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            last_digit += 1\n+            buffer(last_digit) = (count + '0').toChar\n+          }\n+\n+          k += 1\n+        }\n+\n+        last_digit += 1\n+        buffer(last_digit) = (positive_value + '0').toChar\n+        last_digit -= 1\n+        count = last_digit"
  },
  {
    "id" : "f4630080-7480-43ff-b0f3-bb3b91ec3833",
    "prId" : 238,
    "comments" : [
      {
        "id" : "775f6832-aa15-4b1d-aab5-68a59dafcb0d",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Remove those two methods. As the comment indicate, they're an artifact of Scala.js not boxing primitives. SN should not have them.\n",
        "createdAt" : "2016-07-11T14:37:23Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7694ee8f-d924-4866-bfa9-a4a55c09fc8c",
        "parentId" : "775f6832-aa15-4b1d-aab5-68a59dafcb0d",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Done.\n",
        "createdAt" : "2016-07-11T15:45:03Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -1,45 +1,49 @@\n package java.lang\n \n-import scalanative.runtime.{divUInt, remUInt}\n+import scalanative.runtime.{divUInt, remUInt, intToULong, Intrinsics}\n \n final class Integer(override val intValue: scala.Int)\n     extends Number\n     with Comparable[Integer] {\n-  def this(s: String) = this(Integer.parseInt(s))\n+  @inline def this(s: String) =\n+    this(Integer.parseInt(s))\n \n-  @inline override def byteValue(): scala.Byte   = intValue.toByte\n-  @inline override def shortValue(): scala.Short = intValue.toShort\n-  @inline def longValue(): scala.Long            = intValue.toLong\n-  @inline def floatValue(): scala.Float          = intValue.toFloat\n-  @inline def doubleValue(): scala.Double        = intValue.toDouble\n+  @inline override def byteValue(): scala.Byte =\n+    intValue.toByte\n \n-  @inline override def equals(that: Any): scala.Boolean = that match {\n-    case that: Integer => byteValue == that.intValue\n-    case _             => false\n-  }\n+  @inline override def shortValue(): scala.Short =\n+    intValue.toShort\n+\n+  @inline def longValue(): scala.Long =\n+    intValue.toLong\n+\n+  @inline def floatValue(): scala.Float =\n+    intValue.toFloat\n \n-  @inline override def hashCode(): Int =\n+  @inline def doubleValue(): scala.Double =\n+    intValue.toDouble\n+\n+  @inline override def equals(that: Any): scala.Boolean =\n+    that match {\n+      case that: Integer =>\n+        byteValue == that.intValue\n+      case _ =>\n+        false\n+    }\n+\n+  @inline override def hashCode(): scala.Int =\n     Integer.hashCode(intValue)\n \n-  @inline override def compareTo(that: Integer): Int =\n+  @inline override def compareTo(that: Integer): scala.Int =\n     Integer.compare(intValue, that.intValue)\n \n   @inline override def toString(): String =\n     Integer.toString(intValue)\n \n-  /* Methods of java.lang.Byte and java.lang.Short.\n-   * When calling a method of j.l.Byte or j.l.Short on a primitive value,\n-   * it appears to be called directly on the primitive value, which has type\n-   * IntType. Call resolution, by the analyzer and the optimizer, will then\n-   * look for the method in the class j.l.Integer instead of j.l.Byte or\n-   * j.l.Short. This is why we add here the methods of these two classes that\n-   * are not already in j.l.Integer.\n-   */\n-\n-  @inline def compareTo(that: Byte): Int =\n+  @inline def compareTo(that: Byte): scala.Int =\n     Integer.compare(intValue, that.intValue)\n \n-  @inline def compareTo(that: Short): Int =\n+  @inline def compareTo(that: Short): scala.Int =\n     Integer.compare(intValue, that.intValue)"
  },
  {
    "id" : "871f0c8c-6353-4bdf-8196-82b366554769",
    "prId" : 238,
    "comments" : [
      {
        "id" : "c9506f8d-2b3f-45d3-aadd-c2b594926b31",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Just `v`? Same for the two other uses in this method.\n",
        "createdAt" : "2016-07-11T14:42:14Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "092b813c-89be-4d94-9759-2629e1334655",
        "parentId" : "c9506f8d-2b3f-45d3-aadd-c2b594926b31",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Fixed in https://github.com/scala-native/scala-native/pull/238/commits/f0eab14d727ad8978b63a07733f4f4a89798198f\n",
        "createdAt" : "2016-07-12T14:31:04Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)"
  },
  {
    "id" : "fc4715e1-8292-47ef-82ba-ad79ac96b40d",
    "prId" : 238,
    "comments" : [
      {
        "id" : "3a855db1-002d-4d45-b7d7-d0d746a318b6",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "This one can become branchless if we introduce `select` intrinsic.\n",
        "createdAt" : "2016-07-11T14:59:56Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1643e658-9895-4294-adae-69a3e74dd528",
        "parentId" : "3a855db1-002d-4d45-b7d7-d0d746a318b6",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Done.\n",
        "createdAt" : "2016-07-11T15:44:17Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int ="
  },
  {
    "id" : "65e6848d-b9ff-420b-80fb-1e57a7ff135a",
    "prId" : 238,
    "comments" : [
      {
        "id" : "38a69a29-6c97-4e56-8893-969d587a1c4b",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "This will blow up when `s == \"\"`\n",
        "createdAt" : "2016-07-11T15:07:54Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'"
  },
  {
    "id" : "e0896b45-217e-46a8-97e1-6448494254f8",
    "prId" : 238,
    "comments" : [
      {
        "id" : "a83a40ae-1290-447b-8df0-bdc4e80375ca",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "``` scala\nvar count = if (i == 0) 1 else 32 - numberOfLeadingZeros(i)\n```\n",
        "createdAt" : "2016-07-11T15:14:28Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      j >>>= 1\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }"
  },
  {
    "id" : "2b0ef9ee-539b-42cc-9575-ec6655d33f47",
    "prId" : 238,
    "comments" : [
      {
        "id" : "1bf33cd7-7d39-4d24-92e6-00e2d33925d9",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Something similar here.\n",
        "createdAt" : "2016-07-11T15:15:11Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "86f02b91-cd5b-4183-a66d-87e82624fcfe",
        "parentId" : "1bf33cd7-7d39-4d24-92e6-00e2d33925d9",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Fixed.\n",
        "createdAt" : "2016-07-12T12:23:25Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      j >>>= 1\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      j >>>= 4\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }"
  },
  {
    "id" : "178f53fb-6537-4178-9e2a-852510d94550",
    "prId" : 238,
    "comments" : [
      {
        "id" : "ee16f257-b9d8-4098-a89a-2b125a06b88c",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "And here.\n",
        "createdAt" : "2016-07-11T15:15:19Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7df89c4b-9a21-45c0-a3de-0d338d826620",
        "parentId" : "ee16f257-b9d8-4098-a89a-2b125a06b88c",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Fixed.\n",
        "createdAt" : "2016-07-12T12:23:19Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      j >>>= 1\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      j >>>= 4\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      j >>>= 3\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }"
  },
  {
    "id" : "ca2558bd-f337-4acf-a50a-b0f29b1042dd",
    "prId" : 238,
    "comments" : [
      {
        "id" : "5404c135-9414-442f-908a-e29887bc167e",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "I'm not sure whether you want to keep the complete semantics of the JDK. The JDK mandates that values from -128 to 127 be cached. (Same for `Byte`, `Short` and `Long`, IIRC).\n\nIt would probably be good for GC pressure as well, in the case of SN.\n",
        "createdAt" : "2016-07-11T15:20:57Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c06c68db-24c7-49c9-b3b5-769282f443a0",
        "parentId" : "5404c135-9414-442f-908a-e29887bc167e",
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "From https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#valueOf(int)\n\n> This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range.\n",
        "createdAt" : "2016-07-11T15:21:38Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ad450e70-d85c-44e7-8f3e-933c43cbcd5f",
        "parentId" : "5404c135-9414-442f-908a-e29887bc167e",
        "author" : {
          "login" : "DarkDimius",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1084930?u=4d7224bafc59d579b227c92ee0b965947186d9e2&v=4"
        },
        "body" : "A minor note: the range of values to cache is specified by undocumented option `-XX:AutoBoxCacheMax` \n",
        "createdAt" : "2016-07-11T15:32:31Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "DarkDimius",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1084930?u=4d7224bafc59d579b227c92ee0b965947186d9e2&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bef027df-23bc-47d9-98d3-6117b3fe8a21",
        "parentId" : "5404c135-9414-442f-908a-e29887bc167e",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "I think that SMI optimisation is the real solution to this performance-wise. We can pack most primitive values into pointers with tagging. This makes 90%+ of all boxing not to allocate at all and also is compliant with JVM caching semantics for -128 to 127 range of numbers. The only issue that stands in our way to do this is interaction of pointer packing with GC. \n",
        "createdAt" : "2016-07-12T12:31:39Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : 589,
    "diffHunk" : "@@ -50,127 +54,472 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n-\n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n     if (i == 0) 0\n     else (1 << 31) >>> numberOfLeadingZeros(i)\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 32\n     } else {\n-      var r = 1\n-      if ((x & 0xffff0000) == 0) { x <<= 16; r += 16 }\n-      if ((x & 0xff000000) == 0) { x <<= 8; r += 8 }\n-      if ((x & 0xf0000000) == 0) { x <<= 4; r += 4 }\n-      if ((x & 0xc0000000) == 0) { x <<= 2; r += 2 }\n-      r + (x >> 31)\n+      j >>>= 1\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 1\n+      }\n     }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n   }\n \n-  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n-    if (i == 0) 32\n-    else 31 - numberOfLeadingZeros(i & -i)\n+  def toHexString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 8\n+    } else {\n+      j >>>= 4\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 4\n+      }\n+    }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    var count = 1\n+    var j     = i\n+\n+    if (i < 0) {\n+      count = 11\n+    } else {\n+      j >>>= 3\n+      while (j != 0) {\n+        count += 1\n+        j >>>= 3\n+      }\n+    }\n+\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 7) + '0').toChar\n+      k >>>= 3\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n \n-  def toBinaryString(i: scala.Int): String = toStringBase(i, 2)\n-  def toHexString(i: scala.Int): String    = toStringBase(i, 16)\n-  def toOctalString(i: scala.Int): String  = toStringBase(i, 8)\n+  def toString(i: scala.Int): String = {\n+    if (i == 0) {\n+      \"0\"\n+    } else {\n+      val negative = i < 0\n+\n+      if (i < 1000 && i > -1000) {\n+        val buffer = new Array[Char](4)\n+        val positive_value =\n+          if (negative) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit = first_digit\n+        var quot       = positive_value\n+        do {\n+          val res = quot / 10\n+          var digit_value = quot - ((res << 3) + (res << 1))\n+          digit_value += '0'\n+          buffer(last_digit) = digit_value.toChar\n+          last_digit += 1\n+          quot = res\n+        } while (quot != 0)\n+\n+        last_digit -= 1\n+        val count = last_digit\n+        do {\n+          val tmp = buffer(last_digit)\n+          buffer(last_digit) = buffer(first_digit)\n+          last_digit -= 1\n+          buffer(first_digit) = tmp\n+          first_digit += 1\n+        } while (first_digit < last_digit)\n+\n+        new String(buffer, 0, count)\n+      } else if (i == MIN_VALUE) {\n+        \"-2147483648\"\n+      } else {\n+        val buffer = new Array[Char](11)\n+        var positive_value =\n+          if (i < 0) -i\n+          else i\n+        var first_digit = 0\n+        if (negative) {\n+          buffer(0) = '-'\n+          first_digit += 1\n+        }\n+\n+        var last_digit  = first_digit\n+        var count       = 0\n+        var number: Int = 0\n+        var start       = false\n+        var k           = 0\n+        while (k < 9) {\n+          count = 0\n+          number = decimalScale(k)\n+          if (positive_value < number) {\n+            if (start) {\n+              buffer(last_digit) = '0'\n+              last_digit += 1\n+            }\n+          }\n+\n+          if (k > 0) {\n+            number = decimalScale(k) << 3\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 8\n+            }\n+\n+            number = decimalScale(k) << 2\n+            if (positive_value >= number) {\n+              positive_value -= number\n+              count += 4\n+            }\n+          }\n+\n+          number = decimalScale(k) << 1\n+          if (positive_value >= number) {\n+            positive_value -= number\n+            count += 2\n+          }\n+\n+          if (positive_value >= decimalScale(k)) {\n+            positive_value -= decimalScale(k)\n+            count += 1\n+          }\n+\n+          if (count > 0 && !start) {\n+            start = true\n+          }\n+\n+          if (start) {\n+            buffer(last_digit) = (count + '0').toChar\n+            last_digit += 1\n+          }\n+\n+          k += 1\n+        }\n+\n+        buffer(last_digit) = (positive_value + '0').toChar\n+        last_digit += 1\n+        count = last_digit\n+        last_digit -= 1\n+\n+        new String(buffer, 0, count)\n+      }\n+    }\n+  }\n+\n+  def toString(_i: scala.Int, _radix: scala.Int): String = {\n+    if (_i == 0) {\n+      \"0\"\n+    } else {\n+      val radix =\n+        if (_radix < Character.MIN_RADIX || _radix > Character.MAX_RADIX) 10\n+        else _radix\n+      var i     = _i\n+      var j     = _i\n+      var count = 2\n+      val negative = _i < 0\n+      if (!negative) {\n+        count = 1\n+        j = -i\n+      }\n+      i /= radix\n+      while (i != 0) {\n+        count += 1\n+        i = i / radix\n+      }\n+\n+      val buffer = new Array[Char](count)\n+      do {\n+        var ch = 0 - (j % radix)\n+        if (ch > 9) {\n+          ch = ch - 10 + 'a'\n+        } else {\n+          ch += '0'\n+        }\n+        count -= 1\n+        buffer(count) = ch.toChar\n+        j /= radix\n+      } while (j != 0)\n+\n+      if (negative) {\n+        buffer(0) = '-'\n+      }\n+\n+      new String(buffer)\n+    }\n+  }\n \n-  @inline // because radix is almost certainly constant at call site\n-  def toString(i: Int, radix: Int): String = ???\n+  @inline def toUnsignedLong(x: scala.Int): scala.Long =\n+    intToULong(x)\n \n-  @inline def toUnsignedString(i: scala.Int): String = toUnsignedString(i, 10)\n+  @inline def valueOf(i: scala.Int): Integer =\n+    new Integer(i)"
  },
  {
    "id" : "52645317-51a3-4d96-ae71-b338a8631ff6",
    "prId" : 238,
    "comments" : [
      {
        "id" : "c38ece11-7507-4667-9b1c-9d17e3578445",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Hum, nope, that's not correct. When `i == 2`, `ilz == 2` so your formula gives `count == 2`, but it should be 1.\n\nIt should be `((32 - numberOfLeadingZeros(i)) + 3) / 4`. Essentially it's integer division but with rounding _up_ instead of rounding _down_.\n",
        "createdAt" : "2016-07-12T12:33:01Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b78a2848-0e08-4796-9a1d-3c4a1ed3a87b",
        "parentId" : "c38ece11-7507-4667-9b1c-9d17e3578445",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Fixed.\n",
        "createdAt" : "2016-07-12T12:45:19Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +48,445 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n-\n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n-    if (i == 0) 0\n-    else (1 << 31) >>> numberOfLeadingZeros(i)\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n+    select(i == 0, 0, (1 << 31) >>> numberOfLeadingZeros(i) )\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    val count  = if (i == 0) 1 else 32 - numberOfLeadingZeros(i)\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toHexString(i: scala.Int): String = {\n+    val count =\n+      if (i == 0) 1\n+      else {\n+        val ilz = 32 - numberOfLeadingZeros(i)\n+        ilz / 4 + ilz % 4\n+      }"
  },
  {
    "id" : "836b3351-1639-4277-9436-62d5dbfff3ba",
    "prId" : 238,
    "comments" : [
      {
        "id" : "d3f2ff6d-df1c-4b2f-b3e2-4b03f72786fb",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "Similarly, here it should be ((32 - numberOfLeadingZeros(i)) + 2) / 3`.\n\nAnd then the same for the `Long` versions.\n",
        "createdAt" : "2016-07-12T12:33:29Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c603144-ea49-43dd-887d-51566eea6627",
        "parentId" : "d3f2ff6d-df1c-4b2f-b3e2-4b03f72786fb",
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Fixed.\n",
        "createdAt" : "2016-07-12T12:45:17Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -50,127 +48,445 @@ object Integer {\n   final val SIZE      = 32\n   final val BYTES     = 4\n \n-  @inline def valueOf(intValue: scala.Int): Integer = new Integer(intValue)\n-  @inline def valueOf(s: String): Integer           = valueOf(parseInt(s))\n+  private final val decimalScale: Array[scala.Int] = Array(1000000000,\n+                                                           100000000,\n+                                                           10000000,\n+                                                           1000000,\n+                                                           100000,\n+                                                           10000,\n+                                                           1000,\n+                                                           100,\n+                                                           10,\n+                                                           1)\n+  private final val digits = Array('0',\n+                                   '1',\n+                                   '2',\n+                                   '3',\n+                                   '4',\n+                                   '5',\n+                                   '6',\n+                                   '7',\n+                                   '8',\n+                                   '9',\n+                                   'a',\n+                                   'b',\n+                                   'c',\n+                                   'd',\n+                                   'e',\n+                                   'f',\n+                                   'g',\n+                                   'h',\n+                                   'i',\n+                                   'j',\n+                                   'k',\n+                                   'l',\n+                                   'm',\n+                                   'n',\n+                                   'o',\n+                                   'p',\n+                                   'q',\n+                                   'r',\n+                                   's',\n+                                   't',\n+                                   'u',\n+                                   'v',\n+                                   'w',\n+                                   'x',\n+                                   'y',\n+                                   'z')\n+\n+  @inline def bitCount(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctpop.i32`(i)\n+\n+  @inline def byteValue(i: scala.Int): scala.Byte =\n+    i.toByte\n \n-  @inline def valueOf(s: String, radix: Int): Integer =\n-    valueOf(parseInt(s, radix))\n-\n-  @inline def parseInt(s: String): scala.Int = parseInt(s, 10)\n+  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n+    if (x == y) 0 else if (x < y) -1 else 1\n \n-  @noinline def parseInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = true)\n+  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int =\n+    compare(x ^ scala.Int.MinValue, y ^ scala.Int.MinValue)\n \n-  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+  def decode(nm: String): Integer = {\n+    val length = nm.length()\n+    if (length == 0) throw new NumberFormatException()\n \n-  @noinline def parseUnsignedInt(s: String, radix: scala.Int): scala.Int =\n-    parseIntImpl(s, radix, signed = false)\n+    var i     = 0\n+    var first = nm.charAt(i)\n+    val negative = first == '-'\n+    if (negative) {\n+      if (length == 1) throw new NumberFormatException(nm)\n+      i += 1\n+      first = nm.charAt(i)\n+    }\n \n-  @inline\n-  private def parseIntImpl(s: String,\n-                           radix: scala.Int,\n-                           signed: scala.Boolean): scala.Int = ???\n+    var base = 10\n+    if (first == '0') {\n+      i += 1\n+      if (i == length) return valueOf(0)\n+      first = nm.charAt(i)\n+      if (first == 'x' || first == 'X') {\n+        i += 1\n+        if (i == length) throw new NumberFormatException(nm)\n+        base = 16\n+      } else {\n+        base = 8\n+      }\n+    } else if (first == '#') {\n+      i += 1\n+      if (i == length) throw new NumberFormatException(nm)\n+      base = 16\n+    }\n \n-  @inline def toString(i: scala.Int): String =\n-    ???\n+    valueOf(parse(nm, i, base, negative))\n+  }\n \n-  @inline def toUnsignedString(i: Int, radix: Int): String =\n-    toStringBase(i, radix)\n+  @inline\n+  def divideUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    divUInt(dividend, divisor)\n \n-  @inline def compare(x: scala.Int, y: scala.Int): scala.Int =\n-    if (x == y) 0 else if (x < y) -1 else 1\n+  @inline def getInteger(nm: String): Integer =\n+    getInteger(nm, null)\n \n-  @inline def compareUnsigned(x: scala.Int, y: scala.Int): scala.Int = ???\n-\n-  @inline def toUnsignedLong(x: Int): scala.Long =\n-    x.toLong & 0xffffffffL\n-\n-  def bitCount(i: scala.Int): scala.Int = {\n-    /* See http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n-     *\n-     * The original algorithm uses *logical* shift rights. Here we use\n-     * *arithmetic* shift rights instead. >> is shorter than >>>, especially\n-     * since the latter needs (a >>> b) | 0 in JS. It might also be the case\n-     * that >>> is a bit slower for that reason on some VMs.\n-     *\n-     * Using >> is valid because:\n-     * * For the 2 first >>, the possible sign bit extension is &'ed away\n-     * * For (t2 >> 4), t2 cannot be negative because it is at most the result\n-     *   of 2 * 0x33333333, which does not overflow and is positive.\n-     * * For the last >> 24, the left operand cannot be negative either.\n-     *   Assume it was, that means the result of a >>> would be >= 128, but\n-     *   the correct result must be <= 32. So by contradiction, it is positive.\n-     */\n-    val t1 = i - ((i >> 1) & 0x55555555)\n-    val t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333)\n-    (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24\n+  @inline def getInteger(nm: String, v: scala.Int): Integer = {\n+    val result = getInteger(nm, null)\n+    if (result == null) new Integer(v)\n+    else result\n   }\n \n-  @inline def divideUnsigned(dividend: Int, divisor: Int): Int =\n-    divUInt(dividend, divisor)\n+  def getInteger(nm: String, v: Integer): Integer =\n+    if (nm == null || nm.length() == 0) {\n+      valueOf(v)\n+    } else {\n+      val prop = System.getProperty(nm)\n+      if (prop == null) {\n+        valueOf(v)\n+      } else {\n+        try {\n+          decode(prop)\n+        } catch {\n+          case e: NumberFormatException =>\n+            valueOf(v)\n+        }\n+      }\n+    }\n \n-  @inline def remainderUnsigned(dividend: Int, divisor: Int): Int =\n-    remUInt(dividend, divisor)\n+  @inline def hashCode(value: scala.Int): scala.Int =\n+    value\n \n-  @inline def highestOneBit(i: Int): Int =\n-    if (i == 0) 0\n-    else (1 << 31) >>> numberOfLeadingZeros(i)\n+  @inline def highestOneBit(i: scala.Int): scala.Int =\n+    select(i == 0, 0, (1 << 31) >>> numberOfLeadingZeros(i) )\n \n-  @inline def lowestOneBit(i: Int): Int =\n+  @inline def lowestOneBit(i: scala.Int): scala.Int =\n     i & -i\n \n-  def reverseBytes(i: scala.Int): scala.Int = {\n-    val byte3 = i >>> 24\n-    val byte2 = (i >>> 8) & 0xFF00\n-    val byte1 = (i << 8) & 0xFF0000\n-    val byte0 = i << 24\n-    byte0 | byte1 | byte2 | byte3\n+  @inline def max(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.max(a, b)\n+\n+  @inline def min(a: scala.Int, b: scala.Int): scala.Int =\n+    Math.min(a, b)\n+\n+  @inline def numberOfLeadingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.ctlz.i32`(i, iszeroundef = false)\n+\n+  @inline def numberOfTrailingZeros(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.cttz.i32`(i, iszeroundef = false)\n+\n+  @inline def parseInt(s: String): scala.Int =\n+    parseInt(s, 10)\n+\n+  def parseInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+    val length   = s.length()\n+    val negative = s.charAt(0) == '-'\n+\n+    if (length == 0)\n+      throw new NumberFormatException(s)\n+    else if (negative && length == 1)\n+      throw new NumberFormatException(s)\n+    else\n+      parse(s, 1, radix, negative)\n+  }\n+\n+  private def parse(s: String,\n+                    _offset: scala.Int,\n+                    radix: scala.Int,\n+                    negative: scala.Boolean): scala.Int = {\n+    val max    = MIN_VALUE / radix\n+    val length = s.length()\n+    var result = 0\n+    var offset = _offset\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+      if (digit == -1) throw new NumberFormatException(s)\n+      if (max > result) throw new NumberFormatException(s)\n+\n+      val next = result * radix - digit\n+      if (next > result) throw new NumberFormatException(s)\n+      result = next\n+    }\n+\n+    if (!negative) {\n+      result = -result\n+      if (result < 0) throw new NumberFormatException(s)\n+    }\n+\n+    result\n   }\n \n+  @inline\n+  def remainderUnsigned(dividend: scala.Int, divisor: scala.Int): scala.Int =\n+    remUInt(dividend, divisor)\n+\n+  @inline def reverse(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bitreverse.i32`(i)\n+\n+  @inline def reverseBytes(i: scala.Int): scala.Int =\n+    Intrinsics.`llvm.bswap.i32`(i)\n+\n   @inline def rotateLeft(i: scala.Int, distance: scala.Int): scala.Int =\n     (i << distance) | (i >>> -distance)\n \n   @inline def rotateRight(i: scala.Int, distance: scala.Int): scala.Int =\n     (i >>> distance) | (i << -distance)\n \n   @inline def signum(i: scala.Int): scala.Int =\n-    if (i == 0) 0 else if (i < 0) -1 else 1\n-\n-  // Intrinsic\n-  def numberOfLeadingZeros(i: scala.Int): scala.Int = {\n-    // See Hacker's Delight, Section 5-3\n-    var x = i\n-    if (x == 0) {\n-      32\n+    if (i == 0) 0\n+    else if (i < 0) -1\n+    else 1\n+\n+  @inline def sum(a: scala.Int, b: scala.Int): scala.Int =\n+    a + b\n+\n+  def toBinaryString(i: scala.Int): String = {\n+    val count  = if (i == 0) 1 else 32 - numberOfLeadingZeros(i)\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      count -= 1\n+      buffer(count) = ((k & 1) + '0').toChar\n+      k >>>= 1\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toHexString(i: scala.Int): String = {\n+    val count =\n+      if (i == 0) 1\n+      else {\n+        val ilz = 32 - numberOfLeadingZeros(i)\n+        ilz / 4 + ilz % 4\n+      }\n+    val buffer = new Array[Char](count)\n+    var k = i\n+    do {\n+      var t = k & 15\n+      if (t > 9) {\n+        t = t - 10 + 'a'\n+      } else {\n+        t += '0'\n+      }\n+      count -= 1\n+      buffer(count) = t.toChar\n+      k >>>= 4\n+    } while (count > 0)\n+\n+    new String(buffer)\n+  }\n+\n+  def toOctalString(i: scala.Int): String = {\n+    val count  =\n+      if (i == 0) 1\n+      else {\n+        val ilz = 32 - numberOfLeadingZeros(i)\n+        ilz / 3 + ilz % 3\n+      }"
  },
  {
    "id" : "80d31370-d3c5-42d9-a2b1-17e9b74f91f0",
    "prId" : 344,
    "comments" : [
      {
        "id" : "47f665ea-8dc6-4fe5-ab88-2462dab0d5aa",
        "parentId" : null,
        "author" : {
          "login" : "pbatko",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1202093?v=4"
        },
        "body" : "unused code\n",
        "createdAt" : "2016-10-20T23:04:27Z",
        "updatedAt" : "2016-10-20T23:04:27Z",
        "lastEditedBy" : {
          "login" : "pbatko",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1202093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4e8fc2f0852af09acb1e417971ad9c45fc4b1a00",
    "line" : 4,
    "diffHunk" : "@@ -58,42 +58,6 @@ object Integer {\n                                                            100,\n                                                            10,\n                                                            1)\n-  private final val digits = Array('0',"
  },
  {
    "id" : "5eadf7d6-972a-4cb7-9133-cfa3ef86ff98",
    "prId" : 346,
    "comments" : [
      {
        "id" : "bb5ab9ee-c91e-4748-b586-efc652be3a87",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "One test case for you: `Integer.parseUnsignedInt(\"4294967296\")`. It should fail with `NumberFormatException`, but currently this will succeed and return 0. That's because the (unsigned) addition overflows.\nYou need to test that, after the addition of `digit`, `result` is not smaller than `digit` (which would signal an overflow during the addition):\n\n``` scala\nif (compareUnsigned(result, digit) < 0) throw new NumberFormatException(s)\n```\n",
        "createdAt" : "2016-10-22T09:37:04Z",
        "updatedAt" : "2016-10-24T20:17:08Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "447905ab4bcdb07c44fb14c6049d8537c1120295",
    "line" : null,
    "diffHunk" : "@@ -451,9 +451,80 @@ object Integer {\n   @inline def valueOf(s: String, radix: scala.Int): Integer =\n     valueOf(parseInt(s, radix))\n \n-  // TODO:\n-  // def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n-  // def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = ???\n-  // def toUnsignedString(i: scala.Int): String = toUnsignedString(i, 10)\n-  // def toUnsignedString(_i: scala.Int, _radix: scala.Int): String = ???\n+  @inline def parseUnsignedInt(s: String): scala.Int = parseUnsignedInt(s, 10)\n+\n+  def parseUnsignedInt(s: String, radix: scala.Int): scala.Int = {\n+    if (s == null || radix < Character.MIN_RADIX ||\n+        radix > Character.MAX_RADIX) throw new NumberFormatException(s)\n+\n+    val len = s.length()\n+\n+    if (len == 0) throw new NumberFormatException(s)\n+\n+    val hasPlusSign = s.charAt(0) == '+'\n+\n+    if (hasPlusSign && len == 1) throw new NumberFormatException(s)\n+\n+    val offset = if (hasPlusSign) 1 else 0\n+\n+    parseUnsigned(s, offset, radix)\n+  }\n+\n+  private def parseUnsigned(s: String, _offset: Int, radix: Int): scala.Int = {\n+    val unsignedIntMaxValue = -1\n+    val max                 = divideUnsigned(unsignedIntMaxValue, radix)\n+    var result = 0\n+    var offset = _offset\n+    val length = s.length()\n+\n+    while (offset < length) {\n+      val digit = Character.digit(s.charAt(offset), radix)\n+      offset += 1\n+\n+      if (digit == -1) throw new NumberFormatException(s)\n+\n+      if (compareUnsigned(result, max) == 1) throw new NumberFormatException(s)\n+\n+      result = result * radix + digit\n+    }"
  },
  {
    "id" : "8e22e26c-9c37-42a4-a9fd-b14912107eea",
    "prId" : 346,
    "comments" : [
      {
        "id" : "c6251d43-ea17-4e9c-8cbd-b904670e901a",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "You cannot use comparison after the fact to check for overflow of _multiplication_. That's because multiplication overflow does not \"wrap around\" in any meaningful way. It just overflows and bits are lost.\n\nFor example, in 8 bits, consider `80 * 8`. 80 is `01010000` in binary. If `result == 80`, `radix == 8` and `digit == 0` at this point, then `next = result * radix + digit == 80 * 8 + 0 == 80 << 3 == 01010000b << 3 == 10000000b == 128`. You have `next` is unsigned-greater than `result`, but you had an overflow.\n\nThe previous check with `max` that you had was the good way to test for overflow of the _multiplication_. My addition is the good way to test for overflow of the _addition_. You need both.\n",
        "createdAt" : "2016-10-22T16:16:34Z",
        "updatedAt" : "2016-10-24T20:17:08Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6730c2b7-3502-4aad-a563-c6783f7b1605",
        "parentId" : "c6251d43-ea17-4e9c-8cbd-b904670e901a",
        "author" : {
          "login" : "pbatko",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1202093?v=4"
        },
        "body" : "Thanks for the example. Should be better now.\n",
        "createdAt" : "2016-10-22T17:49:33Z",
        "updatedAt" : "2016-10-24T20:17:08Z",
        "lastEditedBy" : {
          "login" : "pbatko",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/1202093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "447905ab4bcdb07c44fb14c6049d8537c1120295",
    "line" : null,
    "diffHunk" : "@@ -483,9 +482,11 @@ object Integer {\n \n       if (digit == -1) throw new NumberFormatException(s)\n \n-      if (compareUnsigned(result, max) == 1) throw new NumberFormatException(s)\n+      val next = result * radix + digit\n \n-      result = result * radix + digit\n+      if (compareUnsigned(next, result) < 0) throw new NumberFormatException(s)"
  },
  {
    "id" : "22a0e56c-ab54-49d1-9e3f-595c6e1a7778",
    "prId" : 1000,
    "comments" : [
      {
        "id" : "7218da2a-3c0d-4478-951f-b5d0b97905e1",
        "parentId" : null,
        "author" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "body" : "You can do this test with only one branch as `(intValue.toByte.toInt != intValue)`. Same for the `Short` and `Long` cases.",
        "createdAt" : "2017-09-04T15:31:16Z",
        "updatedAt" : "2017-09-05T14:50:02Z",
        "lastEditedBy" : {
          "login" : "sjrd",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/535934?u=837d8ccc05f624946f9fbec6a81ecb1eb519031b&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "06a264eb99f8de9fdf1bfefda5d32e5b0e0e207c",
    "line" : null,
    "diffHunk" : "@@ -564,8 +564,23 @@ object Integer {\n   @inline def toUnsignedLong(x: scala.Int): scala.Long =\n     intToULong(x)\n \n-  @inline def valueOf(i: scala.Int): Integer =\n-    new Integer(i)\n+  import IntegerCache.cache\n+\n+  @inline def valueOf(intValue: scala.Int): Integer = {\n+    if (intValue < -128 || intValue > 127) {"
  }
]
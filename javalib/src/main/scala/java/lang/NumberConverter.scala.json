[
  {
    "id" : "b02bbfa4-e012-4313-8bf3-a9e49b4e60fa",
    "prId" : 212,
    "comments" : [
      {
        "id" : "6640d531-2248-4774-84fc-a3c66327dbec",
        "parentId" : null,
        "author" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "body" : "Needs implementation.\n",
        "createdAt" : "2016-07-13T13:41:37Z",
        "updatedAt" : "2016-07-13T13:41:37Z",
        "lastEditedBy" : {
          "login" : "densh",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/320966?u=784f6f761f35b8b7f3f787172b468334d6524524&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "fde256b043f37f07d62ae5867c2845a877d78287",
    "line" : 207,
    "diffHunk" : "@@ -0,0 +1,296 @@\n+package java.lang\n+\n+private[lang] object NumberConverter {\n+  private val invLogOfTenBaseTwo: scala.Double = Math.log(2.0) / Math.log(10.0)\n+  private val TEN_TO_THE: Array[scala.Long] = {\n+    val TEN_TO_THE = Array[scala.Long](20)\n+    TEN_TO_THE(0) = 1L\n+    var i = 1\n+    while (i < TEN_TO_THE.length) {\n+      val previous = TEN_TO_THE(i - 1)\n+      TEN_TO_THE(i) = (previous << 1) + (previous << 3)\n+      i += 1\n+    }\n+    TEN_TO_THE\n+  }\n+\n+  @inline private def getConverter(): NumberConverter =\n+    new NumberConverter()\n+\n+  @inline def convert(d: scala.Double): String =\n+    getConverter().convertD(d)\n+\n+  @inline def convert(f: scala.Float): String =\n+    getConverter().convertF(f)\n+}\n+\n+private class NumberConverter {\n+  private var setCount: scala.Int = _\n+  private var getCount: scala.Int = _\n+  private val uArray: Array[scala.Int] = new Array[Int](64)\n+  private var firstK: scala.Int = _\n+\n+  @inline def convertD(d: scala.Double): String = {\n+    val p               = 1023 + 52\n+    val signMask        = 0x8000000000000000L\n+    val eMask           = 0x7FF0000000000000L\n+    val fMask           = 0x000FFFFFFFFFFFFFL\n+    val inputNumberBits = Double.doubleToLongBits(d)\n+    val signString =\n+      if ((inputNumberBits & signMask) == 0) \"\"\n+      else \"-\"\n+    val e = ((inputNumberBits & eMask) >> 52).toInt\n+    var f = inputNumberBits & fMask\n+    val mantissaIsZero = f == 0\n+    var pow     = 0\n+    var numBits = 52\n+\n+    if (e == 2047) {\n+      if (mantissaIsZero) signString + \"Infinity\"\n+      else \"NaN\"\n+    } else {\n+      if (e == 0) {\n+        if (mantissaIsZero) return signString + \"0.0\"\n+        if (f == 1) return signString + \"4.9E-324\"\n+\n+        pow = 1 - p\n+        var ff = f\n+        while ((ff & 0x0010000000000000L) == 0) {\n+          ff = ff << 1\n+          numBits -= 1\n+        }\n+      } else {\n+        f = f | 0x0010000000000000L\n+        pow = e - p\n+      }\n+\n+      if (-59 < pow && pow < 6 || (pow == -59 && !mantissaIsZero))\n+        longDigitGenerator(f, pow, e == 0, mantissaIsZero, numBits)\n+      else\n+        bigIntDigitGeneratorInstImpl(f, pow, e == 0, mantissaIsZero, numBits)\n+\n+      if (d >= 1e7D || d <= -1e7D || (d > -1e-3D && d < 1e-3D))\n+        signString + freeFormatExponential()\n+      else\n+        signString + freeFormat()\n+    }\n+  }\n+\n+  @inline def convertF(f: scala.Float): String = {\n+    val p               = 127 + 23\n+    val signMask        = 0x80000000\n+    val eMask           = 0x7F800000\n+    val fMask           = 0x007FFFFF\n+    val inputNumberBits = Float.floatToIntBits(f)\n+    val signString =\n+      if ((inputNumberBits & signMask) == 0) \"\"\n+      else \"-\"\n+    val e = (inputNumberBits & eMask) >> 23\n+    var i = inputNumberBits & fMask\n+    val mantissaIsZero = i == 0\n+    var pow     = 0\n+    var numBits = 23\n+\n+    if (e == 255) {\n+      if (mantissaIsZero) signString + \"Infinity\"\n+      else \"NaN\"\n+    } else {\n+      if (e == 0) {\n+        if (mantissaIsZero) return signString + \"0.0\"\n+\n+        pow = 1 - p\n+        if (i < 8) {\n+          i = i << 2\n+          pow -= 2\n+        }\n+        var ff = i\n+        while ((ff & 0x00800000) == 0) {\n+          ff = ff << 1\n+          numBits -= 1\n+        }\n+      } else {\n+        i = i | 0x00800000\n+        pow = e - p\n+      }\n+\n+      if (-59 < pow && pow < 35 || (pow == -59 && !mantissaIsZero))\n+        longDigitGenerator(i, pow, e == 0, mantissaIsZero, numBits)\n+      else\n+        bigIntDigitGeneratorInstImpl(i, pow, e == 0, mantissaIsZero, numBits)\n+\n+      if (f >= 1e7f || f <= -1e7f || (f > -1e-3f && f < 1e-3f))\n+        signString + freeFormatExponential()\n+      else\n+        signString + freeFormat()\n+    }\n+  }\n+\n+  @inline private def freeFormatExponential(): String = {\n+    val formattedDecimal = new Array[Char](25)\n+    getCount += 1\n+    formattedDecimal(0) = ('0' + uArray(getCount)).toChar\n+    formattedDecimal(1) = '.'\n+    var charPos = 2\n+    var k       = firstK\n+    val expt = k\n+\n+    var i = true\n+    while (i) {\n+      k -= 1\n+      if (getCount >= setCount) i = false\n+\n+      charPos += 1\n+      getCount += 1\n+      formattedDecimal(charPos) = ('0' + uArray(getCount)).toChar\n+    }\n+\n+    if (k == expt - 1) {\n+      charPos += 1\n+      formattedDecimal(charPos) = '0'\n+    }\n+\n+    charPos += 1\n+    formattedDecimal(charPos) = 'E'\n+\n+    new String(formattedDecimal, 0, charPos) + Integer.toString(expt)\n+  }\n+\n+  @inline private def freeFormat(): String = {\n+    val formattedDecimal = new Array[Char](25)\n+    var charPos = 0\n+    var k       = firstK\n+    if (k < 0) {\n+      formattedDecimal(0) = '0'\n+      formattedDecimal(1) = '.'\n+      charPos += 2\n+\n+      var i = k + 1\n+      while (i < 0) {\n+        charPos += 1\n+        formattedDecimal(charPos) = '0'\n+        i += 1\n+      }\n+    }\n+\n+    getCount += 1\n+    var U = uArray(getCount)\n+    do {\n+      if (U != -1) {\n+        charPos += 1\n+        formattedDecimal(charPos) = ('0' + U).toChar\n+      } else if (k >= -1) {\n+        charPos += 1\n+        formattedDecimal(charPos) = '0'\n+      }\n+\n+      if (k == 0) {\n+        charPos += 1\n+        formattedDecimal(charPos) = '.'\n+      }\n+\n+      k -= 1\n+      U =\n+        if (getCount < setCount) {\n+          getCount += 1\n+          uArray(getCount)\n+        } else -1\n+    } while (U != -1 || k >= -1)\n+\n+    new String(formattedDecimal, 0, charPos)\n+  }\n+\n+  // ToDo reimplement from c to scala\n+  def bigIntDigitGeneratorInstImpl(f: scala.Long,\n+                                   e: scala.Int,\n+                                   isDenormalized: scala.Boolean,\n+                                   mantissaIsZero: scala.Boolean,\n+                                   p: scala.Int): Unit = ???"
  }
]